/// GENERATED CODE - DO NOT MODIFY BY HAND
/// *****************************************************
///  FlutterGen
/// *****************************************************

// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: directives_ordering,unnecessary_import,implicit_dynamic_list_literal,deprecated_member_use

class Input$SignUpInput {
  factory Input$SignUpInput({
    required String version,
    required String platform,
    required String first_name,
    required String last_name,
    required String phone_country_id,
    required String mobile_number,
    String? device_token,
    String? device_info,
  }) =>
      Input$SignUpInput._({
        r'version': version,
        r'platform': platform,
        r'first_name': first_name,
        r'last_name': last_name,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        if (device_token != null) r'device_token': device_token,
        if (device_info != null) r'device_info': device_info,
      });

  Input$SignUpInput._(this._$data);

  factory Input$SignUpInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$version = data['version'];
    result$data['version'] = (l$version as String);
    final l$platform = data['platform'];
    result$data['platform'] = (l$platform as String);
    final l$first_name = data['first_name'];
    result$data['first_name'] = (l$first_name as String);
    final l$last_name = data['last_name'];
    result$data['last_name'] = (l$last_name as String);
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    if (data.containsKey('device_token')) {
      final l$device_token = data['device_token'];
      result$data['device_token'] = (l$device_token as String?);
    }
    if (data.containsKey('device_info')) {
      final l$device_info = data['device_info'];
      result$data['device_info'] = (l$device_info as String?);
    }
    return Input$SignUpInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get version => (_$data['version'] as String);

  String get platform => (_$data['platform'] as String);

  String get first_name => (_$data['first_name'] as String);

  String get last_name => (_$data['last_name'] as String);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String? get device_token => (_$data['device_token'] as String?);

  String? get device_info => (_$data['device_info'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$version = version;
    result$data['version'] = l$version;
    final l$platform = platform;
    result$data['platform'] = l$platform;
    final l$first_name = first_name;
    result$data['first_name'] = l$first_name;
    final l$last_name = last_name;
    result$data['last_name'] = l$last_name;
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    if (_$data.containsKey('device_token')) {
      final l$device_token = device_token;
      result$data['device_token'] = l$device_token;
    }
    if (_$data.containsKey('device_info')) {
      final l$device_info = device_info;
      result$data['device_info'] = l$device_info;
    }
    return result$data;
  }

  CopyWith$Input$SignUpInput<Input$SignUpInput> get copyWith =>
      CopyWith$Input$SignUpInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SignUpInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$device_token = device_token;
    final lOther$device_token = other.device_token;
    if (_$data.containsKey('device_token') !=
        other._$data.containsKey('device_token')) {
      return false;
    }
    if (l$device_token != lOther$device_token) {
      return false;
    }
    final l$device_info = device_info;
    final lOther$device_info = other.device_info;
    if (_$data.containsKey('device_info') !=
        other._$data.containsKey('device_info')) {
      return false;
    }
    if (l$device_info != lOther$device_info) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$device_token = device_token;
    final l$device_info = device_info;
    return Object.hashAll([
      l$version,
      l$platform,
      l$first_name,
      l$last_name,
      l$phone_country_id,
      l$mobile_number,
      _$data.containsKey('device_token') ? l$device_token : const {},
      _$data.containsKey('device_info') ? l$device_info : const {},
    ]);
  }
}

abstract class CopyWith$Input$SignUpInput<TRes> {
  factory CopyWith$Input$SignUpInput(
    Input$SignUpInput instance,
    TRes Function(Input$SignUpInput) then,
  ) = _CopyWithImpl$Input$SignUpInput;

  factory CopyWith$Input$SignUpInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SignUpInput;

  TRes call({
    String? version,
    String? platform,
    String? first_name,
    String? last_name,
    String? phone_country_id,
    String? mobile_number,
    String? device_token,
    String? device_info,
  });
}

class _CopyWithImpl$Input$SignUpInput<TRes>
    implements CopyWith$Input$SignUpInput<TRes> {
  _CopyWithImpl$Input$SignUpInput(
    this._instance,
    this._then,
  );

  final Input$SignUpInput _instance;

  final TRes Function(Input$SignUpInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? device_token = _undefined,
    Object? device_info = _undefined,
  }) =>
      _then(Input$SignUpInput._({
        ..._instance._$data,
        if (version != _undefined && version != null)
          'version': (version as String),
        if (platform != _undefined && platform != null)
          'platform': (platform as String),
        if (first_name != _undefined && first_name != null)
          'first_name': (first_name as String),
        if (last_name != _undefined && last_name != null)
          'last_name': (last_name as String),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (device_token != _undefined)
          'device_token': (device_token as String?),
        if (device_info != _undefined) 'device_info': (device_info as String?),
      }));
}

class _CopyWithStubImpl$Input$SignUpInput<TRes>
    implements CopyWith$Input$SignUpInput<TRes> {
  _CopyWithStubImpl$Input$SignUpInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? first_name,
    String? last_name,
    String? phone_country_id,
    String? mobile_number,
    String? device_token,
    String? device_info,
  }) =>
      _res;
}

class Input$SignUpStepTwoInput {
  factory Input$SignUpStepTwoInput({
    required String uuid,
    String? avatar,
    String? file_path,
    required String first_name,
    required String last_name,
    required String email,
    required int gender,
    required String date_of_birth,
    String? bio_data,
    List<String?>? pickler,
    String? country,
    String? state,
    String? city,
    String? latitude,
    String? longitude,
    int? is_social,
    String? phone_country_id,
    String? mobile_number,
    String? referral_from,
  }) =>
      Input$SignUpStepTwoInput._({
        r'uuid': uuid,
        if (avatar != null) r'avatar': avatar,
        if (file_path != null) r'file_path': file_path,
        r'first_name': first_name,
        r'last_name': last_name,
        r'email': email,
        r'gender': gender,
        r'date_of_birth': date_of_birth,
        if (bio_data != null) r'bio_data': bio_data,
        if (pickler != null) r'pickler': pickler,
        if (country != null) r'country': country,
        if (state != null) r'state': state,
        if (city != null) r'city': city,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (is_social != null) r'is_social': is_social,
        if (phone_country_id != null) r'phone_country_id': phone_country_id,
        if (mobile_number != null) r'mobile_number': mobile_number,
        if (referral_from != null) r'referral_from': referral_from,
      });

  Input$SignUpStepTwoInput._(this._$data);

  factory Input$SignUpStepTwoInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    final l$first_name = data['first_name'];
    result$data['first_name'] = (l$first_name as String);
    final l$last_name = data['last_name'];
    result$data['last_name'] = (l$last_name as String);
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$gender = data['gender'];
    result$data['gender'] = (l$gender as int);
    final l$date_of_birth = data['date_of_birth'];
    result$data['date_of_birth'] = (l$date_of_birth as String);
    if (data.containsKey('bio_data')) {
      final l$bio_data = data['bio_data'];
      result$data['bio_data'] = (l$bio_data as String?);
    }
    if (data.containsKey('pickler')) {
      final l$pickler = data['pickler'];
      result$data['pickler'] =
          (l$pickler as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('is_social')) {
      final l$is_social = data['is_social'];
      result$data['is_social'] = (l$is_social as int?);
    }
    if (data.containsKey('phone_country_id')) {
      final l$phone_country_id = data['phone_country_id'];
      result$data['phone_country_id'] = (l$phone_country_id as String?);
    }
    if (data.containsKey('mobile_number')) {
      final l$mobile_number = data['mobile_number'];
      result$data['mobile_number'] = (l$mobile_number as String?);
    }
    if (data.containsKey('referral_from')) {
      final l$referral_from = data['referral_from'];
      result$data['referral_from'] = (l$referral_from as String?);
    }
    return Input$SignUpStepTwoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get avatar => (_$data['avatar'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String get first_name => (_$data['first_name'] as String);

  String get last_name => (_$data['last_name'] as String);

  String get email => (_$data['email'] as String);

  int get gender => (_$data['gender'] as int);

  String get date_of_birth => (_$data['date_of_birth'] as String);

  String? get bio_data => (_$data['bio_data'] as String?);

  List<String?>? get pickler => (_$data['pickler'] as List<String?>?);

  String? get country => (_$data['country'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  int? get is_social => (_$data['is_social'] as int?);

  String? get phone_country_id => (_$data['phone_country_id'] as String?);

  String? get mobile_number => (_$data['mobile_number'] as String?);

  String? get referral_from => (_$data['referral_from'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    final l$first_name = first_name;
    result$data['first_name'] = l$first_name;
    final l$last_name = last_name;
    result$data['last_name'] = l$last_name;
    final l$email = email;
    result$data['email'] = l$email;
    final l$gender = gender;
    result$data['gender'] = l$gender;
    final l$date_of_birth = date_of_birth;
    result$data['date_of_birth'] = l$date_of_birth;
    if (_$data.containsKey('bio_data')) {
      final l$bio_data = bio_data;
      result$data['bio_data'] = l$bio_data;
    }
    if (_$data.containsKey('pickler')) {
      final l$pickler = pickler;
      result$data['pickler'] = l$pickler?.map((e) => e).toList();
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('is_social')) {
      final l$is_social = is_social;
      result$data['is_social'] = l$is_social;
    }
    if (_$data.containsKey('phone_country_id')) {
      final l$phone_country_id = phone_country_id;
      result$data['phone_country_id'] = l$phone_country_id;
    }
    if (_$data.containsKey('mobile_number')) {
      final l$mobile_number = mobile_number;
      result$data['mobile_number'] = l$mobile_number;
    }
    if (_$data.containsKey('referral_from')) {
      final l$referral_from = referral_from;
      result$data['referral_from'] = l$referral_from;
    }
    return result$data;
  }

  CopyWith$Input$SignUpStepTwoInput<Input$SignUpStepTwoInput> get copyWith =>
      CopyWith$Input$SignUpStepTwoInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SignUpStepTwoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$date_of_birth = date_of_birth;
    final lOther$date_of_birth = other.date_of_birth;
    if (l$date_of_birth != lOther$date_of_birth) {
      return false;
    }
    final l$bio_data = bio_data;
    final lOther$bio_data = other.bio_data;
    if (_$data.containsKey('bio_data') !=
        other._$data.containsKey('bio_data')) {
      return false;
    }
    if (l$bio_data != lOther$bio_data) {
      return false;
    }
    final l$pickler = pickler;
    final lOther$pickler = other.pickler;
    if (_$data.containsKey('pickler') != other._$data.containsKey('pickler')) {
      return false;
    }
    if (l$pickler != null && lOther$pickler != null) {
      if (l$pickler.length != lOther$pickler.length) {
        return false;
      }
      for (int i = 0; i < l$pickler.length; i++) {
        final l$pickler$entry = l$pickler[i];
        final lOther$pickler$entry = lOther$pickler[i];
        if (l$pickler$entry != lOther$pickler$entry) {
          return false;
        }
      }
    } else if (l$pickler != lOther$pickler) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$is_social = is_social;
    final lOther$is_social = other.is_social;
    if (_$data.containsKey('is_social') !=
        other._$data.containsKey('is_social')) {
      return false;
    }
    if (l$is_social != lOther$is_social) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (_$data.containsKey('phone_country_id') !=
        other._$data.containsKey('phone_country_id')) {
      return false;
    }
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (_$data.containsKey('mobile_number') !=
        other._$data.containsKey('mobile_number')) {
      return false;
    }
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$referral_from = referral_from;
    final lOther$referral_from = other.referral_from;
    if (_$data.containsKey('referral_from') !=
        other._$data.containsKey('referral_from')) {
      return false;
    }
    if (l$referral_from != lOther$referral_from) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$avatar = avatar;
    final l$file_path = file_path;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$email = email;
    final l$gender = gender;
    final l$date_of_birth = date_of_birth;
    final l$bio_data = bio_data;
    final l$pickler = pickler;
    final l$country = country;
    final l$state = state;
    final l$city = city;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$is_social = is_social;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$referral_from = referral_from;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      l$first_name,
      l$last_name,
      l$email,
      l$gender,
      l$date_of_birth,
      _$data.containsKey('bio_data') ? l$bio_data : const {},
      _$data.containsKey('pickler')
          ? l$pickler == null
              ? null
              : Object.hashAll(l$pickler.map((v) => v))
          : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('is_social') ? l$is_social : const {},
      _$data.containsKey('phone_country_id') ? l$phone_country_id : const {},
      _$data.containsKey('mobile_number') ? l$mobile_number : const {},
      _$data.containsKey('referral_from') ? l$referral_from : const {},
    ]);
  }
}

abstract class CopyWith$Input$SignUpStepTwoInput<TRes> {
  factory CopyWith$Input$SignUpStepTwoInput(
    Input$SignUpStepTwoInput instance,
    TRes Function(Input$SignUpStepTwoInput) then,
  ) = _CopyWithImpl$Input$SignUpStepTwoInput;

  factory CopyWith$Input$SignUpStepTwoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SignUpStepTwoInput;

  TRes call({
    String? uuid,
    String? avatar,
    String? file_path,
    String? first_name,
    String? last_name,
    String? email,
    int? gender,
    String? date_of_birth,
    String? bio_data,
    List<String?>? pickler,
    String? country,
    String? state,
    String? city,
    String? latitude,
    String? longitude,
    int? is_social,
    String? phone_country_id,
    String? mobile_number,
    String? referral_from,
  });
}

class _CopyWithImpl$Input$SignUpStepTwoInput<TRes>
    implements CopyWith$Input$SignUpStepTwoInput<TRes> {
  _CopyWithImpl$Input$SignUpStepTwoInput(
    this._instance,
    this._then,
  );

  final Input$SignUpStepTwoInput _instance;

  final TRes Function(Input$SignUpStepTwoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? avatar = _undefined,
    Object? file_path = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? email = _undefined,
    Object? gender = _undefined,
    Object? date_of_birth = _undefined,
    Object? bio_data = _undefined,
    Object? pickler = _undefined,
    Object? country = _undefined,
    Object? state = _undefined,
    Object? city = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? is_social = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? referral_from = _undefined,
  }) =>
      _then(Input$SignUpStepTwoInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (first_name != _undefined && first_name != null)
          'first_name': (first_name as String),
        if (last_name != _undefined && last_name != null)
          'last_name': (last_name as String),
        if (email != _undefined && email != null) 'email': (email as String),
        if (gender != _undefined && gender != null) 'gender': (gender as int),
        if (date_of_birth != _undefined && date_of_birth != null)
          'date_of_birth': (date_of_birth as String),
        if (bio_data != _undefined) 'bio_data': (bio_data as String?),
        if (pickler != _undefined) 'pickler': (pickler as List<String?>?),
        if (country != _undefined) 'country': (country as String?),
        if (state != _undefined) 'state': (state as String?),
        if (city != _undefined) 'city': (city as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (is_social != _undefined) 'is_social': (is_social as int?),
        if (phone_country_id != _undefined)
          'phone_country_id': (phone_country_id as String?),
        if (mobile_number != _undefined)
          'mobile_number': (mobile_number as String?),
        if (referral_from != _undefined)
          'referral_from': (referral_from as String?),
      }));
}

class _CopyWithStubImpl$Input$SignUpStepTwoInput<TRes>
    implements CopyWith$Input$SignUpStepTwoInput<TRes> {
  _CopyWithStubImpl$Input$SignUpStepTwoInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? avatar,
    String? file_path,
    String? first_name,
    String? last_name,
    String? email,
    int? gender,
    String? date_of_birth,
    String? bio_data,
    List<String?>? pickler,
    String? country,
    String? state,
    String? city,
    String? latitude,
    String? longitude,
    int? is_social,
    String? phone_country_id,
    String? mobile_number,
    String? referral_from,
  }) =>
      _res;
}

class Input$SignUpStepThreeInput {
  factory Input$SignUpStepThreeInput({
    required String uuid,
    String? rating,
    int? is_finish,
    List<String?>? club,
  }) =>
      Input$SignUpStepThreeInput._({
        r'uuid': uuid,
        if (rating != null) r'rating': rating,
        if (is_finish != null) r'is_finish': is_finish,
        if (club != null) r'club': club,
      });

  Input$SignUpStepThreeInput._(this._$data);

  factory Input$SignUpStepThreeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('is_finish')) {
      final l$is_finish = data['is_finish'];
      result$data['is_finish'] = (l$is_finish as int?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    return Input$SignUpStepThreeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get rating => (_$data['rating'] as String?);

  int? get is_finish => (_$data['is_finish'] as int?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('is_finish')) {
      final l$is_finish = is_finish;
      result$data['is_finish'] = l$is_finish;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$SignUpStepThreeInput<Input$SignUpStepThreeInput>
      get copyWith => CopyWith$Input$SignUpStepThreeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SignUpStepThreeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$is_finish = is_finish;
    final lOther$is_finish = other.is_finish;
    if (_$data.containsKey('is_finish') !=
        other._$data.containsKey('is_finish')) {
      return false;
    }
    if (l$is_finish != lOther$is_finish) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$rating = rating;
    final l$is_finish = is_finish;
    final l$club = club;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('is_finish') ? l$is_finish : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SignUpStepThreeInput<TRes> {
  factory CopyWith$Input$SignUpStepThreeInput(
    Input$SignUpStepThreeInput instance,
    TRes Function(Input$SignUpStepThreeInput) then,
  ) = _CopyWithImpl$Input$SignUpStepThreeInput;

  factory CopyWith$Input$SignUpStepThreeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SignUpStepThreeInput;

  TRes call({
    String? uuid,
    String? rating,
    int? is_finish,
    List<String?>? club,
  });
}

class _CopyWithImpl$Input$SignUpStepThreeInput<TRes>
    implements CopyWith$Input$SignUpStepThreeInput<TRes> {
  _CopyWithImpl$Input$SignUpStepThreeInput(
    this._instance,
    this._then,
  );

  final Input$SignUpStepThreeInput _instance;

  final TRes Function(Input$SignUpStepThreeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? rating = _undefined,
    Object? is_finish = _undefined,
    Object? club = _undefined,
  }) =>
      _then(Input$SignUpStepThreeInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (rating != _undefined) 'rating': (rating as String?),
        if (is_finish != _undefined) 'is_finish': (is_finish as int?),
        if (club != _undefined) 'club': (club as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$SignUpStepThreeInput<TRes>
    implements CopyWith$Input$SignUpStepThreeInput<TRes> {
  _CopyWithStubImpl$Input$SignUpStepThreeInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? rating,
    int? is_finish,
    List<String?>? club,
  }) =>
      _res;
}

class Input$SendOTPInput {
  factory Input$SendOTPInput({
    String? version,
    String? platform,
    required String phone_country_id,
    required String mobile_number,
  }) =>
      Input$SendOTPInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
      });

  Input$SendOTPInput._(this._$data);

  factory Input$SendOTPInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    return Input$SendOTPInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    return result$data;
  }

  CopyWith$Input$SendOTPInput<Input$SendOTPInput> get copyWith =>
      CopyWith$Input$SendOTPInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SendOTPInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      l$phone_country_id,
      l$mobile_number,
    ]);
  }
}

abstract class CopyWith$Input$SendOTPInput<TRes> {
  factory CopyWith$Input$SendOTPInput(
    Input$SendOTPInput instance,
    TRes Function(Input$SendOTPInput) then,
  ) = _CopyWithImpl$Input$SendOTPInput;

  factory CopyWith$Input$SendOTPInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SendOTPInput;

  TRes call({
    String? version,
    String? platform,
    String? phone_country_id,
    String? mobile_number,
  });
}

class _CopyWithImpl$Input$SendOTPInput<TRes>
    implements CopyWith$Input$SendOTPInput<TRes> {
  _CopyWithImpl$Input$SendOTPInput(
    this._instance,
    this._then,
  );

  final Input$SendOTPInput _instance;

  final TRes Function(Input$SendOTPInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
  }) =>
      _then(Input$SendOTPInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
      }));
}

class _CopyWithStubImpl$Input$SendOTPInput<TRes>
    implements CopyWith$Input$SendOTPInput<TRes> {
  _CopyWithStubImpl$Input$SendOTPInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? phone_country_id,
    String? mobile_number,
  }) =>
      _res;
}

class Input$VeryfyOtpInput {
  factory Input$VeryfyOtpInput({
    required String phone_country_id,
    required String mobile_number,
    required String otp,
  }) =>
      Input$VeryfyOtpInput._({
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        r'otp': otp,
      });

  Input$VeryfyOtpInput._(this._$data);

  factory Input$VeryfyOtpInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    final l$otp = data['otp'];
    result$data['otp'] = (l$otp as String);
    return Input$VeryfyOtpInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String get otp => (_$data['otp'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    final l$otp = otp;
    result$data['otp'] = l$otp;
    return result$data;
  }

  CopyWith$Input$VeryfyOtpInput<Input$VeryfyOtpInput> get copyWith =>
      CopyWith$Input$VeryfyOtpInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VeryfyOtpInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$otp = otp;
    final lOther$otp = other.otp;
    if (l$otp != lOther$otp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$otp = otp;
    return Object.hashAll([
      l$phone_country_id,
      l$mobile_number,
      l$otp,
    ]);
  }
}

abstract class CopyWith$Input$VeryfyOtpInput<TRes> {
  factory CopyWith$Input$VeryfyOtpInput(
    Input$VeryfyOtpInput instance,
    TRes Function(Input$VeryfyOtpInput) then,
  ) = _CopyWithImpl$Input$VeryfyOtpInput;

  factory CopyWith$Input$VeryfyOtpInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VeryfyOtpInput;

  TRes call({
    String? phone_country_id,
    String? mobile_number,
    String? otp,
  });
}

class _CopyWithImpl$Input$VeryfyOtpInput<TRes>
    implements CopyWith$Input$VeryfyOtpInput<TRes> {
  _CopyWithImpl$Input$VeryfyOtpInput(
    this._instance,
    this._then,
  );

  final Input$VeryfyOtpInput _instance;

  final TRes Function(Input$VeryfyOtpInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? otp = _undefined,
  }) =>
      _then(Input$VeryfyOtpInput._({
        ..._instance._$data,
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (otp != _undefined && otp != null) 'otp': (otp as String),
      }));
}

class _CopyWithStubImpl$Input$VeryfyOtpInput<TRes>
    implements CopyWith$Input$VeryfyOtpInput<TRes> {
  _CopyWithStubImpl$Input$VeryfyOtpInput(this._res);

  TRes _res;

  call({
    String? phone_country_id,
    String? mobile_number,
    String? otp,
  }) =>
      _res;
}

class Input$UserLoginInput {
  factory Input$UserLoginInput({
    required String version,
    required String platform,
    required String phone_country_id,
    required String mobile_number,
    required String otp,
    String? device_token,
    String? device_info,
  }) =>
      Input$UserLoginInput._({
        r'version': version,
        r'platform': platform,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        r'otp': otp,
        if (device_token != null) r'device_token': device_token,
        if (device_info != null) r'device_info': device_info,
      });

  Input$UserLoginInput._(this._$data);

  factory Input$UserLoginInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$version = data['version'];
    result$data['version'] = (l$version as String);
    final l$platform = data['platform'];
    result$data['platform'] = (l$platform as String);
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    final l$otp = data['otp'];
    result$data['otp'] = (l$otp as String);
    if (data.containsKey('device_token')) {
      final l$device_token = data['device_token'];
      result$data['device_token'] = (l$device_token as String?);
    }
    if (data.containsKey('device_info')) {
      final l$device_info = data['device_info'];
      result$data['device_info'] = (l$device_info as String?);
    }
    return Input$UserLoginInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get version => (_$data['version'] as String);

  String get platform => (_$data['platform'] as String);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String get otp => (_$data['otp'] as String);

  String? get device_token => (_$data['device_token'] as String?);

  String? get device_info => (_$data['device_info'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$version = version;
    result$data['version'] = l$version;
    final l$platform = platform;
    result$data['platform'] = l$platform;
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    final l$otp = otp;
    result$data['otp'] = l$otp;
    if (_$data.containsKey('device_token')) {
      final l$device_token = device_token;
      result$data['device_token'] = l$device_token;
    }
    if (_$data.containsKey('device_info')) {
      final l$device_info = device_info;
      result$data['device_info'] = l$device_info;
    }
    return result$data;
  }

  CopyWith$Input$UserLoginInput<Input$UserLoginInput> get copyWith =>
      CopyWith$Input$UserLoginInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserLoginInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$otp = otp;
    final lOther$otp = other.otp;
    if (l$otp != lOther$otp) {
      return false;
    }
    final l$device_token = device_token;
    final lOther$device_token = other.device_token;
    if (_$data.containsKey('device_token') !=
        other._$data.containsKey('device_token')) {
      return false;
    }
    if (l$device_token != lOther$device_token) {
      return false;
    }
    final l$device_info = device_info;
    final lOther$device_info = other.device_info;
    if (_$data.containsKey('device_info') !=
        other._$data.containsKey('device_info')) {
      return false;
    }
    if (l$device_info != lOther$device_info) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$otp = otp;
    final l$device_token = device_token;
    final l$device_info = device_info;
    return Object.hashAll([
      l$version,
      l$platform,
      l$phone_country_id,
      l$mobile_number,
      l$otp,
      _$data.containsKey('device_token') ? l$device_token : const {},
      _$data.containsKey('device_info') ? l$device_info : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserLoginInput<TRes> {
  factory CopyWith$Input$UserLoginInput(
    Input$UserLoginInput instance,
    TRes Function(Input$UserLoginInput) then,
  ) = _CopyWithImpl$Input$UserLoginInput;

  factory CopyWith$Input$UserLoginInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserLoginInput;

  TRes call({
    String? version,
    String? platform,
    String? phone_country_id,
    String? mobile_number,
    String? otp,
    String? device_token,
    String? device_info,
  });
}

class _CopyWithImpl$Input$UserLoginInput<TRes>
    implements CopyWith$Input$UserLoginInput<TRes> {
  _CopyWithImpl$Input$UserLoginInput(
    this._instance,
    this._then,
  );

  final Input$UserLoginInput _instance;

  final TRes Function(Input$UserLoginInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? otp = _undefined,
    Object? device_token = _undefined,
    Object? device_info = _undefined,
  }) =>
      _then(Input$UserLoginInput._({
        ..._instance._$data,
        if (version != _undefined && version != null)
          'version': (version as String),
        if (platform != _undefined && platform != null)
          'platform': (platform as String),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (otp != _undefined && otp != null) 'otp': (otp as String),
        if (device_token != _undefined)
          'device_token': (device_token as String?),
        if (device_info != _undefined) 'device_info': (device_info as String?),
      }));
}

class _CopyWithStubImpl$Input$UserLoginInput<TRes>
    implements CopyWith$Input$UserLoginInput<TRes> {
  _CopyWithStubImpl$Input$UserLoginInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? phone_country_id,
    String? mobile_number,
    String? otp,
    String? device_token,
    String? device_info,
  }) =>
      _res;
}

class Input$ClubInput {
  factory Input$ClubInput({
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? club_type,
    String? user_uuid,
  }) =>
      Input$ClubInput._({
        if (name != null) r'name': name,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (club_type != null) r'club_type': club_type,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$ClubInput._(this._$data);

  factory Input$ClubInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$ClubInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$ClubInput<Input$ClubInput> get copyWith =>
      CopyWith$Input$ClubInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClubInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$is_membership_requre = is_membership_requre;
    final l$club_type = club_type;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClubInput<TRes> {
  factory CopyWith$Input$ClubInput(
    Input$ClubInput instance,
    TRes Function(Input$ClubInput) then,
  ) = _CopyWithImpl$Input$ClubInput;

  factory CopyWith$Input$ClubInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClubInput;

  TRes call({
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? club_type,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$ClubInput<TRes>
    implements CopyWith$Input$ClubInput<TRes> {
  _CopyWithImpl$Input$ClubInput(
    this._instance,
    this._then,
  );

  final Input$ClubInput _instance;

  final TRes Function(Input$ClubInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? is_membership_requre = _undefined,
    Object? club_type = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$ClubInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$ClubInput<TRes>
    implements CopyWith$Input$ClubInput<TRes> {
  _CopyWithStubImpl$Input$ClubInput(this._res);

  TRes _res;

  call({
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? club_type,
    String? user_uuid,
  }) =>
      _res;
}

class Input$clubMemberPaginationInput {
  factory Input$clubMemberPaginationInput({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$clubMemberPaginationInput._({
        if (uuid != null) r'uuid': uuid,
        if (full_name != null) r'full_name': full_name,
        if (rating != null) r'rating': rating,
        if (gender != null) r'gender': gender,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (recommendation != null) r'recommendation': recommendation,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$clubMemberPaginationInput._(this._$data);

  factory Input$clubMemberPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$clubMemberPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get gender => (_$data['gender'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  String? get recommendation => (_$data['recommendation'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$clubMemberPaginationInput<Input$clubMemberPaginationInput>
      get copyWith => CopyWith$Input$clubMemberPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$clubMemberPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$full_name = full_name;
    final l$rating = rating;
    final l$gender = gender;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$recommendation = recommendation;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$clubMemberPaginationInput<TRes> {
  factory CopyWith$Input$clubMemberPaginationInput(
    Input$clubMemberPaginationInput instance,
    TRes Function(Input$clubMemberPaginationInput) then,
  ) = _CopyWithImpl$Input$clubMemberPaginationInput;

  factory CopyWith$Input$clubMemberPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$clubMemberPaginationInput;

  TRes call({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$clubMemberPaginationInput<TRes>
    implements CopyWith$Input$clubMemberPaginationInput<TRes> {
  _CopyWithImpl$Input$clubMemberPaginationInput(
    this._instance,
    this._then,
  );

  final Input$clubMemberPaginationInput _instance;

  final TRes Function(Input$clubMemberPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? full_name = _undefined,
    Object? rating = _undefined,
    Object? gender = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? recommendation = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$clubMemberPaginationInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$clubMemberPaginationInput<TRes>
    implements CopyWith$Input$clubMemberPaginationInput<TRes> {
  _CopyWithStubImpl$Input$clubMemberPaginationInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$getClubDetailInput {
  factory Input$getClubDetailInput({String? uuid}) =>
      Input$getClubDetailInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$getClubDetailInput._(this._$data);

  factory Input$getClubDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$getClubDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$getClubDetailInput<Input$getClubDetailInput> get copyWith =>
      CopyWith$Input$getClubDetailInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getClubDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$getClubDetailInput<TRes> {
  factory CopyWith$Input$getClubDetailInput(
    Input$getClubDetailInput instance,
    TRes Function(Input$getClubDetailInput) then,
  ) = _CopyWithImpl$Input$getClubDetailInput;

  factory CopyWith$Input$getClubDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getClubDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$getClubDetailInput<TRes>
    implements CopyWith$Input$getClubDetailInput<TRes> {
  _CopyWithImpl$Input$getClubDetailInput(
    this._instance,
    this._then,
  );

  final Input$getClubDetailInput _instance;

  final TRes Function(Input$getClubDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$getClubDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$getClubDetailInput<TRes>
    implements CopyWith$Input$getClubDetailInput<TRes> {
  _CopyWithStubImpl$Input$getClubDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$LoginLogInput {
  factory Input$LoginLogInput({
    String? user_uuid,
    String? version,
    String? plateform,
  }) =>
      Input$LoginLogInput._({
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (version != null) r'version': version,
        if (plateform != null) r'plateform': plateform,
      });

  Input$LoginLogInput._(this._$data);

  factory Input$LoginLogInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('plateform')) {
      final l$plateform = data['plateform'];
      result$data['plateform'] = (l$plateform as String?);
    }
    return Input$LoginLogInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get version => (_$data['version'] as String?);

  String? get plateform => (_$data['plateform'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('plateform')) {
      final l$plateform = plateform;
      result$data['plateform'] = l$plateform;
    }
    return result$data;
  }

  CopyWith$Input$LoginLogInput<Input$LoginLogInput> get copyWith =>
      CopyWith$Input$LoginLogInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LoginLogInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$plateform = plateform;
    final lOther$plateform = other.plateform;
    if (_$data.containsKey('plateform') !=
        other._$data.containsKey('plateform')) {
      return false;
    }
    if (l$plateform != lOther$plateform) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    final l$version = version;
    final l$plateform = plateform;
    return Object.hashAll([
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('plateform') ? l$plateform : const {},
    ]);
  }
}

abstract class CopyWith$Input$LoginLogInput<TRes> {
  factory CopyWith$Input$LoginLogInput(
    Input$LoginLogInput instance,
    TRes Function(Input$LoginLogInput) then,
  ) = _CopyWithImpl$Input$LoginLogInput;

  factory CopyWith$Input$LoginLogInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LoginLogInput;

  TRes call({
    String? user_uuid,
    String? version,
    String? plateform,
  });
}

class _CopyWithImpl$Input$LoginLogInput<TRes>
    implements CopyWith$Input$LoginLogInput<TRes> {
  _CopyWithImpl$Input$LoginLogInput(
    this._instance,
    this._then,
  );

  final Input$LoginLogInput _instance;

  final TRes Function(Input$LoginLogInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_uuid = _undefined,
    Object? version = _undefined,
    Object? plateform = _undefined,
  }) =>
      _then(Input$LoginLogInput._({
        ..._instance._$data,
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (version != _undefined) 'version': (version as String?),
        if (plateform != _undefined) 'plateform': (plateform as String?),
      }));
}

class _CopyWithStubImpl$Input$LoginLogInput<TRes>
    implements CopyWith$Input$LoginLogInput<TRes> {
  _CopyWithStubImpl$Input$LoginLogInput(this._res);

  TRes _res;

  call({
    String? user_uuid,
    String? version,
    String? plateform,
  }) =>
      _res;
}

class Input$UserClubCreateInput {
  factory Input$UserClubCreateInput({
    String? user_uuid,
    required String name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? note,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? cost,
    String? court_type,
    String? country_code,
    String? start_time,
    String? end_time,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    int? is_register,
    String? short_address,
  }) =>
      Input$UserClubCreateInput._({
        if (user_uuid != null) r'user_uuid': user_uuid,
        r'name': name,
        if (address != null) r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (type != null) r'type': type,
        if (url != null) r'url': url,
        if (note != null) r'note': note,
        if (phone_number != null) r'phone_number': phone_number,
        if (number_of_member != null) r'number_of_member': number_of_member,
        if (number_of_courts != null) r'number_of_courts': number_of_courts,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (cost != null) r'cost': cost,
        if (court_type != null) r'court_type': court_type,
        if (country_code != null) r'country_code': country_code,
        if (start_time != null) r'start_time': start_time,
        if (end_time != null) r'end_time': end_time,
        if (start_time_mon != null) r'start_time_mon': start_time_mon,
        if (end_time_mon != null) r'end_time_mon': end_time_mon,
        if (start_time_tue != null) r'start_time_tue': start_time_tue,
        if (end_time_tue != null) r'end_time_tue': end_time_tue,
        if (start_time_wed != null) r'start_time_wed': start_time_wed,
        if (end_time_wed != null) r'end_time_wed': end_time_wed,
        if (start_time_thu != null) r'start_time_thu': start_time_thu,
        if (end_time_thu != null) r'end_time_thu': end_time_thu,
        if (start_time_fri != null) r'start_time_fri': start_time_fri,
        if (end_time_fri != null) r'end_time_fri': end_time_fri,
        if (start_time_sat != null) r'start_time_sat': start_time_sat,
        if (end_time_sat != null) r'end_time_sat': end_time_sat,
        if (start_time_sun != null) r'start_time_sun': start_time_sun,
        if (end_time_sun != null) r'end_time_sun': end_time_sun,
        if (is_mon_on != null) r'is_mon_on': is_mon_on,
        if (is_tue_on != null) r'is_tue_on': is_tue_on,
        if (is_wed_on != null) r'is_wed_on': is_wed_on,
        if (is_thu_on != null) r'is_thu_on': is_thu_on,
        if (is_fri_on != null) r'is_fri_on': is_fri_on,
        if (is_sat_on != null) r'is_sat_on': is_sat_on,
        if (is_sun_on != null) r'is_sun_on': is_sun_on,
        if (is_register != null) r'is_register': is_register,
        if (short_address != null) r'short_address': short_address,
      });

  Input$UserClubCreateInput._(this._$data);

  factory Input$UserClubCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('phone_number')) {
      final l$phone_number = data['phone_number'];
      result$data['phone_number'] = (l$phone_number as String?);
    }
    if (data.containsKey('number_of_member')) {
      final l$number_of_member = data['number_of_member'];
      result$data['number_of_member'] = (l$number_of_member as String?);
    }
    if (data.containsKey('number_of_courts')) {
      final l$number_of_courts = data['number_of_courts'];
      result$data['number_of_courts'] = (l$number_of_courts as String?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('cost')) {
      final l$cost = data['cost'];
      result$data['cost'] = (l$cost as String?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    if (data.containsKey('country_code')) {
      final l$country_code = data['country_code'];
      result$data['country_code'] = (l$country_code as String?);
    }
    if (data.containsKey('start_time')) {
      final l$start_time = data['start_time'];
      result$data['start_time'] = (l$start_time as String?);
    }
    if (data.containsKey('end_time')) {
      final l$end_time = data['end_time'];
      result$data['end_time'] = (l$end_time as String?);
    }
    if (data.containsKey('start_time_mon')) {
      final l$start_time_mon = data['start_time_mon'];
      result$data['start_time_mon'] = (l$start_time_mon as String?);
    }
    if (data.containsKey('end_time_mon')) {
      final l$end_time_mon = data['end_time_mon'];
      result$data['end_time_mon'] = (l$end_time_mon as String?);
    }
    if (data.containsKey('start_time_tue')) {
      final l$start_time_tue = data['start_time_tue'];
      result$data['start_time_tue'] = (l$start_time_tue as String?);
    }
    if (data.containsKey('end_time_tue')) {
      final l$end_time_tue = data['end_time_tue'];
      result$data['end_time_tue'] = (l$end_time_tue as String?);
    }
    if (data.containsKey('start_time_wed')) {
      final l$start_time_wed = data['start_time_wed'];
      result$data['start_time_wed'] = (l$start_time_wed as String?);
    }
    if (data.containsKey('end_time_wed')) {
      final l$end_time_wed = data['end_time_wed'];
      result$data['end_time_wed'] = (l$end_time_wed as String?);
    }
    if (data.containsKey('start_time_thu')) {
      final l$start_time_thu = data['start_time_thu'];
      result$data['start_time_thu'] = (l$start_time_thu as String?);
    }
    if (data.containsKey('end_time_thu')) {
      final l$end_time_thu = data['end_time_thu'];
      result$data['end_time_thu'] = (l$end_time_thu as String?);
    }
    if (data.containsKey('start_time_fri')) {
      final l$start_time_fri = data['start_time_fri'];
      result$data['start_time_fri'] = (l$start_time_fri as String?);
    }
    if (data.containsKey('end_time_fri')) {
      final l$end_time_fri = data['end_time_fri'];
      result$data['end_time_fri'] = (l$end_time_fri as String?);
    }
    if (data.containsKey('start_time_sat')) {
      final l$start_time_sat = data['start_time_sat'];
      result$data['start_time_sat'] = (l$start_time_sat as String?);
    }
    if (data.containsKey('end_time_sat')) {
      final l$end_time_sat = data['end_time_sat'];
      result$data['end_time_sat'] = (l$end_time_sat as String?);
    }
    if (data.containsKey('start_time_sun')) {
      final l$start_time_sun = data['start_time_sun'];
      result$data['start_time_sun'] = (l$start_time_sun as String?);
    }
    if (data.containsKey('end_time_sun')) {
      final l$end_time_sun = data['end_time_sun'];
      result$data['end_time_sun'] = (l$end_time_sun as String?);
    }
    if (data.containsKey('is_mon_on')) {
      final l$is_mon_on = data['is_mon_on'];
      result$data['is_mon_on'] = (l$is_mon_on as bool?);
    }
    if (data.containsKey('is_tue_on')) {
      final l$is_tue_on = data['is_tue_on'];
      result$data['is_tue_on'] = (l$is_tue_on as bool?);
    }
    if (data.containsKey('is_wed_on')) {
      final l$is_wed_on = data['is_wed_on'];
      result$data['is_wed_on'] = (l$is_wed_on as bool?);
    }
    if (data.containsKey('is_thu_on')) {
      final l$is_thu_on = data['is_thu_on'];
      result$data['is_thu_on'] = (l$is_thu_on as bool?);
    }
    if (data.containsKey('is_fri_on')) {
      final l$is_fri_on = data['is_fri_on'];
      result$data['is_fri_on'] = (l$is_fri_on as bool?);
    }
    if (data.containsKey('is_sat_on')) {
      final l$is_sat_on = data['is_sat_on'];
      result$data['is_sat_on'] = (l$is_sat_on as bool?);
    }
    if (data.containsKey('is_sun_on')) {
      final l$is_sun_on = data['is_sun_on'];
      result$data['is_sun_on'] = (l$is_sun_on as bool?);
    }
    if (data.containsKey('is_register')) {
      final l$is_register = data['is_register'];
      result$data['is_register'] = (l$is_register as int?);
    }
    if (data.containsKey('short_address')) {
      final l$short_address = data['short_address'];
      result$data['short_address'] = (l$short_address as String?);
    }
    return Input$UserClubCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String get name => (_$data['name'] as String);

  String? get address => (_$data['address'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get type => (_$data['type'] as String?);

  String? get url => (_$data['url'] as String?);

  String? get note => (_$data['note'] as String?);

  String? get phone_number => (_$data['phone_number'] as String?);

  String? get number_of_member => (_$data['number_of_member'] as String?);

  String? get number_of_courts => (_$data['number_of_courts'] as String?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get cost => (_$data['cost'] as String?);

  String? get court_type => (_$data['court_type'] as String?);

  String? get country_code => (_$data['country_code'] as String?);

  String? get start_time => (_$data['start_time'] as String?);

  String? get end_time => (_$data['end_time'] as String?);

  String? get start_time_mon => (_$data['start_time_mon'] as String?);

  String? get end_time_mon => (_$data['end_time_mon'] as String?);

  String? get start_time_tue => (_$data['start_time_tue'] as String?);

  String? get end_time_tue => (_$data['end_time_tue'] as String?);

  String? get start_time_wed => (_$data['start_time_wed'] as String?);

  String? get end_time_wed => (_$data['end_time_wed'] as String?);

  String? get start_time_thu => (_$data['start_time_thu'] as String?);

  String? get end_time_thu => (_$data['end_time_thu'] as String?);

  String? get start_time_fri => (_$data['start_time_fri'] as String?);

  String? get end_time_fri => (_$data['end_time_fri'] as String?);

  String? get start_time_sat => (_$data['start_time_sat'] as String?);

  String? get end_time_sat => (_$data['end_time_sat'] as String?);

  String? get start_time_sun => (_$data['start_time_sun'] as String?);

  String? get end_time_sun => (_$data['end_time_sun'] as String?);

  bool? get is_mon_on => (_$data['is_mon_on'] as bool?);

  bool? get is_tue_on => (_$data['is_tue_on'] as bool?);

  bool? get is_wed_on => (_$data['is_wed_on'] as bool?);

  bool? get is_thu_on => (_$data['is_thu_on'] as bool?);

  bool? get is_fri_on => (_$data['is_fri_on'] as bool?);

  bool? get is_sat_on => (_$data['is_sat_on'] as bool?);

  bool? get is_sun_on => (_$data['is_sun_on'] as bool?);

  int? get is_register => (_$data['is_register'] as int?);

  String? get short_address => (_$data['short_address'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('phone_number')) {
      final l$phone_number = phone_number;
      result$data['phone_number'] = l$phone_number;
    }
    if (_$data.containsKey('number_of_member')) {
      final l$number_of_member = number_of_member;
      result$data['number_of_member'] = l$number_of_member;
    }
    if (_$data.containsKey('number_of_courts')) {
      final l$number_of_courts = number_of_courts;
      result$data['number_of_courts'] = l$number_of_courts;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('cost')) {
      final l$cost = cost;
      result$data['cost'] = l$cost;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    if (_$data.containsKey('country_code')) {
      final l$country_code = country_code;
      result$data['country_code'] = l$country_code;
    }
    if (_$data.containsKey('start_time')) {
      final l$start_time = start_time;
      result$data['start_time'] = l$start_time;
    }
    if (_$data.containsKey('end_time')) {
      final l$end_time = end_time;
      result$data['end_time'] = l$end_time;
    }
    if (_$data.containsKey('start_time_mon')) {
      final l$start_time_mon = start_time_mon;
      result$data['start_time_mon'] = l$start_time_mon;
    }
    if (_$data.containsKey('end_time_mon')) {
      final l$end_time_mon = end_time_mon;
      result$data['end_time_mon'] = l$end_time_mon;
    }
    if (_$data.containsKey('start_time_tue')) {
      final l$start_time_tue = start_time_tue;
      result$data['start_time_tue'] = l$start_time_tue;
    }
    if (_$data.containsKey('end_time_tue')) {
      final l$end_time_tue = end_time_tue;
      result$data['end_time_tue'] = l$end_time_tue;
    }
    if (_$data.containsKey('start_time_wed')) {
      final l$start_time_wed = start_time_wed;
      result$data['start_time_wed'] = l$start_time_wed;
    }
    if (_$data.containsKey('end_time_wed')) {
      final l$end_time_wed = end_time_wed;
      result$data['end_time_wed'] = l$end_time_wed;
    }
    if (_$data.containsKey('start_time_thu')) {
      final l$start_time_thu = start_time_thu;
      result$data['start_time_thu'] = l$start_time_thu;
    }
    if (_$data.containsKey('end_time_thu')) {
      final l$end_time_thu = end_time_thu;
      result$data['end_time_thu'] = l$end_time_thu;
    }
    if (_$data.containsKey('start_time_fri')) {
      final l$start_time_fri = start_time_fri;
      result$data['start_time_fri'] = l$start_time_fri;
    }
    if (_$data.containsKey('end_time_fri')) {
      final l$end_time_fri = end_time_fri;
      result$data['end_time_fri'] = l$end_time_fri;
    }
    if (_$data.containsKey('start_time_sat')) {
      final l$start_time_sat = start_time_sat;
      result$data['start_time_sat'] = l$start_time_sat;
    }
    if (_$data.containsKey('end_time_sat')) {
      final l$end_time_sat = end_time_sat;
      result$data['end_time_sat'] = l$end_time_sat;
    }
    if (_$data.containsKey('start_time_sun')) {
      final l$start_time_sun = start_time_sun;
      result$data['start_time_sun'] = l$start_time_sun;
    }
    if (_$data.containsKey('end_time_sun')) {
      final l$end_time_sun = end_time_sun;
      result$data['end_time_sun'] = l$end_time_sun;
    }
    if (_$data.containsKey('is_mon_on')) {
      final l$is_mon_on = is_mon_on;
      result$data['is_mon_on'] = l$is_mon_on;
    }
    if (_$data.containsKey('is_tue_on')) {
      final l$is_tue_on = is_tue_on;
      result$data['is_tue_on'] = l$is_tue_on;
    }
    if (_$data.containsKey('is_wed_on')) {
      final l$is_wed_on = is_wed_on;
      result$data['is_wed_on'] = l$is_wed_on;
    }
    if (_$data.containsKey('is_thu_on')) {
      final l$is_thu_on = is_thu_on;
      result$data['is_thu_on'] = l$is_thu_on;
    }
    if (_$data.containsKey('is_fri_on')) {
      final l$is_fri_on = is_fri_on;
      result$data['is_fri_on'] = l$is_fri_on;
    }
    if (_$data.containsKey('is_sat_on')) {
      final l$is_sat_on = is_sat_on;
      result$data['is_sat_on'] = l$is_sat_on;
    }
    if (_$data.containsKey('is_sun_on')) {
      final l$is_sun_on = is_sun_on;
      result$data['is_sun_on'] = l$is_sun_on;
    }
    if (_$data.containsKey('is_register')) {
      final l$is_register = is_register;
      result$data['is_register'] = l$is_register;
    }
    if (_$data.containsKey('short_address')) {
      final l$short_address = short_address;
      result$data['short_address'] = l$short_address;
    }
    return result$data;
  }

  CopyWith$Input$UserClubCreateInput<Input$UserClubCreateInput> get copyWith =>
      CopyWith$Input$UserClubCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserClubCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$phone_number = phone_number;
    final lOther$phone_number = other.phone_number;
    if (_$data.containsKey('phone_number') !=
        other._$data.containsKey('phone_number')) {
      return false;
    }
    if (l$phone_number != lOther$phone_number) {
      return false;
    }
    final l$number_of_member = number_of_member;
    final lOther$number_of_member = other.number_of_member;
    if (_$data.containsKey('number_of_member') !=
        other._$data.containsKey('number_of_member')) {
      return false;
    }
    if (l$number_of_member != lOther$number_of_member) {
      return false;
    }
    final l$number_of_courts = number_of_courts;
    final lOther$number_of_courts = other.number_of_courts;
    if (_$data.containsKey('number_of_courts') !=
        other._$data.containsKey('number_of_courts')) {
      return false;
    }
    if (l$number_of_courts != lOther$number_of_courts) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$cost = cost;
    final lOther$cost = other.cost;
    if (_$data.containsKey('cost') != other._$data.containsKey('cost')) {
      return false;
    }
    if (l$cost != lOther$cost) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    final l$country_code = country_code;
    final lOther$country_code = other.country_code;
    if (_$data.containsKey('country_code') !=
        other._$data.containsKey('country_code')) {
      return false;
    }
    if (l$country_code != lOther$country_code) {
      return false;
    }
    final l$start_time = start_time;
    final lOther$start_time = other.start_time;
    if (_$data.containsKey('start_time') !=
        other._$data.containsKey('start_time')) {
      return false;
    }
    if (l$start_time != lOther$start_time) {
      return false;
    }
    final l$end_time = end_time;
    final lOther$end_time = other.end_time;
    if (_$data.containsKey('end_time') !=
        other._$data.containsKey('end_time')) {
      return false;
    }
    if (l$end_time != lOther$end_time) {
      return false;
    }
    final l$start_time_mon = start_time_mon;
    final lOther$start_time_mon = other.start_time_mon;
    if (_$data.containsKey('start_time_mon') !=
        other._$data.containsKey('start_time_mon')) {
      return false;
    }
    if (l$start_time_mon != lOther$start_time_mon) {
      return false;
    }
    final l$end_time_mon = end_time_mon;
    final lOther$end_time_mon = other.end_time_mon;
    if (_$data.containsKey('end_time_mon') !=
        other._$data.containsKey('end_time_mon')) {
      return false;
    }
    if (l$end_time_mon != lOther$end_time_mon) {
      return false;
    }
    final l$start_time_tue = start_time_tue;
    final lOther$start_time_tue = other.start_time_tue;
    if (_$data.containsKey('start_time_tue') !=
        other._$data.containsKey('start_time_tue')) {
      return false;
    }
    if (l$start_time_tue != lOther$start_time_tue) {
      return false;
    }
    final l$end_time_tue = end_time_tue;
    final lOther$end_time_tue = other.end_time_tue;
    if (_$data.containsKey('end_time_tue') !=
        other._$data.containsKey('end_time_tue')) {
      return false;
    }
    if (l$end_time_tue != lOther$end_time_tue) {
      return false;
    }
    final l$start_time_wed = start_time_wed;
    final lOther$start_time_wed = other.start_time_wed;
    if (_$data.containsKey('start_time_wed') !=
        other._$data.containsKey('start_time_wed')) {
      return false;
    }
    if (l$start_time_wed != lOther$start_time_wed) {
      return false;
    }
    final l$end_time_wed = end_time_wed;
    final lOther$end_time_wed = other.end_time_wed;
    if (_$data.containsKey('end_time_wed') !=
        other._$data.containsKey('end_time_wed')) {
      return false;
    }
    if (l$end_time_wed != lOther$end_time_wed) {
      return false;
    }
    final l$start_time_thu = start_time_thu;
    final lOther$start_time_thu = other.start_time_thu;
    if (_$data.containsKey('start_time_thu') !=
        other._$data.containsKey('start_time_thu')) {
      return false;
    }
    if (l$start_time_thu != lOther$start_time_thu) {
      return false;
    }
    final l$end_time_thu = end_time_thu;
    final lOther$end_time_thu = other.end_time_thu;
    if (_$data.containsKey('end_time_thu') !=
        other._$data.containsKey('end_time_thu')) {
      return false;
    }
    if (l$end_time_thu != lOther$end_time_thu) {
      return false;
    }
    final l$start_time_fri = start_time_fri;
    final lOther$start_time_fri = other.start_time_fri;
    if (_$data.containsKey('start_time_fri') !=
        other._$data.containsKey('start_time_fri')) {
      return false;
    }
    if (l$start_time_fri != lOther$start_time_fri) {
      return false;
    }
    final l$end_time_fri = end_time_fri;
    final lOther$end_time_fri = other.end_time_fri;
    if (_$data.containsKey('end_time_fri') !=
        other._$data.containsKey('end_time_fri')) {
      return false;
    }
    if (l$end_time_fri != lOther$end_time_fri) {
      return false;
    }
    final l$start_time_sat = start_time_sat;
    final lOther$start_time_sat = other.start_time_sat;
    if (_$data.containsKey('start_time_sat') !=
        other._$data.containsKey('start_time_sat')) {
      return false;
    }
    if (l$start_time_sat != lOther$start_time_sat) {
      return false;
    }
    final l$end_time_sat = end_time_sat;
    final lOther$end_time_sat = other.end_time_sat;
    if (_$data.containsKey('end_time_sat') !=
        other._$data.containsKey('end_time_sat')) {
      return false;
    }
    if (l$end_time_sat != lOther$end_time_sat) {
      return false;
    }
    final l$start_time_sun = start_time_sun;
    final lOther$start_time_sun = other.start_time_sun;
    if (_$data.containsKey('start_time_sun') !=
        other._$data.containsKey('start_time_sun')) {
      return false;
    }
    if (l$start_time_sun != lOther$start_time_sun) {
      return false;
    }
    final l$end_time_sun = end_time_sun;
    final lOther$end_time_sun = other.end_time_sun;
    if (_$data.containsKey('end_time_sun') !=
        other._$data.containsKey('end_time_sun')) {
      return false;
    }
    if (l$end_time_sun != lOther$end_time_sun) {
      return false;
    }
    final l$is_mon_on = is_mon_on;
    final lOther$is_mon_on = other.is_mon_on;
    if (_$data.containsKey('is_mon_on') !=
        other._$data.containsKey('is_mon_on')) {
      return false;
    }
    if (l$is_mon_on != lOther$is_mon_on) {
      return false;
    }
    final l$is_tue_on = is_tue_on;
    final lOther$is_tue_on = other.is_tue_on;
    if (_$data.containsKey('is_tue_on') !=
        other._$data.containsKey('is_tue_on')) {
      return false;
    }
    if (l$is_tue_on != lOther$is_tue_on) {
      return false;
    }
    final l$is_wed_on = is_wed_on;
    final lOther$is_wed_on = other.is_wed_on;
    if (_$data.containsKey('is_wed_on') !=
        other._$data.containsKey('is_wed_on')) {
      return false;
    }
    if (l$is_wed_on != lOther$is_wed_on) {
      return false;
    }
    final l$is_thu_on = is_thu_on;
    final lOther$is_thu_on = other.is_thu_on;
    if (_$data.containsKey('is_thu_on') !=
        other._$data.containsKey('is_thu_on')) {
      return false;
    }
    if (l$is_thu_on != lOther$is_thu_on) {
      return false;
    }
    final l$is_fri_on = is_fri_on;
    final lOther$is_fri_on = other.is_fri_on;
    if (_$data.containsKey('is_fri_on') !=
        other._$data.containsKey('is_fri_on')) {
      return false;
    }
    if (l$is_fri_on != lOther$is_fri_on) {
      return false;
    }
    final l$is_sat_on = is_sat_on;
    final lOther$is_sat_on = other.is_sat_on;
    if (_$data.containsKey('is_sat_on') !=
        other._$data.containsKey('is_sat_on')) {
      return false;
    }
    if (l$is_sat_on != lOther$is_sat_on) {
      return false;
    }
    final l$is_sun_on = is_sun_on;
    final lOther$is_sun_on = other.is_sun_on;
    if (_$data.containsKey('is_sun_on') !=
        other._$data.containsKey('is_sun_on')) {
      return false;
    }
    if (l$is_sun_on != lOther$is_sun_on) {
      return false;
    }
    final l$is_register = is_register;
    final lOther$is_register = other.is_register;
    if (_$data.containsKey('is_register') !=
        other._$data.containsKey('is_register')) {
      return false;
    }
    if (l$is_register != lOther$is_register) {
      return false;
    }
    final l$short_address = short_address;
    final lOther$short_address = other.short_address;
    if (_$data.containsKey('short_address') !=
        other._$data.containsKey('short_address')) {
      return false;
    }
    if (l$short_address != lOther$short_address) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    final l$name = name;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$image = image;
    final l$file_path = file_path;
    final l$type = type;
    final l$url = url;
    final l$note = note;
    final l$phone_number = phone_number;
    final l$number_of_member = number_of_member;
    final l$number_of_courts = number_of_courts;
    final l$is_membership_requre = is_membership_requre;
    final l$cost = cost;
    final l$court_type = court_type;
    final l$country_code = country_code;
    final l$start_time = start_time;
    final l$end_time = end_time;
    final l$start_time_mon = start_time_mon;
    final l$end_time_mon = end_time_mon;
    final l$start_time_tue = start_time_tue;
    final l$end_time_tue = end_time_tue;
    final l$start_time_wed = start_time_wed;
    final l$end_time_wed = end_time_wed;
    final l$start_time_thu = start_time_thu;
    final l$end_time_thu = end_time_thu;
    final l$start_time_fri = start_time_fri;
    final l$end_time_fri = end_time_fri;
    final l$start_time_sat = start_time_sat;
    final l$end_time_sat = end_time_sat;
    final l$start_time_sun = start_time_sun;
    final l$end_time_sun = end_time_sun;
    final l$is_mon_on = is_mon_on;
    final l$is_tue_on = is_tue_on;
    final l$is_wed_on = is_wed_on;
    final l$is_thu_on = is_thu_on;
    final l$is_fri_on = is_fri_on;
    final l$is_sat_on = is_sat_on;
    final l$is_sun_on = is_sun_on;
    final l$is_register = is_register;
    final l$short_address = short_address;
    return Object.hashAll([
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      l$name,
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('phone_number') ? l$phone_number : const {},
      _$data.containsKey('number_of_member') ? l$number_of_member : const {},
      _$data.containsKey('number_of_courts') ? l$number_of_courts : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('cost') ? l$cost : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
      _$data.containsKey('country_code') ? l$country_code : const {},
      _$data.containsKey('start_time') ? l$start_time : const {},
      _$data.containsKey('end_time') ? l$end_time : const {},
      _$data.containsKey('start_time_mon') ? l$start_time_mon : const {},
      _$data.containsKey('end_time_mon') ? l$end_time_mon : const {},
      _$data.containsKey('start_time_tue') ? l$start_time_tue : const {},
      _$data.containsKey('end_time_tue') ? l$end_time_tue : const {},
      _$data.containsKey('start_time_wed') ? l$start_time_wed : const {},
      _$data.containsKey('end_time_wed') ? l$end_time_wed : const {},
      _$data.containsKey('start_time_thu') ? l$start_time_thu : const {},
      _$data.containsKey('end_time_thu') ? l$end_time_thu : const {},
      _$data.containsKey('start_time_fri') ? l$start_time_fri : const {},
      _$data.containsKey('end_time_fri') ? l$end_time_fri : const {},
      _$data.containsKey('start_time_sat') ? l$start_time_sat : const {},
      _$data.containsKey('end_time_sat') ? l$end_time_sat : const {},
      _$data.containsKey('start_time_sun') ? l$start_time_sun : const {},
      _$data.containsKey('end_time_sun') ? l$end_time_sun : const {},
      _$data.containsKey('is_mon_on') ? l$is_mon_on : const {},
      _$data.containsKey('is_tue_on') ? l$is_tue_on : const {},
      _$data.containsKey('is_wed_on') ? l$is_wed_on : const {},
      _$data.containsKey('is_thu_on') ? l$is_thu_on : const {},
      _$data.containsKey('is_fri_on') ? l$is_fri_on : const {},
      _$data.containsKey('is_sat_on') ? l$is_sat_on : const {},
      _$data.containsKey('is_sun_on') ? l$is_sun_on : const {},
      _$data.containsKey('is_register') ? l$is_register : const {},
      _$data.containsKey('short_address') ? l$short_address : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserClubCreateInput<TRes> {
  factory CopyWith$Input$UserClubCreateInput(
    Input$UserClubCreateInput instance,
    TRes Function(Input$UserClubCreateInput) then,
  ) = _CopyWithImpl$Input$UserClubCreateInput;

  factory CopyWith$Input$UserClubCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserClubCreateInput;

  TRes call({
    String? user_uuid,
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? note,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? cost,
    String? court_type,
    String? country_code,
    String? start_time,
    String? end_time,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    int? is_register,
    String? short_address,
  });
}

class _CopyWithImpl$Input$UserClubCreateInput<TRes>
    implements CopyWith$Input$UserClubCreateInput<TRes> {
  _CopyWithImpl$Input$UserClubCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserClubCreateInput _instance;

  final TRes Function(Input$UserClubCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_uuid = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? type = _undefined,
    Object? url = _undefined,
    Object? note = _undefined,
    Object? phone_number = _undefined,
    Object? number_of_member = _undefined,
    Object? number_of_courts = _undefined,
    Object? is_membership_requre = _undefined,
    Object? cost = _undefined,
    Object? court_type = _undefined,
    Object? country_code = _undefined,
    Object? start_time = _undefined,
    Object? end_time = _undefined,
    Object? start_time_mon = _undefined,
    Object? end_time_mon = _undefined,
    Object? start_time_tue = _undefined,
    Object? end_time_tue = _undefined,
    Object? start_time_wed = _undefined,
    Object? end_time_wed = _undefined,
    Object? start_time_thu = _undefined,
    Object? end_time_thu = _undefined,
    Object? start_time_fri = _undefined,
    Object? end_time_fri = _undefined,
    Object? start_time_sat = _undefined,
    Object? end_time_sat = _undefined,
    Object? start_time_sun = _undefined,
    Object? end_time_sun = _undefined,
    Object? is_mon_on = _undefined,
    Object? is_tue_on = _undefined,
    Object? is_wed_on = _undefined,
    Object? is_thu_on = _undefined,
    Object? is_fri_on = _undefined,
    Object? is_sat_on = _undefined,
    Object? is_sun_on = _undefined,
    Object? is_register = _undefined,
    Object? short_address = _undefined,
  }) =>
      _then(Input$UserClubCreateInput._({
        ..._instance._$data,
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (address != _undefined) 'address': (address as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (type != _undefined) 'type': (type as String?),
        if (url != _undefined) 'url': (url as String?),
        if (note != _undefined) 'note': (note as String?),
        if (phone_number != _undefined)
          'phone_number': (phone_number as String?),
        if (number_of_member != _undefined)
          'number_of_member': (number_of_member as String?),
        if (number_of_courts != _undefined)
          'number_of_courts': (number_of_courts as String?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (cost != _undefined) 'cost': (cost as String?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
        if (country_code != _undefined)
          'country_code': (country_code as String?),
        if (start_time != _undefined) 'start_time': (start_time as String?),
        if (end_time != _undefined) 'end_time': (end_time as String?),
        if (start_time_mon != _undefined)
          'start_time_mon': (start_time_mon as String?),
        if (end_time_mon != _undefined)
          'end_time_mon': (end_time_mon as String?),
        if (start_time_tue != _undefined)
          'start_time_tue': (start_time_tue as String?),
        if (end_time_tue != _undefined)
          'end_time_tue': (end_time_tue as String?),
        if (start_time_wed != _undefined)
          'start_time_wed': (start_time_wed as String?),
        if (end_time_wed != _undefined)
          'end_time_wed': (end_time_wed as String?),
        if (start_time_thu != _undefined)
          'start_time_thu': (start_time_thu as String?),
        if (end_time_thu != _undefined)
          'end_time_thu': (end_time_thu as String?),
        if (start_time_fri != _undefined)
          'start_time_fri': (start_time_fri as String?),
        if (end_time_fri != _undefined)
          'end_time_fri': (end_time_fri as String?),
        if (start_time_sat != _undefined)
          'start_time_sat': (start_time_sat as String?),
        if (end_time_sat != _undefined)
          'end_time_sat': (end_time_sat as String?),
        if (start_time_sun != _undefined)
          'start_time_sun': (start_time_sun as String?),
        if (end_time_sun != _undefined)
          'end_time_sun': (end_time_sun as String?),
        if (is_mon_on != _undefined) 'is_mon_on': (is_mon_on as bool?),
        if (is_tue_on != _undefined) 'is_tue_on': (is_tue_on as bool?),
        if (is_wed_on != _undefined) 'is_wed_on': (is_wed_on as bool?),
        if (is_thu_on != _undefined) 'is_thu_on': (is_thu_on as bool?),
        if (is_fri_on != _undefined) 'is_fri_on': (is_fri_on as bool?),
        if (is_sat_on != _undefined) 'is_sat_on': (is_sat_on as bool?),
        if (is_sun_on != _undefined) 'is_sun_on': (is_sun_on as bool?),
        if (is_register != _undefined) 'is_register': (is_register as int?),
        if (short_address != _undefined)
          'short_address': (short_address as String?),
      }));
}

class _CopyWithStubImpl$Input$UserClubCreateInput<TRes>
    implements CopyWith$Input$UserClubCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserClubCreateInput(this._res);

  TRes _res;

  call({
    String? user_uuid,
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? note,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? cost,
    String? court_type,
    String? country_code,
    String? start_time,
    String? end_time,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    int? is_register,
    String? short_address,
  }) =>
      _res;
}

class Input$GetProfileInput {
  factory Input$GetProfileInput({
    String? uuid,
    String? logged_in_user,
    bool? is_home,
    bool? is_feedback_need,
  }) =>
      Input$GetProfileInput._({
        if (uuid != null) r'uuid': uuid,
        if (logged_in_user != null) r'logged_in_user': logged_in_user,
        if (is_home != null) r'is_home': is_home,
        if (is_feedback_need != null) r'is_feedback_need': is_feedback_need,
      });

  Input$GetProfileInput._(this._$data);

  factory Input$GetProfileInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('logged_in_user')) {
      final l$logged_in_user = data['logged_in_user'];
      result$data['logged_in_user'] = (l$logged_in_user as String?);
    }
    if (data.containsKey('is_home')) {
      final l$is_home = data['is_home'];
      result$data['is_home'] = (l$is_home as bool?);
    }
    if (data.containsKey('is_feedback_need')) {
      final l$is_feedback_need = data['is_feedback_need'];
      result$data['is_feedback_need'] = (l$is_feedback_need as bool?);
    }
    return Input$GetProfileInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get logged_in_user => (_$data['logged_in_user'] as String?);

  bool? get is_home => (_$data['is_home'] as bool?);

  bool? get is_feedback_need => (_$data['is_feedback_need'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('logged_in_user')) {
      final l$logged_in_user = logged_in_user;
      result$data['logged_in_user'] = l$logged_in_user;
    }
    if (_$data.containsKey('is_home')) {
      final l$is_home = is_home;
      result$data['is_home'] = l$is_home;
    }
    if (_$data.containsKey('is_feedback_need')) {
      final l$is_feedback_need = is_feedback_need;
      result$data['is_feedback_need'] = l$is_feedback_need;
    }
    return result$data;
  }

  CopyWith$Input$GetProfileInput<Input$GetProfileInput> get copyWith =>
      CopyWith$Input$GetProfileInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GetProfileInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$logged_in_user = logged_in_user;
    final lOther$logged_in_user = other.logged_in_user;
    if (_$data.containsKey('logged_in_user') !=
        other._$data.containsKey('logged_in_user')) {
      return false;
    }
    if (l$logged_in_user != lOther$logged_in_user) {
      return false;
    }
    final l$is_home = is_home;
    final lOther$is_home = other.is_home;
    if (_$data.containsKey('is_home') != other._$data.containsKey('is_home')) {
      return false;
    }
    if (l$is_home != lOther$is_home) {
      return false;
    }
    final l$is_feedback_need = is_feedback_need;
    final lOther$is_feedback_need = other.is_feedback_need;
    if (_$data.containsKey('is_feedback_need') !=
        other._$data.containsKey('is_feedback_need')) {
      return false;
    }
    if (l$is_feedback_need != lOther$is_feedback_need) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$logged_in_user = logged_in_user;
    final l$is_home = is_home;
    final l$is_feedback_need = is_feedback_need;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('logged_in_user') ? l$logged_in_user : const {},
      _$data.containsKey('is_home') ? l$is_home : const {},
      _$data.containsKey('is_feedback_need') ? l$is_feedback_need : const {},
    ]);
  }
}

abstract class CopyWith$Input$GetProfileInput<TRes> {
  factory CopyWith$Input$GetProfileInput(
    Input$GetProfileInput instance,
    TRes Function(Input$GetProfileInput) then,
  ) = _CopyWithImpl$Input$GetProfileInput;

  factory CopyWith$Input$GetProfileInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GetProfileInput;

  TRes call({
    String? uuid,
    String? logged_in_user,
    bool? is_home,
    bool? is_feedback_need,
  });
}

class _CopyWithImpl$Input$GetProfileInput<TRes>
    implements CopyWith$Input$GetProfileInput<TRes> {
  _CopyWithImpl$Input$GetProfileInput(
    this._instance,
    this._then,
  );

  final Input$GetProfileInput _instance;

  final TRes Function(Input$GetProfileInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? logged_in_user = _undefined,
    Object? is_home = _undefined,
    Object? is_feedback_need = _undefined,
  }) =>
      _then(Input$GetProfileInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (logged_in_user != _undefined)
          'logged_in_user': (logged_in_user as String?),
        if (is_home != _undefined) 'is_home': (is_home as bool?),
        if (is_feedback_need != _undefined)
          'is_feedback_need': (is_feedback_need as bool?),
      }));
}

class _CopyWithStubImpl$Input$GetProfileInput<TRes>
    implements CopyWith$Input$GetProfileInput<TRes> {
  _CopyWithStubImpl$Input$GetProfileInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? logged_in_user,
    bool? is_home,
    bool? is_feedback_need,
  }) =>
      _res;
}

class Input$ProfileUpdateInput {
  factory Input$ProfileUpdateInput({
    required String uuid,
    required String first_name,
    required String last_name,
    required int gender,
    required String date_of_birth,
    required String phone_country_id,
    required String mobile_number,
    String? country,
    String? state,
    String? city,
    String? bio_data,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    int? coach_rate,
  }) =>
      Input$ProfileUpdateInput._({
        r'uuid': uuid,
        r'first_name': first_name,
        r'last_name': last_name,
        r'gender': gender,
        r'date_of_birth': date_of_birth,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        if (country != null) r'country': country,
        if (state != null) r'state': state,
        if (city != null) r'city': city,
        if (bio_data != null) r'bio_data': bio_data,
        if (avatar != null) r'avatar': avatar,
        if (file_path != null) r'file_path': file_path,
        if (pickler != null) r'pickler': pickler,
        if (club != null) r'club': club,
        if (coach_rate != null) r'coach_rate': coach_rate,
      });

  Input$ProfileUpdateInput._(this._$data);

  factory Input$ProfileUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$first_name = data['first_name'];
    result$data['first_name'] = (l$first_name as String);
    final l$last_name = data['last_name'];
    result$data['last_name'] = (l$last_name as String);
    final l$gender = data['gender'];
    result$data['gender'] = (l$gender as int);
    final l$date_of_birth = data['date_of_birth'];
    result$data['date_of_birth'] = (l$date_of_birth as String);
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('bio_data')) {
      final l$bio_data = data['bio_data'];
      result$data['bio_data'] = (l$bio_data as String?);
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('pickler')) {
      final l$pickler = data['pickler'];
      result$data['pickler'] =
          (l$pickler as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('coach_rate')) {
      final l$coach_rate = data['coach_rate'];
      result$data['coach_rate'] = (l$coach_rate as int?);
    }
    return Input$ProfileUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get first_name => (_$data['first_name'] as String);

  String get last_name => (_$data['last_name'] as String);

  int get gender => (_$data['gender'] as int);

  String get date_of_birth => (_$data['date_of_birth'] as String);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String? get country => (_$data['country'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get bio_data => (_$data['bio_data'] as String?);

  String? get avatar => (_$data['avatar'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  List<String?>? get pickler => (_$data['pickler'] as List<String?>?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  int? get coach_rate => (_$data['coach_rate'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$first_name = first_name;
    result$data['first_name'] = l$first_name;
    final l$last_name = last_name;
    result$data['last_name'] = l$last_name;
    final l$gender = gender;
    result$data['gender'] = l$gender;
    final l$date_of_birth = date_of_birth;
    result$data['date_of_birth'] = l$date_of_birth;
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('bio_data')) {
      final l$bio_data = bio_data;
      result$data['bio_data'] = l$bio_data;
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('pickler')) {
      final l$pickler = pickler;
      result$data['pickler'] = l$pickler?.map((e) => e).toList();
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('coach_rate')) {
      final l$coach_rate = coach_rate;
      result$data['coach_rate'] = l$coach_rate;
    }
    return result$data;
  }

  CopyWith$Input$ProfileUpdateInput<Input$ProfileUpdateInput> get copyWith =>
      CopyWith$Input$ProfileUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProfileUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$date_of_birth = date_of_birth;
    final lOther$date_of_birth = other.date_of_birth;
    if (l$date_of_birth != lOther$date_of_birth) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$bio_data = bio_data;
    final lOther$bio_data = other.bio_data;
    if (_$data.containsKey('bio_data') !=
        other._$data.containsKey('bio_data')) {
      return false;
    }
    if (l$bio_data != lOther$bio_data) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$pickler = pickler;
    final lOther$pickler = other.pickler;
    if (_$data.containsKey('pickler') != other._$data.containsKey('pickler')) {
      return false;
    }
    if (l$pickler != null && lOther$pickler != null) {
      if (l$pickler.length != lOther$pickler.length) {
        return false;
      }
      for (int i = 0; i < l$pickler.length; i++) {
        final l$pickler$entry = l$pickler[i];
        final lOther$pickler$entry = lOther$pickler[i];
        if (l$pickler$entry != lOther$pickler$entry) {
          return false;
        }
      }
    } else if (l$pickler != lOther$pickler) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$coach_rate = coach_rate;
    final lOther$coach_rate = other.coach_rate;
    if (_$data.containsKey('coach_rate') !=
        other._$data.containsKey('coach_rate')) {
      return false;
    }
    if (l$coach_rate != lOther$coach_rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$gender = gender;
    final l$date_of_birth = date_of_birth;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$country = country;
    final l$state = state;
    final l$city = city;
    final l$bio_data = bio_data;
    final l$avatar = avatar;
    final l$file_path = file_path;
    final l$pickler = pickler;
    final l$club = club;
    final l$coach_rate = coach_rate;
    return Object.hashAll([
      l$uuid,
      l$first_name,
      l$last_name,
      l$gender,
      l$date_of_birth,
      l$phone_country_id,
      l$mobile_number,
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('bio_data') ? l$bio_data : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('pickler')
          ? l$pickler == null
              ? null
              : Object.hashAll(l$pickler.map((v) => v))
          : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('coach_rate') ? l$coach_rate : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProfileUpdateInput<TRes> {
  factory CopyWith$Input$ProfileUpdateInput(
    Input$ProfileUpdateInput instance,
    TRes Function(Input$ProfileUpdateInput) then,
  ) = _CopyWithImpl$Input$ProfileUpdateInput;

  factory CopyWith$Input$ProfileUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProfileUpdateInput;

  TRes call({
    String? uuid,
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? bio_data,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    int? coach_rate,
  });
}

class _CopyWithImpl$Input$ProfileUpdateInput<TRes>
    implements CopyWith$Input$ProfileUpdateInput<TRes> {
  _CopyWithImpl$Input$ProfileUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProfileUpdateInput _instance;

  final TRes Function(Input$ProfileUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? gender = _undefined,
    Object? date_of_birth = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? country = _undefined,
    Object? state = _undefined,
    Object? city = _undefined,
    Object? bio_data = _undefined,
    Object? avatar = _undefined,
    Object? file_path = _undefined,
    Object? pickler = _undefined,
    Object? club = _undefined,
    Object? coach_rate = _undefined,
  }) =>
      _then(Input$ProfileUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (first_name != _undefined && first_name != null)
          'first_name': (first_name as String),
        if (last_name != _undefined && last_name != null)
          'last_name': (last_name as String),
        if (gender != _undefined && gender != null) 'gender': (gender as int),
        if (date_of_birth != _undefined && date_of_birth != null)
          'date_of_birth': (date_of_birth as String),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (country != _undefined) 'country': (country as String?),
        if (state != _undefined) 'state': (state as String?),
        if (city != _undefined) 'city': (city as String?),
        if (bio_data != _undefined) 'bio_data': (bio_data as String?),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (pickler != _undefined) 'pickler': (pickler as List<String?>?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (coach_rate != _undefined) 'coach_rate': (coach_rate as int?),
      }));
}

class _CopyWithStubImpl$Input$ProfileUpdateInput<TRes>
    implements CopyWith$Input$ProfileUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProfileUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? bio_data,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    int? coach_rate,
  }) =>
      _res;
}

class Input$UpdateDeviceTockenInput {
  factory Input$UpdateDeviceTockenInput({
    required String uuid,
    required String device_token,
  }) =>
      Input$UpdateDeviceTockenInput._({
        r'uuid': uuid,
        r'device_token': device_token,
      });

  Input$UpdateDeviceTockenInput._(this._$data);

  factory Input$UpdateDeviceTockenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$device_token = data['device_token'];
    result$data['device_token'] = (l$device_token as String);
    return Input$UpdateDeviceTockenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get device_token => (_$data['device_token'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$device_token = device_token;
    result$data['device_token'] = l$device_token;
    return result$data;
  }

  CopyWith$Input$UpdateDeviceTockenInput<Input$UpdateDeviceTockenInput>
      get copyWith => CopyWith$Input$UpdateDeviceTockenInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDeviceTockenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$device_token = device_token;
    final lOther$device_token = other.device_token;
    if (l$device_token != lOther$device_token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$device_token = device_token;
    return Object.hashAll([
      l$uuid,
      l$device_token,
    ]);
  }
}

abstract class CopyWith$Input$UpdateDeviceTockenInput<TRes> {
  factory CopyWith$Input$UpdateDeviceTockenInput(
    Input$UpdateDeviceTockenInput instance,
    TRes Function(Input$UpdateDeviceTockenInput) then,
  ) = _CopyWithImpl$Input$UpdateDeviceTockenInput;

  factory CopyWith$Input$UpdateDeviceTockenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDeviceTockenInput;

  TRes call({
    String? uuid,
    String? device_token,
  });
}

class _CopyWithImpl$Input$UpdateDeviceTockenInput<TRes>
    implements CopyWith$Input$UpdateDeviceTockenInput<TRes> {
  _CopyWithImpl$Input$UpdateDeviceTockenInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDeviceTockenInput _instance;

  final TRes Function(Input$UpdateDeviceTockenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? device_token = _undefined,
  }) =>
      _then(Input$UpdateDeviceTockenInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (device_token != _undefined && device_token != null)
          'device_token': (device_token as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateDeviceTockenInput<TRes>
    implements CopyWith$Input$UpdateDeviceTockenInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDeviceTockenInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? device_token,
  }) =>
      _res;
}

class Input$UserLocationUpdateInput {
  factory Input$UserLocationUpdateInput({
    required String uuid,
    String? latitude,
    String? longitude,
    String? location,
    int? redius,
    String? country_name,
  }) =>
      Input$UserLocationUpdateInput._({
        r'uuid': uuid,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (location != null) r'location': location,
        if (redius != null) r'redius': redius,
        if (country_name != null) r'country_name': country_name,
      });

  Input$UserLocationUpdateInput._(this._$data);

  factory Input$UserLocationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('redius')) {
      final l$redius = data['redius'];
      result$data['redius'] = (l$redius as int?);
    }
    if (data.containsKey('country_name')) {
      final l$country_name = data['country_name'];
      result$data['country_name'] = (l$country_name as String?);
    }
    return Input$UserLocationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get location => (_$data['location'] as String?);

  int? get redius => (_$data['redius'] as int?);

  String? get country_name => (_$data['country_name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('redius')) {
      final l$redius = redius;
      result$data['redius'] = l$redius;
    }
    if (_$data.containsKey('country_name')) {
      final l$country_name = country_name;
      result$data['country_name'] = l$country_name;
    }
    return result$data;
  }

  CopyWith$Input$UserLocationUpdateInput<Input$UserLocationUpdateInput>
      get copyWith => CopyWith$Input$UserLocationUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserLocationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$redius = redius;
    final lOther$redius = other.redius;
    if (_$data.containsKey('redius') != other._$data.containsKey('redius')) {
      return false;
    }
    if (l$redius != lOther$redius) {
      return false;
    }
    final l$country_name = country_name;
    final lOther$country_name = other.country_name;
    if (_$data.containsKey('country_name') !=
        other._$data.containsKey('country_name')) {
      return false;
    }
    if (l$country_name != lOther$country_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$location = location;
    final l$redius = redius;
    final l$country_name = country_name;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('redius') ? l$redius : const {},
      _$data.containsKey('country_name') ? l$country_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserLocationUpdateInput<TRes> {
  factory CopyWith$Input$UserLocationUpdateInput(
    Input$UserLocationUpdateInput instance,
    TRes Function(Input$UserLocationUpdateInput) then,
  ) = _CopyWithImpl$Input$UserLocationUpdateInput;

  factory CopyWith$Input$UserLocationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserLocationUpdateInput;

  TRes call({
    String? uuid,
    String? latitude,
    String? longitude,
    String? location,
    int? redius,
    String? country_name,
  });
}

class _CopyWithImpl$Input$UserLocationUpdateInput<TRes>
    implements CopyWith$Input$UserLocationUpdateInput<TRes> {
  _CopyWithImpl$Input$UserLocationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserLocationUpdateInput _instance;

  final TRes Function(Input$UserLocationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? location = _undefined,
    Object? redius = _undefined,
    Object? country_name = _undefined,
  }) =>
      _then(Input$UserLocationUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (location != _undefined) 'location': (location as String?),
        if (redius != _undefined) 'redius': (redius as int?),
        if (country_name != _undefined)
          'country_name': (country_name as String?),
      }));
}

class _CopyWithStubImpl$Input$UserLocationUpdateInput<TRes>
    implements CopyWith$Input$UserLocationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserLocationUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? latitude,
    String? longitude,
    String? location,
    int? redius,
    String? country_name,
  }) =>
      _res;
}

class Input$LocationUpdateInput {
  factory Input$LocationUpdateInput({
    String? name,
    String? rating,
    String? gender,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    double? latitude,
    double? longitude,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$LocationUpdateInput._({
        if (name != null) r'name': name,
        if (rating != null) r'rating': rating,
        if (gender != null) r'gender': gender,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation != null) r'recommendation': recommendation,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$LocationUpdateInput._(this._$data);

  factory Input$LocationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = (l$max as int?);
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = (l$min as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$LocationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get gender => (_$data['gender'] as String?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  int? get max => (_$data['max'] as int?);

  int? get min => (_$data['min'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation => (_$data['recommendation'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max;
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$LocationUpdateInput<Input$LocationUpdateInput> get copyWith =>
      CopyWith$Input$LocationUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LocationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$rating = rating;
    final l$gender = gender;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$max = max;
    final l$min = min;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation = recommendation;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$LocationUpdateInput<TRes> {
  factory CopyWith$Input$LocationUpdateInput(
    Input$LocationUpdateInput instance,
    TRes Function(Input$LocationUpdateInput) then,
  ) = _CopyWithImpl$Input$LocationUpdateInput;

  factory CopyWith$Input$LocationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LocationUpdateInput;

  TRes call({
    String? name,
    String? rating,
    String? gender,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    double? latitude,
    double? longitude,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$LocationUpdateInput<TRes>
    implements CopyWith$Input$LocationUpdateInput<TRes> {
  _CopyWithImpl$Input$LocationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$LocationUpdateInput _instance;

  final TRes Function(Input$LocationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? rating = _undefined,
    Object? gender = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$LocationUpdateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (max != _undefined) 'max': (max as int?),
        if (min != _undefined) 'min': (min as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$LocationUpdateInput<TRes>
    implements CopyWith$Input$LocationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$LocationUpdateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? rating,
    String? gender,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    double? latitude,
    double? longitude,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddUserCommentInput {
  factory Input$AddUserCommentInput({
    String? user_uuid,
    String? comment,
    String? parent_id,
  }) =>
      Input$AddUserCommentInput._({
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$AddUserCommentInput._(this._$data);

  factory Input$AddUserCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$AddUserCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$AddUserCommentInput<Input$AddUserCommentInput> get copyWith =>
      CopyWith$Input$AddUserCommentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddUserCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddUserCommentInput<TRes> {
  factory CopyWith$Input$AddUserCommentInput(
    Input$AddUserCommentInput instance,
    TRes Function(Input$AddUserCommentInput) then,
  ) = _CopyWithImpl$Input$AddUserCommentInput;

  factory CopyWith$Input$AddUserCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddUserCommentInput;

  TRes call({
    String? user_uuid,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$AddUserCommentInput<TRes>
    implements CopyWith$Input$AddUserCommentInput<TRes> {
  _CopyWithImpl$Input$AddUserCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddUserCommentInput _instance;

  final TRes Function(Input$AddUserCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$AddUserCommentInput._({
        ..._instance._$data,
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AddUserCommentInput<TRes>
    implements CopyWith$Input$AddUserCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddUserCommentInput(this._res);

  TRes _res;

  call({
    String? user_uuid,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$UserCommentsInput {
  factory Input$UserCommentsInput({String? user_uuid}) =>
      Input$UserCommentsInput._({
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$UserCommentsInput._(this._$data);

  factory Input$UserCommentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$UserCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$UserCommentsInput<Input$UserCommentsInput> get copyWith =>
      CopyWith$Input$UserCommentsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    return Object.hashAll(
        [_$data.containsKey('user_uuid') ? l$user_uuid : const {}]);
  }
}

abstract class CopyWith$Input$UserCommentsInput<TRes> {
  factory CopyWith$Input$UserCommentsInput(
    Input$UserCommentsInput instance,
    TRes Function(Input$UserCommentsInput) then,
  ) = _CopyWithImpl$Input$UserCommentsInput;

  factory CopyWith$Input$UserCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCommentsInput;

  TRes call({String? user_uuid});
}

class _CopyWithImpl$Input$UserCommentsInput<TRes>
    implements CopyWith$Input$UserCommentsInput<TRes> {
  _CopyWithImpl$Input$UserCommentsInput(
    this._instance,
    this._then,
  );

  final Input$UserCommentsInput _instance;

  final TRes Function(Input$UserCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? user_uuid = _undefined}) =>
      _then(Input$UserCommentsInput._({
        ..._instance._$data,
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$UserCommentsInput<TRes>
    implements CopyWith$Input$UserCommentsInput<TRes> {
  _CopyWithStubImpl$Input$UserCommentsInput(this._res);

  TRes _res;

  call({String? user_uuid}) => _res;
}

class Input$UserLikeInput {
  factory Input$UserLikeInput({
    String? user_uuid,
    int? is_like,
  }) =>
      Input$UserLikeInput._({
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$UserLikeInput._(this._$data);

  factory Input$UserLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as int?);
    }
    return Input$UserLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_uuid => (_$data['user_uuid'] as String?);

  int? get is_like => (_$data['is_like'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$UserLikeInput<Input$UserLikeInput> get copyWith =>
      CopyWith$Input$UserLikeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserLikeInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserLikeInput<TRes> {
  factory CopyWith$Input$UserLikeInput(
    Input$UserLikeInput instance,
    TRes Function(Input$UserLikeInput) then,
  ) = _CopyWithImpl$Input$UserLikeInput;

  factory CopyWith$Input$UserLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserLikeInput;

  TRes call({
    String? user_uuid,
    int? is_like,
  });
}

class _CopyWithImpl$Input$UserLikeInput<TRes>
    implements CopyWith$Input$UserLikeInput<TRes> {
  _CopyWithImpl$Input$UserLikeInput(
    this._instance,
    this._then,
  );

  final Input$UserLikeInput _instance;

  final TRes Function(Input$UserLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$UserLikeInput._({
        ..._instance._$data,
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as int?),
      }));
}

class _CopyWithStubImpl$Input$UserLikeInput<TRes>
    implements CopyWith$Input$UserLikeInput<TRes> {
  _CopyWithStubImpl$Input$UserLikeInput(this._res);

  TRes _res;

  call({
    String? user_uuid,
    int? is_like,
  }) =>
      _res;
}

class Input$AddAcceptGroupRequestInput {
  factory Input$AddAcceptGroupRequestInput({
    String? group_uuid,
    String? user_uuid,
  }) =>
      Input$AddAcceptGroupRequestInput._({
        if (group_uuid != null) r'group_uuid': group_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$AddAcceptGroupRequestInput._(this._$data);

  factory Input$AddAcceptGroupRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('group_uuid')) {
      final l$group_uuid = data['group_uuid'];
      result$data['group_uuid'] = (l$group_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$AddAcceptGroupRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get group_uuid => (_$data['group_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('group_uuid')) {
      final l$group_uuid = group_uuid;
      result$data['group_uuid'] = l$group_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$AddAcceptGroupRequestInput<Input$AddAcceptGroupRequestInput>
      get copyWith => CopyWith$Input$AddAcceptGroupRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAcceptGroupRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (_$data.containsKey('group_uuid') !=
        other._$data.containsKey('group_uuid')) {
      return false;
    }
    if (l$group_uuid != lOther$group_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('group_uuid') ? l$group_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddAcceptGroupRequestInput<TRes> {
  factory CopyWith$Input$AddAcceptGroupRequestInput(
    Input$AddAcceptGroupRequestInput instance,
    TRes Function(Input$AddAcceptGroupRequestInput) then,
  ) = _CopyWithImpl$Input$AddAcceptGroupRequestInput;

  factory CopyWith$Input$AddAcceptGroupRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAcceptGroupRequestInput;

  TRes call({
    String? group_uuid,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$AddAcceptGroupRequestInput<TRes>
    implements CopyWith$Input$AddAcceptGroupRequestInput<TRes> {
  _CopyWithImpl$Input$AddAcceptGroupRequestInput(
    this._instance,
    this._then,
  );

  final Input$AddAcceptGroupRequestInput _instance;

  final TRes Function(Input$AddAcceptGroupRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$AddAcceptGroupRequestInput._({
        ..._instance._$data,
        if (group_uuid != _undefined) 'group_uuid': (group_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$AddAcceptGroupRequestInput<TRes>
    implements CopyWith$Input$AddAcceptGroupRequestInput<TRes> {
  _CopyWithStubImpl$Input$AddAcceptGroupRequestInput(this._res);

  TRes _res;

  call({
    String? group_uuid,
    String? user_uuid,
  }) =>
      _res;
}

class Input$AddAcceptFriendRequestqrInput {
  factory Input$AddAcceptFriendRequestqrInput({
    required String sender_id,
    required String receiver_id,
  }) =>
      Input$AddAcceptFriendRequestqrInput._({
        r'sender_id': sender_id,
        r'receiver_id': receiver_id,
      });

  Input$AddAcceptFriendRequestqrInput._(this._$data);

  factory Input$AddAcceptFriendRequestqrInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sender_id = data['sender_id'];
    result$data['sender_id'] = (l$sender_id as String);
    final l$receiver_id = data['receiver_id'];
    result$data['receiver_id'] = (l$receiver_id as String);
    return Input$AddAcceptFriendRequestqrInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get sender_id => (_$data['sender_id'] as String);

  String get receiver_id => (_$data['receiver_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sender_id = sender_id;
    result$data['sender_id'] = l$sender_id;
    final l$receiver_id = receiver_id;
    result$data['receiver_id'] = l$receiver_id;
    return result$data;
  }

  CopyWith$Input$AddAcceptFriendRequestqrInput<
          Input$AddAcceptFriendRequestqrInput>
      get copyWith => CopyWith$Input$AddAcceptFriendRequestqrInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAcceptFriendRequestqrInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sender_id = sender_id;
    final lOther$sender_id = other.sender_id;
    if (l$sender_id != lOther$sender_id) {
      return false;
    }
    final l$receiver_id = receiver_id;
    final lOther$receiver_id = other.receiver_id;
    if (l$receiver_id != lOther$receiver_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sender_id = sender_id;
    final l$receiver_id = receiver_id;
    return Object.hashAll([
      l$sender_id,
      l$receiver_id,
    ]);
  }
}

abstract class CopyWith$Input$AddAcceptFriendRequestqrInput<TRes> {
  factory CopyWith$Input$AddAcceptFriendRequestqrInput(
    Input$AddAcceptFriendRequestqrInput instance,
    TRes Function(Input$AddAcceptFriendRequestqrInput) then,
  ) = _CopyWithImpl$Input$AddAcceptFriendRequestqrInput;

  factory CopyWith$Input$AddAcceptFriendRequestqrInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAcceptFriendRequestqrInput;

  TRes call({
    String? sender_id,
    String? receiver_id,
  });
}

class _CopyWithImpl$Input$AddAcceptFriendRequestqrInput<TRes>
    implements CopyWith$Input$AddAcceptFriendRequestqrInput<TRes> {
  _CopyWithImpl$Input$AddAcceptFriendRequestqrInput(
    this._instance,
    this._then,
  );

  final Input$AddAcceptFriendRequestqrInput _instance;

  final TRes Function(Input$AddAcceptFriendRequestqrInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sender_id = _undefined,
    Object? receiver_id = _undefined,
  }) =>
      _then(Input$AddAcceptFriendRequestqrInput._({
        ..._instance._$data,
        if (sender_id != _undefined && sender_id != null)
          'sender_id': (sender_id as String),
        if (receiver_id != _undefined && receiver_id != null)
          'receiver_id': (receiver_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddAcceptFriendRequestqrInput<TRes>
    implements CopyWith$Input$AddAcceptFriendRequestqrInput<TRes> {
  _CopyWithStubImpl$Input$AddAcceptFriendRequestqrInput(this._res);

  TRes _res;

  call({
    String? sender_id,
    String? receiver_id,
  }) =>
      _res;
}

class Input$AdddashboardInput {
  factory Input$AdddashboardInput({
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      Input$AdddashboardInput._({
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
      });

  Input$AdddashboardInput._(this._$data);

  factory Input$AdddashboardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    return Input$AdddashboardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    return result$data;
  }

  CopyWith$Input$AdddashboardInput<Input$AdddashboardInput> get copyWith =>
      CopyWith$Input$AdddashboardInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AdddashboardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    return Object.hashAll([
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
    ]);
  }
}

abstract class CopyWith$Input$AdddashboardInput<TRes> {
  factory CopyWith$Input$AdddashboardInput(
    Input$AdddashboardInput instance,
    TRes Function(Input$AdddashboardInput) then,
  ) = _CopyWithImpl$Input$AdddashboardInput;

  factory CopyWith$Input$AdddashboardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AdddashboardInput;

  TRes call({
    double? latitude,
    double? longitude,
    int? radius,
  });
}

class _CopyWithImpl$Input$AdddashboardInput<TRes>
    implements CopyWith$Input$AdddashboardInput<TRes> {
  _CopyWithImpl$Input$AdddashboardInput(
    this._instance,
    this._then,
  );

  final Input$AdddashboardInput _instance;

  final TRes Function(Input$AdddashboardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
  }) =>
      _then(Input$AdddashboardInput._({
        ..._instance._$data,
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
      }));
}

class _CopyWithStubImpl$Input$AdddashboardInput<TRes>
    implements CopyWith$Input$AdddashboardInput<TRes> {
  _CopyWithStubImpl$Input$AdddashboardInput(this._res);

  TRes _res;

  call({
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      _res;
}

class Input$getPreSignUrlInput {
  factory Input$getPreSignUrlInput({required String file_path}) =>
      Input$getPreSignUrlInput._({
        r'file_path': file_path,
      });

  Input$getPreSignUrlInput._(this._$data);

  factory Input$getPreSignUrlInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$file_path = data['file_path'];
    result$data['file_path'] = (l$file_path as String);
    return Input$getPreSignUrlInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get file_path => (_$data['file_path'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$file_path = file_path;
    result$data['file_path'] = l$file_path;
    return result$data;
  }

  CopyWith$Input$getPreSignUrlInput<Input$getPreSignUrlInput> get copyWith =>
      CopyWith$Input$getPreSignUrlInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getPreSignUrlInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (l$file_path != lOther$file_path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$file_path = file_path;
    return Object.hashAll([l$file_path]);
  }
}

abstract class CopyWith$Input$getPreSignUrlInput<TRes> {
  factory CopyWith$Input$getPreSignUrlInput(
    Input$getPreSignUrlInput instance,
    TRes Function(Input$getPreSignUrlInput) then,
  ) = _CopyWithImpl$Input$getPreSignUrlInput;

  factory CopyWith$Input$getPreSignUrlInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getPreSignUrlInput;

  TRes call({String? file_path});
}

class _CopyWithImpl$Input$getPreSignUrlInput<TRes>
    implements CopyWith$Input$getPreSignUrlInput<TRes> {
  _CopyWithImpl$Input$getPreSignUrlInput(
    this._instance,
    this._then,
  );

  final Input$getPreSignUrlInput _instance;

  final TRes Function(Input$getPreSignUrlInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? file_path = _undefined}) =>
      _then(Input$getPreSignUrlInput._({
        ..._instance._$data,
        if (file_path != _undefined && file_path != null)
          'file_path': (file_path as String),
      }));
}

class _CopyWithStubImpl$Input$getPreSignUrlInput<TRes>
    implements CopyWith$Input$getPreSignUrlInput<TRes> {
  _CopyWithStubImpl$Input$getPreSignUrlInput(this._res);

  TRes _res;

  call({String? file_path}) => _res;
}

class Input$Input {
  factory Input$Input({
    required String email,
    required String password,
  }) =>
      Input$Input._({
        r'email': email,
        r'password': password,
      });

  Input$Input._(this._$data);

  factory Input$Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String get email => (_$data['email'] as String);

  String get password => (_$data['password'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$Input<Input$Input> get copyWith => CopyWith$Input$Input(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$Input) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$email = email;
    final l$password = password;
    return Object.hashAll([
      l$email,
      l$password,
    ]);
  }
}

abstract class CopyWith$Input$Input<TRes> {
  factory CopyWith$Input$Input(
    Input$Input instance,
    TRes Function(Input$Input) then,
  ) = _CopyWithImpl$Input$Input;

  factory CopyWith$Input$Input.stub(TRes res) = _CopyWithStubImpl$Input$Input;

  TRes call({
    String? email,
    String? password,
  });
}

class _CopyWithImpl$Input$Input<TRes> implements CopyWith$Input$Input<TRes> {
  _CopyWithImpl$Input$Input(
    this._instance,
    this._then,
  );

  final Input$Input _instance;

  final TRes Function(Input$Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? email = _undefined,
    Object? password = _undefined,
  }) =>
      _then(Input$Input._({
        ..._instance._$data,
        if (email != _undefined && email != null) 'email': (email as String),
        if (password != _undefined && password != null)
          'password': (password as String),
      }));
}

class _CopyWithStubImpl$Input$Input<TRes>
    implements CopyWith$Input$Input<TRes> {
  _CopyWithStubImpl$Input$Input(this._res);

  TRes _res;

  call({
    String? email,
    String? password,
  }) =>
      _res;
}

class Input$ForgotPasswordInput {
  factory Input$ForgotPasswordInput({required String email}) =>
      Input$ForgotPasswordInput._({
        r'email': email,
      });

  Input$ForgotPasswordInput._(this._$data);

  factory Input$ForgotPasswordInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    return Input$ForgotPasswordInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get email => (_$data['email'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$email = email;
    result$data['email'] = l$email;
    return result$data;
  }

  CopyWith$Input$ForgotPasswordInput<Input$ForgotPasswordInput> get copyWith =>
      CopyWith$Input$ForgotPasswordInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ForgotPasswordInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$email = email;
    return Object.hashAll([l$email]);
  }
}

abstract class CopyWith$Input$ForgotPasswordInput<TRes> {
  factory CopyWith$Input$ForgotPasswordInput(
    Input$ForgotPasswordInput instance,
    TRes Function(Input$ForgotPasswordInput) then,
  ) = _CopyWithImpl$Input$ForgotPasswordInput;

  factory CopyWith$Input$ForgotPasswordInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ForgotPasswordInput;

  TRes call({String? email});
}

class _CopyWithImpl$Input$ForgotPasswordInput<TRes>
    implements CopyWith$Input$ForgotPasswordInput<TRes> {
  _CopyWithImpl$Input$ForgotPasswordInput(
    this._instance,
    this._then,
  );

  final Input$ForgotPasswordInput _instance;

  final TRes Function(Input$ForgotPasswordInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? email = _undefined}) => _then(Input$ForgotPasswordInput._({
        ..._instance._$data,
        if (email != _undefined && email != null) 'email': (email as String),
      }));
}

class _CopyWithStubImpl$Input$ForgotPasswordInput<TRes>
    implements CopyWith$Input$ForgotPasswordInput<TRes> {
  _CopyWithStubImpl$Input$ForgotPasswordInput(this._res);

  TRes _res;

  call({String? email}) => _res;
}

class Input$UserPaginationInput {
  factory Input$UserPaginationInput({
    required int offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
  }) =>
      Input$UserPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (full_name != null) r'full_name': full_name,
        if (mobile_number != null) r'mobile_number': mobile_number,
        if (status != null) r'status': status,
        if (gender != null) r'gender': gender,
        if (email != null) r'email': email,
        if (rating != null) r'rating': rating,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (club_id != null) r'club_id': club_id,
        if (state != null) r'state': state,
        if (is_coach != null) r'is_coach': is_coach,
      });

  Input$UserPaginationInput._(this._$data);

  factory Input$UserPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('mobile_number')) {
      final l$mobile_number = data['mobile_number'];
      result$data['mobile_number'] = (l$mobile_number as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('club_id')) {
      final l$club_id = data['club_id'];
      result$data['club_id'] = (l$club_id as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as String?);
    }
    return Input$UserPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get mobile_number => (_$data['mobile_number'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get club_id => (_$data['club_id'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get is_coach => (_$data['is_coach'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('mobile_number')) {
      final l$mobile_number = mobile_number;
      result$data['mobile_number'] = l$mobile_number;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('club_id')) {
      final l$club_id = club_id;
      result$data['club_id'] = l$club_id;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    return result$data;
  }

  CopyWith$Input$UserPaginationInput<Input$UserPaginationInput> get copyWith =>
      CopyWith$Input$UserPaginationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (_$data.containsKey('mobile_number') !=
        other._$data.containsKey('mobile_number')) {
      return false;
    }
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$club_id = club_id;
    final lOther$club_id = other.club_id;
    if (_$data.containsKey('club_id') != other._$data.containsKey('club_id')) {
      return false;
    }
    if (l$club_id != lOther$club_id) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$full_name = full_name;
    final l$mobile_number = mobile_number;
    final l$status = status;
    final l$gender = gender;
    final l$email = email;
    final l$rating = rating;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$club_id = club_id;
    final l$state = state;
    final l$is_coach = is_coach;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('mobile_number') ? l$mobile_number : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('club_id') ? l$club_id : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserPaginationInput<TRes> {
  factory CopyWith$Input$UserPaginationInput(
    Input$UserPaginationInput instance,
    TRes Function(Input$UserPaginationInput) then,
  ) = _CopyWithImpl$Input$UserPaginationInput;

  factory CopyWith$Input$UserPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
  });
}

class _CopyWithImpl$Input$UserPaginationInput<TRes>
    implements CopyWith$Input$UserPaginationInput<TRes> {
  _CopyWithImpl$Input$UserPaginationInput(
    this._instance,
    this._then,
  );

  final Input$UserPaginationInput _instance;

  final TRes Function(Input$UserPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? full_name = _undefined,
    Object? mobile_number = _undefined,
    Object? status = _undefined,
    Object? gender = _undefined,
    Object? email = _undefined,
    Object? rating = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? club_id = _undefined,
    Object? state = _undefined,
    Object? is_coach = _undefined,
  }) =>
      _then(Input$UserPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (mobile_number != _undefined)
          'mobile_number': (mobile_number as String?),
        if (status != _undefined) 'status': (status as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (email != _undefined) 'email': (email as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (club_id != _undefined) 'club_id': (club_id as String?),
        if (state != _undefined) 'state': (state as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as String?),
      }));
}

class _CopyWithStubImpl$Input$UserPaginationInput<TRes>
    implements CopyWith$Input$UserPaginationInput<TRes> {
  _CopyWithStubImpl$Input$UserPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
  }) =>
      _res;
}

class Input$deleteUserInput {
  factory Input$deleteUserInput({required String uuid}) =>
      Input$deleteUserInput._({
        r'uuid': uuid,
      });

  Input$deleteUserInput._(this._$data);

  factory Input$deleteUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteUserInput<Input$deleteUserInput> get copyWith =>
      CopyWith$Input$deleteUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteUserInput<TRes> {
  factory CopyWith$Input$deleteUserInput(
    Input$deleteUserInput instance,
    TRes Function(Input$deleteUserInput) then,
  ) = _CopyWithImpl$Input$deleteUserInput;

  factory CopyWith$Input$deleteUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteUserInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteUserInput<TRes>
    implements CopyWith$Input$deleteUserInput<TRes> {
  _CopyWithImpl$Input$deleteUserInput(
    this._instance,
    this._then,
  );

  final Input$deleteUserInput _instance;

  final TRes Function(Input$deleteUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteUserInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteUserInput<TRes>
    implements CopyWith$Input$deleteUserInput<TRes> {
  _CopyWithStubImpl$Input$deleteUserInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$viewUserInput {
  factory Input$viewUserInput({required String uuid}) => Input$viewUserInput._({
        r'uuid': uuid,
      });

  Input$viewUserInput._(this._$data);

  factory Input$viewUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewUserInput<Input$viewUserInput> get copyWith =>
      CopyWith$Input$viewUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewUserInput<TRes> {
  factory CopyWith$Input$viewUserInput(
    Input$viewUserInput instance,
    TRes Function(Input$viewUserInput) then,
  ) = _CopyWithImpl$Input$viewUserInput;

  factory CopyWith$Input$viewUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewUserInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewUserInput<TRes>
    implements CopyWith$Input$viewUserInput<TRes> {
  _CopyWithImpl$Input$viewUserInput(
    this._instance,
    this._then,
  );

  final Input$viewUserInput _instance;

  final TRes Function(Input$viewUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewUserInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewUserInput<TRes>
    implements CopyWith$Input$viewUserInput<TRes> {
  _CopyWithStubImpl$Input$viewUserInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$UserUpdateStatusInput {
  factory Input$UserUpdateStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UserUpdateStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UserUpdateStatusInput._(this._$data);

  factory Input$UserUpdateStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UserUpdateStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UserUpdateStatusInput<Input$UserUpdateStatusInput>
      get copyWith => CopyWith$Input$UserUpdateStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateStatusInput<TRes> {
  factory CopyWith$Input$UserUpdateStatusInput(
    Input$UserUpdateStatusInput instance,
    TRes Function(Input$UserUpdateStatusInput) then,
  ) = _CopyWithImpl$Input$UserUpdateStatusInput;

  factory CopyWith$Input$UserUpdateStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UserUpdateStatusInput<TRes>
    implements CopyWith$Input$UserUpdateStatusInput<TRes> {
  _CopyWithImpl$Input$UserUpdateStatusInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateStatusInput _instance;

  final TRes Function(Input$UserUpdateStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UserUpdateStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UserUpdateStatusInput<TRes>
    implements CopyWith$Input$UserUpdateStatusInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$UserCreateInput {
  factory Input$UserCreateInput({
    required String first_name,
    required String last_name,
    required int gender,
    required String date_of_birth,
    required String phone_country_id,
    required String mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    List<String?>? pickler,
    List<String?>? club,
    String? avatar,
    String? file_path,
    String? email,
    String? bio_data,
    String? location,
    int? coach_rate,
  }) =>
      Input$UserCreateInput._({
        r'first_name': first_name,
        r'last_name': last_name,
        r'gender': gender,
        r'date_of_birth': date_of_birth,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        if (country != null) r'country': country,
        if (state != null) r'state': state,
        if (city != null) r'city': city,
        if (rating != null) r'rating': rating,
        if (pickler != null) r'pickler': pickler,
        if (club != null) r'club': club,
        if (avatar != null) r'avatar': avatar,
        if (file_path != null) r'file_path': file_path,
        if (email != null) r'email': email,
        if (bio_data != null) r'bio_data': bio_data,
        if (location != null) r'location': location,
        if (coach_rate != null) r'coach_rate': coach_rate,
      });

  Input$UserCreateInput._(this._$data);

  factory Input$UserCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$first_name = data['first_name'];
    result$data['first_name'] = (l$first_name as String);
    final l$last_name = data['last_name'];
    result$data['last_name'] = (l$last_name as String);
    final l$gender = data['gender'];
    result$data['gender'] = (l$gender as int);
    final l$date_of_birth = data['date_of_birth'];
    result$data['date_of_birth'] = (l$date_of_birth as String);
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('pickler')) {
      final l$pickler = data['pickler'];
      result$data['pickler'] =
          (l$pickler as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('bio_data')) {
      final l$bio_data = data['bio_data'];
      result$data['bio_data'] = (l$bio_data as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('coach_rate')) {
      final l$coach_rate = data['coach_rate'];
      result$data['coach_rate'] = (l$coach_rate as int?);
    }
    return Input$UserCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get first_name => (_$data['first_name'] as String);

  String get last_name => (_$data['last_name'] as String);

  int get gender => (_$data['gender'] as int);

  String get date_of_birth => (_$data['date_of_birth'] as String);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String? get country => (_$data['country'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get rating => (_$data['rating'] as String?);

  List<String?>? get pickler => (_$data['pickler'] as List<String?>?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  String? get avatar => (_$data['avatar'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get bio_data => (_$data['bio_data'] as String?);

  String? get location => (_$data['location'] as String?);

  int? get coach_rate => (_$data['coach_rate'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$first_name = first_name;
    result$data['first_name'] = l$first_name;
    final l$last_name = last_name;
    result$data['last_name'] = l$last_name;
    final l$gender = gender;
    result$data['gender'] = l$gender;
    final l$date_of_birth = date_of_birth;
    result$data['date_of_birth'] = l$date_of_birth;
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('pickler')) {
      final l$pickler = pickler;
      result$data['pickler'] = l$pickler?.map((e) => e).toList();
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('bio_data')) {
      final l$bio_data = bio_data;
      result$data['bio_data'] = l$bio_data;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('coach_rate')) {
      final l$coach_rate = coach_rate;
      result$data['coach_rate'] = l$coach_rate;
    }
    return result$data;
  }

  CopyWith$Input$UserCreateInput<Input$UserCreateInput> get copyWith =>
      CopyWith$Input$UserCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$date_of_birth = date_of_birth;
    final lOther$date_of_birth = other.date_of_birth;
    if (l$date_of_birth != lOther$date_of_birth) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$pickler = pickler;
    final lOther$pickler = other.pickler;
    if (_$data.containsKey('pickler') != other._$data.containsKey('pickler')) {
      return false;
    }
    if (l$pickler != null && lOther$pickler != null) {
      if (l$pickler.length != lOther$pickler.length) {
        return false;
      }
      for (int i = 0; i < l$pickler.length; i++) {
        final l$pickler$entry = l$pickler[i];
        final lOther$pickler$entry = lOther$pickler[i];
        if (l$pickler$entry != lOther$pickler$entry) {
          return false;
        }
      }
    } else if (l$pickler != lOther$pickler) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$bio_data = bio_data;
    final lOther$bio_data = other.bio_data;
    if (_$data.containsKey('bio_data') !=
        other._$data.containsKey('bio_data')) {
      return false;
    }
    if (l$bio_data != lOther$bio_data) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$coach_rate = coach_rate;
    final lOther$coach_rate = other.coach_rate;
    if (_$data.containsKey('coach_rate') !=
        other._$data.containsKey('coach_rate')) {
      return false;
    }
    if (l$coach_rate != lOther$coach_rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$gender = gender;
    final l$date_of_birth = date_of_birth;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$country = country;
    final l$state = state;
    final l$city = city;
    final l$rating = rating;
    final l$pickler = pickler;
    final l$club = club;
    final l$avatar = avatar;
    final l$file_path = file_path;
    final l$email = email;
    final l$bio_data = bio_data;
    final l$location = location;
    final l$coach_rate = coach_rate;
    return Object.hashAll([
      l$first_name,
      l$last_name,
      l$gender,
      l$date_of_birth,
      l$phone_country_id,
      l$mobile_number,
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('pickler')
          ? l$pickler == null
              ? null
              : Object.hashAll(l$pickler.map((v) => v))
          : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('bio_data') ? l$bio_data : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('coach_rate') ? l$coach_rate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateInput<TRes> {
  factory CopyWith$Input$UserCreateInput(
    Input$UserCreateInput instance,
    TRes Function(Input$UserCreateInput) then,
  ) = _CopyWithImpl$Input$UserCreateInput;

  factory CopyWith$Input$UserCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateInput;

  TRes call({
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    List<String?>? pickler,
    List<String?>? club,
    String? avatar,
    String? file_path,
    String? email,
    String? bio_data,
    String? location,
    int? coach_rate,
  });
}

class _CopyWithImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithImpl$Input$UserCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateInput _instance;

  final TRes Function(Input$UserCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? gender = _undefined,
    Object? date_of_birth = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? country = _undefined,
    Object? state = _undefined,
    Object? city = _undefined,
    Object? rating = _undefined,
    Object? pickler = _undefined,
    Object? club = _undefined,
    Object? avatar = _undefined,
    Object? file_path = _undefined,
    Object? email = _undefined,
    Object? bio_data = _undefined,
    Object? location = _undefined,
    Object? coach_rate = _undefined,
  }) =>
      _then(Input$UserCreateInput._({
        ..._instance._$data,
        if (first_name != _undefined && first_name != null)
          'first_name': (first_name as String),
        if (last_name != _undefined && last_name != null)
          'last_name': (last_name as String),
        if (gender != _undefined && gender != null) 'gender': (gender as int),
        if (date_of_birth != _undefined && date_of_birth != null)
          'date_of_birth': (date_of_birth as String),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (country != _undefined) 'country': (country as String?),
        if (state != _undefined) 'state': (state as String?),
        if (city != _undefined) 'city': (city as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (pickler != _undefined) 'pickler': (pickler as List<String?>?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (email != _undefined) 'email': (email as String?),
        if (bio_data != _undefined) 'bio_data': (bio_data as String?),
        if (location != _undefined) 'location': (location as String?),
        if (coach_rate != _undefined) 'coach_rate': (coach_rate as int?),
      }));
}

class _CopyWithStubImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateInput(this._res);

  TRes _res;

  call({
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    List<String?>? pickler,
    List<String?>? club,
    String? avatar,
    String? file_path,
    String? email,
    String? bio_data,
    String? location,
    int? coach_rate,
  }) =>
      _res;
}

class Input$UserUpdateInput {
  factory Input$UserUpdateInput({
    required String uuid,
    required String first_name,
    required String last_name,
    required int gender,
    required String date_of_birth,
    required String phone_country_id,
    required String mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    String? email,
    String? bio_data,
    String? location,
    int? coach_speciality,
    double? coach_experience,
    int? is_coach,
    List<String?>? certificate,
    String? coach_bio,
    int? coach_rate,
  }) =>
      Input$UserUpdateInput._({
        r'uuid': uuid,
        r'first_name': first_name,
        r'last_name': last_name,
        r'gender': gender,
        r'date_of_birth': date_of_birth,
        r'phone_country_id': phone_country_id,
        r'mobile_number': mobile_number,
        if (country != null) r'country': country,
        if (state != null) r'state': state,
        if (city != null) r'city': city,
        if (rating != null) r'rating': rating,
        if (avatar != null) r'avatar': avatar,
        if (file_path != null) r'file_path': file_path,
        if (pickler != null) r'pickler': pickler,
        if (club != null) r'club': club,
        if (email != null) r'email': email,
        if (bio_data != null) r'bio_data': bio_data,
        if (location != null) r'location': location,
        if (coach_speciality != null) r'coach_speciality': coach_speciality,
        if (coach_experience != null) r'coach_experience': coach_experience,
        if (is_coach != null) r'is_coach': is_coach,
        if (certificate != null) r'certificate': certificate,
        if (coach_bio != null) r'coach_bio': coach_bio,
        if (coach_rate != null) r'coach_rate': coach_rate,
      });

  Input$UserUpdateInput._(this._$data);

  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$first_name = data['first_name'];
    result$data['first_name'] = (l$first_name as String);
    final l$last_name = data['last_name'];
    result$data['last_name'] = (l$last_name as String);
    final l$gender = data['gender'];
    result$data['gender'] = (l$gender as int);
    final l$date_of_birth = data['date_of_birth'];
    result$data['date_of_birth'] = (l$date_of_birth as String);
    final l$phone_country_id = data['phone_country_id'];
    result$data['phone_country_id'] = (l$phone_country_id as String);
    final l$mobile_number = data['mobile_number'];
    result$data['mobile_number'] = (l$mobile_number as String);
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('avatar')) {
      final l$avatar = data['avatar'];
      result$data['avatar'] = (l$avatar as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('pickler')) {
      final l$pickler = data['pickler'];
      result$data['pickler'] =
          (l$pickler as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('bio_data')) {
      final l$bio_data = data['bio_data'];
      result$data['bio_data'] = (l$bio_data as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('coach_speciality')) {
      final l$coach_speciality = data['coach_speciality'];
      result$data['coach_speciality'] = (l$coach_speciality as int?);
    }
    if (data.containsKey('coach_experience')) {
      final l$coach_experience = data['coach_experience'];
      result$data['coach_experience'] =
          (l$coach_experience as num?)?.toDouble();
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as int?);
    }
    if (data.containsKey('certificate')) {
      final l$certificate = data['certificate'];
      result$data['certificate'] = (l$certificate as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('coach_bio')) {
      final l$coach_bio = data['coach_bio'];
      result$data['coach_bio'] = (l$coach_bio as String?);
    }
    if (data.containsKey('coach_rate')) {
      final l$coach_rate = data['coach_rate'];
      result$data['coach_rate'] = (l$coach_rate as int?);
    }
    return Input$UserUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get first_name => (_$data['first_name'] as String);

  String get last_name => (_$data['last_name'] as String);

  int get gender => (_$data['gender'] as int);

  String get date_of_birth => (_$data['date_of_birth'] as String);

  String get phone_country_id => (_$data['phone_country_id'] as String);

  String get mobile_number => (_$data['mobile_number'] as String);

  String? get country => (_$data['country'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get avatar => (_$data['avatar'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  List<String?>? get pickler => (_$data['pickler'] as List<String?>?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  String? get email => (_$data['email'] as String?);

  String? get bio_data => (_$data['bio_data'] as String?);

  String? get location => (_$data['location'] as String?);

  int? get coach_speciality => (_$data['coach_speciality'] as int?);

  double? get coach_experience => (_$data['coach_experience'] as double?);

  int? get is_coach => (_$data['is_coach'] as int?);

  List<String?>? get certificate => (_$data['certificate'] as List<String?>?);

  String? get coach_bio => (_$data['coach_bio'] as String?);

  int? get coach_rate => (_$data['coach_rate'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$first_name = first_name;
    result$data['first_name'] = l$first_name;
    final l$last_name = last_name;
    result$data['last_name'] = l$last_name;
    final l$gender = gender;
    result$data['gender'] = l$gender;
    final l$date_of_birth = date_of_birth;
    result$data['date_of_birth'] = l$date_of_birth;
    final l$phone_country_id = phone_country_id;
    result$data['phone_country_id'] = l$phone_country_id;
    final l$mobile_number = mobile_number;
    result$data['mobile_number'] = l$mobile_number;
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('avatar')) {
      final l$avatar = avatar;
      result$data['avatar'] = l$avatar;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('pickler')) {
      final l$pickler = pickler;
      result$data['pickler'] = l$pickler?.map((e) => e).toList();
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('bio_data')) {
      final l$bio_data = bio_data;
      result$data['bio_data'] = l$bio_data;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('coach_speciality')) {
      final l$coach_speciality = coach_speciality;
      result$data['coach_speciality'] = l$coach_speciality;
    }
    if (_$data.containsKey('coach_experience')) {
      final l$coach_experience = coach_experience;
      result$data['coach_experience'] = l$coach_experience;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    if (_$data.containsKey('certificate')) {
      final l$certificate = certificate;
      result$data['certificate'] = l$certificate?.map((e) => e).toList();
    }
    if (_$data.containsKey('coach_bio')) {
      final l$coach_bio = coach_bio;
      result$data['coach_bio'] = l$coach_bio;
    }
    if (_$data.containsKey('coach_rate')) {
      final l$coach_rate = coach_rate;
      result$data['coach_rate'] = l$coach_rate;
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateInput<Input$UserUpdateInput> get copyWith =>
      CopyWith$Input$UserUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$date_of_birth = date_of_birth;
    final lOther$date_of_birth = other.date_of_birth;
    if (l$date_of_birth != lOther$date_of_birth) {
      return false;
    }
    final l$phone_country_id = phone_country_id;
    final lOther$phone_country_id = other.phone_country_id;
    if (l$phone_country_id != lOther$phone_country_id) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$avatar = avatar;
    final lOther$avatar = other.avatar;
    if (_$data.containsKey('avatar') != other._$data.containsKey('avatar')) {
      return false;
    }
    if (l$avatar != lOther$avatar) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$pickler = pickler;
    final lOther$pickler = other.pickler;
    if (_$data.containsKey('pickler') != other._$data.containsKey('pickler')) {
      return false;
    }
    if (l$pickler != null && lOther$pickler != null) {
      if (l$pickler.length != lOther$pickler.length) {
        return false;
      }
      for (int i = 0; i < l$pickler.length; i++) {
        final l$pickler$entry = l$pickler[i];
        final lOther$pickler$entry = lOther$pickler[i];
        if (l$pickler$entry != lOther$pickler$entry) {
          return false;
        }
      }
    } else if (l$pickler != lOther$pickler) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$bio_data = bio_data;
    final lOther$bio_data = other.bio_data;
    if (_$data.containsKey('bio_data') !=
        other._$data.containsKey('bio_data')) {
      return false;
    }
    if (l$bio_data != lOther$bio_data) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$coach_speciality = coach_speciality;
    final lOther$coach_speciality = other.coach_speciality;
    if (_$data.containsKey('coach_speciality') !=
        other._$data.containsKey('coach_speciality')) {
      return false;
    }
    if (l$coach_speciality != lOther$coach_speciality) {
      return false;
    }
    final l$coach_experience = coach_experience;
    final lOther$coach_experience = other.coach_experience;
    if (_$data.containsKey('coach_experience') !=
        other._$data.containsKey('coach_experience')) {
      return false;
    }
    if (l$coach_experience != lOther$coach_experience) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    final l$certificate = certificate;
    final lOther$certificate = other.certificate;
    if (_$data.containsKey('certificate') !=
        other._$data.containsKey('certificate')) {
      return false;
    }
    if (l$certificate != null && lOther$certificate != null) {
      if (l$certificate.length != lOther$certificate.length) {
        return false;
      }
      for (int i = 0; i < l$certificate.length; i++) {
        final l$certificate$entry = l$certificate[i];
        final lOther$certificate$entry = lOther$certificate[i];
        if (l$certificate$entry != lOther$certificate$entry) {
          return false;
        }
      }
    } else if (l$certificate != lOther$certificate) {
      return false;
    }
    final l$coach_bio = coach_bio;
    final lOther$coach_bio = other.coach_bio;
    if (_$data.containsKey('coach_bio') !=
        other._$data.containsKey('coach_bio')) {
      return false;
    }
    if (l$coach_bio != lOther$coach_bio) {
      return false;
    }
    final l$coach_rate = coach_rate;
    final lOther$coach_rate = other.coach_rate;
    if (_$data.containsKey('coach_rate') !=
        other._$data.containsKey('coach_rate')) {
      return false;
    }
    if (l$coach_rate != lOther$coach_rate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$gender = gender;
    final l$date_of_birth = date_of_birth;
    final l$phone_country_id = phone_country_id;
    final l$mobile_number = mobile_number;
    final l$country = country;
    final l$state = state;
    final l$city = city;
    final l$rating = rating;
    final l$avatar = avatar;
    final l$file_path = file_path;
    final l$pickler = pickler;
    final l$club = club;
    final l$email = email;
    final l$bio_data = bio_data;
    final l$location = location;
    final l$coach_speciality = coach_speciality;
    final l$coach_experience = coach_experience;
    final l$is_coach = is_coach;
    final l$certificate = certificate;
    final l$coach_bio = coach_bio;
    final l$coach_rate = coach_rate;
    return Object.hashAll([
      l$uuid,
      l$first_name,
      l$last_name,
      l$gender,
      l$date_of_birth,
      l$phone_country_id,
      l$mobile_number,
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('avatar') ? l$avatar : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('pickler')
          ? l$pickler == null
              ? null
              : Object.hashAll(l$pickler.map((v) => v))
          : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('bio_data') ? l$bio_data : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('coach_speciality') ? l$coach_speciality : const {},
      _$data.containsKey('coach_experience') ? l$coach_experience : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
      _$data.containsKey('certificate')
          ? l$certificate == null
              ? null
              : Object.hashAll(l$certificate.map((v) => v))
          : const {},
      _$data.containsKey('coach_bio') ? l$coach_bio : const {},
      _$data.containsKey('coach_rate') ? l$coach_rate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateInput<TRes> {
  factory CopyWith$Input$UserUpdateInput(
    Input$UserUpdateInput instance,
    TRes Function(Input$UserUpdateInput) then,
  ) = _CopyWithImpl$Input$UserUpdateInput;

  factory CopyWith$Input$UserUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateInput;

  TRes call({
    String? uuid,
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    String? email,
    String? bio_data,
    String? location,
    int? coach_speciality,
    double? coach_experience,
    int? is_coach,
    List<String?>? certificate,
    String? coach_bio,
    int? coach_rate,
  });
}

class _CopyWithImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithImpl$Input$UserUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateInput _instance;

  final TRes Function(Input$UserUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? gender = _undefined,
    Object? date_of_birth = _undefined,
    Object? phone_country_id = _undefined,
    Object? mobile_number = _undefined,
    Object? country = _undefined,
    Object? state = _undefined,
    Object? city = _undefined,
    Object? rating = _undefined,
    Object? avatar = _undefined,
    Object? file_path = _undefined,
    Object? pickler = _undefined,
    Object? club = _undefined,
    Object? email = _undefined,
    Object? bio_data = _undefined,
    Object? location = _undefined,
    Object? coach_speciality = _undefined,
    Object? coach_experience = _undefined,
    Object? is_coach = _undefined,
    Object? certificate = _undefined,
    Object? coach_bio = _undefined,
    Object? coach_rate = _undefined,
  }) =>
      _then(Input$UserUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (first_name != _undefined && first_name != null)
          'first_name': (first_name as String),
        if (last_name != _undefined && last_name != null)
          'last_name': (last_name as String),
        if (gender != _undefined && gender != null) 'gender': (gender as int),
        if (date_of_birth != _undefined && date_of_birth != null)
          'date_of_birth': (date_of_birth as String),
        if (phone_country_id != _undefined && phone_country_id != null)
          'phone_country_id': (phone_country_id as String),
        if (mobile_number != _undefined && mobile_number != null)
          'mobile_number': (mobile_number as String),
        if (country != _undefined) 'country': (country as String?),
        if (state != _undefined) 'state': (state as String?),
        if (city != _undefined) 'city': (city as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (avatar != _undefined) 'avatar': (avatar as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (pickler != _undefined) 'pickler': (pickler as List<String?>?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (email != _undefined) 'email': (email as String?),
        if (bio_data != _undefined) 'bio_data': (bio_data as String?),
        if (location != _undefined) 'location': (location as String?),
        if (coach_speciality != _undefined)
          'coach_speciality': (coach_speciality as int?),
        if (coach_experience != _undefined)
          'coach_experience': (coach_experience as double?),
        if (is_coach != _undefined) 'is_coach': (is_coach as int?),
        if (certificate != _undefined)
          'certificate': (certificate as List<String?>?),
        if (coach_bio != _undefined) 'coach_bio': (coach_bio as String?),
        if (coach_rate != _undefined) 'coach_rate': (coach_rate as int?),
      }));
}

class _CopyWithStubImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? first_name,
    String? last_name,
    int? gender,
    String? date_of_birth,
    String? phone_country_id,
    String? mobile_number,
    String? country,
    String? state,
    String? city,
    String? rating,
    String? avatar,
    String? file_path,
    List<String?>? pickler,
    List<String?>? club,
    String? email,
    String? bio_data,
    String? location,
    int? coach_speciality,
    double? coach_experience,
    int? is_coach,
    List<String?>? certificate,
    String? coach_bio,
    int? coach_rate,
  }) =>
      _res;
}

class Input$ClubCreateInput {
  factory Input$ClubCreateInput({
    required String name,
    required String address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? short_address,
  }) =>
      Input$ClubCreateInput._({
        r'name': name,
        r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (type != null) r'type': type,
        if (url != null) r'url': url,
        if (phone_number != null) r'phone_number': phone_number,
        if (number_of_member != null) r'number_of_member': number_of_member,
        if (number_of_courts != null) r'number_of_courts': number_of_courts,
        if (start_time != null) r'start_time': start_time,
        if (end_time != null) r'end_time': end_time,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (cost != null) r'cost': cost,
        if (note != null) r'note': note,
        if (court_type != null) r'court_type': court_type,
        if (country_code != null) r'country_code': country_code,
        if (start_time_mon != null) r'start_time_mon': start_time_mon,
        if (end_time_mon != null) r'end_time_mon': end_time_mon,
        if (start_time_tue != null) r'start_time_tue': start_time_tue,
        if (end_time_tue != null) r'end_time_tue': end_time_tue,
        if (start_time_wed != null) r'start_time_wed': start_time_wed,
        if (end_time_wed != null) r'end_time_wed': end_time_wed,
        if (start_time_thu != null) r'start_time_thu': start_time_thu,
        if (end_time_thu != null) r'end_time_thu': end_time_thu,
        if (start_time_fri != null) r'start_time_fri': start_time_fri,
        if (end_time_fri != null) r'end_time_fri': end_time_fri,
        if (start_time_sat != null) r'start_time_sat': start_time_sat,
        if (end_time_sat != null) r'end_time_sat': end_time_sat,
        if (start_time_sun != null) r'start_time_sun': start_time_sun,
        if (end_time_sun != null) r'end_time_sun': end_time_sun,
        if (is_mon_on != null) r'is_mon_on': is_mon_on,
        if (is_tue_on != null) r'is_tue_on': is_tue_on,
        if (is_wed_on != null) r'is_wed_on': is_wed_on,
        if (is_thu_on != null) r'is_thu_on': is_thu_on,
        if (is_fri_on != null) r'is_fri_on': is_fri_on,
        if (is_sat_on != null) r'is_sat_on': is_sat_on,
        if (is_sun_on != null) r'is_sun_on': is_sun_on,
        if (short_address != null) r'short_address': short_address,
      });

  Input$ClubCreateInput._(this._$data);

  factory Input$ClubCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('phone_number')) {
      final l$phone_number = data['phone_number'];
      result$data['phone_number'] = (l$phone_number as String?);
    }
    if (data.containsKey('number_of_member')) {
      final l$number_of_member = data['number_of_member'];
      result$data['number_of_member'] = (l$number_of_member as String?);
    }
    if (data.containsKey('number_of_courts')) {
      final l$number_of_courts = data['number_of_courts'];
      result$data['number_of_courts'] = (l$number_of_courts as String?);
    }
    if (data.containsKey('start_time')) {
      final l$start_time = data['start_time'];
      result$data['start_time'] = (l$start_time as String?);
    }
    if (data.containsKey('end_time')) {
      final l$end_time = data['end_time'];
      result$data['end_time'] = (l$end_time as String?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('cost')) {
      final l$cost = data['cost'];
      result$data['cost'] = (l$cost as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    if (data.containsKey('country_code')) {
      final l$country_code = data['country_code'];
      result$data['country_code'] = (l$country_code as String?);
    }
    if (data.containsKey('start_time_mon')) {
      final l$start_time_mon = data['start_time_mon'];
      result$data['start_time_mon'] = (l$start_time_mon as String?);
    }
    if (data.containsKey('end_time_mon')) {
      final l$end_time_mon = data['end_time_mon'];
      result$data['end_time_mon'] = (l$end_time_mon as String?);
    }
    if (data.containsKey('start_time_tue')) {
      final l$start_time_tue = data['start_time_tue'];
      result$data['start_time_tue'] = (l$start_time_tue as String?);
    }
    if (data.containsKey('end_time_tue')) {
      final l$end_time_tue = data['end_time_tue'];
      result$data['end_time_tue'] = (l$end_time_tue as String?);
    }
    if (data.containsKey('start_time_wed')) {
      final l$start_time_wed = data['start_time_wed'];
      result$data['start_time_wed'] = (l$start_time_wed as String?);
    }
    if (data.containsKey('end_time_wed')) {
      final l$end_time_wed = data['end_time_wed'];
      result$data['end_time_wed'] = (l$end_time_wed as String?);
    }
    if (data.containsKey('start_time_thu')) {
      final l$start_time_thu = data['start_time_thu'];
      result$data['start_time_thu'] = (l$start_time_thu as String?);
    }
    if (data.containsKey('end_time_thu')) {
      final l$end_time_thu = data['end_time_thu'];
      result$data['end_time_thu'] = (l$end_time_thu as String?);
    }
    if (data.containsKey('start_time_fri')) {
      final l$start_time_fri = data['start_time_fri'];
      result$data['start_time_fri'] = (l$start_time_fri as String?);
    }
    if (data.containsKey('end_time_fri')) {
      final l$end_time_fri = data['end_time_fri'];
      result$data['end_time_fri'] = (l$end_time_fri as String?);
    }
    if (data.containsKey('start_time_sat')) {
      final l$start_time_sat = data['start_time_sat'];
      result$data['start_time_sat'] = (l$start_time_sat as String?);
    }
    if (data.containsKey('end_time_sat')) {
      final l$end_time_sat = data['end_time_sat'];
      result$data['end_time_sat'] = (l$end_time_sat as String?);
    }
    if (data.containsKey('start_time_sun')) {
      final l$start_time_sun = data['start_time_sun'];
      result$data['start_time_sun'] = (l$start_time_sun as String?);
    }
    if (data.containsKey('end_time_sun')) {
      final l$end_time_sun = data['end_time_sun'];
      result$data['end_time_sun'] = (l$end_time_sun as String?);
    }
    if (data.containsKey('is_mon_on')) {
      final l$is_mon_on = data['is_mon_on'];
      result$data['is_mon_on'] = (l$is_mon_on as bool?);
    }
    if (data.containsKey('is_tue_on')) {
      final l$is_tue_on = data['is_tue_on'];
      result$data['is_tue_on'] = (l$is_tue_on as bool?);
    }
    if (data.containsKey('is_wed_on')) {
      final l$is_wed_on = data['is_wed_on'];
      result$data['is_wed_on'] = (l$is_wed_on as bool?);
    }
    if (data.containsKey('is_thu_on')) {
      final l$is_thu_on = data['is_thu_on'];
      result$data['is_thu_on'] = (l$is_thu_on as bool?);
    }
    if (data.containsKey('is_fri_on')) {
      final l$is_fri_on = data['is_fri_on'];
      result$data['is_fri_on'] = (l$is_fri_on as bool?);
    }
    if (data.containsKey('is_sat_on')) {
      final l$is_sat_on = data['is_sat_on'];
      result$data['is_sat_on'] = (l$is_sat_on as bool?);
    }
    if (data.containsKey('is_sun_on')) {
      final l$is_sun_on = data['is_sun_on'];
      result$data['is_sun_on'] = (l$is_sun_on as bool?);
    }
    if (data.containsKey('short_address')) {
      final l$short_address = data['short_address'];
      result$data['short_address'] = (l$short_address as String?);
    }
    return Input$ClubCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get address => (_$data['address'] as String);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get type => (_$data['type'] as String?);

  String? get url => (_$data['url'] as String?);

  String? get phone_number => (_$data['phone_number'] as String?);

  String? get number_of_member => (_$data['number_of_member'] as String?);

  String? get number_of_courts => (_$data['number_of_courts'] as String?);

  String? get start_time => (_$data['start_time'] as String?);

  String? get end_time => (_$data['end_time'] as String?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get cost => (_$data['cost'] as String?);

  String? get note => (_$data['note'] as String?);

  String? get court_type => (_$data['court_type'] as String?);

  String? get country_code => (_$data['country_code'] as String?);

  String? get start_time_mon => (_$data['start_time_mon'] as String?);

  String? get end_time_mon => (_$data['end_time_mon'] as String?);

  String? get start_time_tue => (_$data['start_time_tue'] as String?);

  String? get end_time_tue => (_$data['end_time_tue'] as String?);

  String? get start_time_wed => (_$data['start_time_wed'] as String?);

  String? get end_time_wed => (_$data['end_time_wed'] as String?);

  String? get start_time_thu => (_$data['start_time_thu'] as String?);

  String? get end_time_thu => (_$data['end_time_thu'] as String?);

  String? get start_time_fri => (_$data['start_time_fri'] as String?);

  String? get end_time_fri => (_$data['end_time_fri'] as String?);

  String? get start_time_sat => (_$data['start_time_sat'] as String?);

  String? get end_time_sat => (_$data['end_time_sat'] as String?);

  String? get start_time_sun => (_$data['start_time_sun'] as String?);

  String? get end_time_sun => (_$data['end_time_sun'] as String?);

  bool? get is_mon_on => (_$data['is_mon_on'] as bool?);

  bool? get is_tue_on => (_$data['is_tue_on'] as bool?);

  bool? get is_wed_on => (_$data['is_wed_on'] as bool?);

  bool? get is_thu_on => (_$data['is_thu_on'] as bool?);

  bool? get is_fri_on => (_$data['is_fri_on'] as bool?);

  bool? get is_sat_on => (_$data['is_sat_on'] as bool?);

  bool? get is_sun_on => (_$data['is_sun_on'] as bool?);

  String? get short_address => (_$data['short_address'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$address = address;
    result$data['address'] = l$address;
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('phone_number')) {
      final l$phone_number = phone_number;
      result$data['phone_number'] = l$phone_number;
    }
    if (_$data.containsKey('number_of_member')) {
      final l$number_of_member = number_of_member;
      result$data['number_of_member'] = l$number_of_member;
    }
    if (_$data.containsKey('number_of_courts')) {
      final l$number_of_courts = number_of_courts;
      result$data['number_of_courts'] = l$number_of_courts;
    }
    if (_$data.containsKey('start_time')) {
      final l$start_time = start_time;
      result$data['start_time'] = l$start_time;
    }
    if (_$data.containsKey('end_time')) {
      final l$end_time = end_time;
      result$data['end_time'] = l$end_time;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('cost')) {
      final l$cost = cost;
      result$data['cost'] = l$cost;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    if (_$data.containsKey('country_code')) {
      final l$country_code = country_code;
      result$data['country_code'] = l$country_code;
    }
    if (_$data.containsKey('start_time_mon')) {
      final l$start_time_mon = start_time_mon;
      result$data['start_time_mon'] = l$start_time_mon;
    }
    if (_$data.containsKey('end_time_mon')) {
      final l$end_time_mon = end_time_mon;
      result$data['end_time_mon'] = l$end_time_mon;
    }
    if (_$data.containsKey('start_time_tue')) {
      final l$start_time_tue = start_time_tue;
      result$data['start_time_tue'] = l$start_time_tue;
    }
    if (_$data.containsKey('end_time_tue')) {
      final l$end_time_tue = end_time_tue;
      result$data['end_time_tue'] = l$end_time_tue;
    }
    if (_$data.containsKey('start_time_wed')) {
      final l$start_time_wed = start_time_wed;
      result$data['start_time_wed'] = l$start_time_wed;
    }
    if (_$data.containsKey('end_time_wed')) {
      final l$end_time_wed = end_time_wed;
      result$data['end_time_wed'] = l$end_time_wed;
    }
    if (_$data.containsKey('start_time_thu')) {
      final l$start_time_thu = start_time_thu;
      result$data['start_time_thu'] = l$start_time_thu;
    }
    if (_$data.containsKey('end_time_thu')) {
      final l$end_time_thu = end_time_thu;
      result$data['end_time_thu'] = l$end_time_thu;
    }
    if (_$data.containsKey('start_time_fri')) {
      final l$start_time_fri = start_time_fri;
      result$data['start_time_fri'] = l$start_time_fri;
    }
    if (_$data.containsKey('end_time_fri')) {
      final l$end_time_fri = end_time_fri;
      result$data['end_time_fri'] = l$end_time_fri;
    }
    if (_$data.containsKey('start_time_sat')) {
      final l$start_time_sat = start_time_sat;
      result$data['start_time_sat'] = l$start_time_sat;
    }
    if (_$data.containsKey('end_time_sat')) {
      final l$end_time_sat = end_time_sat;
      result$data['end_time_sat'] = l$end_time_sat;
    }
    if (_$data.containsKey('start_time_sun')) {
      final l$start_time_sun = start_time_sun;
      result$data['start_time_sun'] = l$start_time_sun;
    }
    if (_$data.containsKey('end_time_sun')) {
      final l$end_time_sun = end_time_sun;
      result$data['end_time_sun'] = l$end_time_sun;
    }
    if (_$data.containsKey('is_mon_on')) {
      final l$is_mon_on = is_mon_on;
      result$data['is_mon_on'] = l$is_mon_on;
    }
    if (_$data.containsKey('is_tue_on')) {
      final l$is_tue_on = is_tue_on;
      result$data['is_tue_on'] = l$is_tue_on;
    }
    if (_$data.containsKey('is_wed_on')) {
      final l$is_wed_on = is_wed_on;
      result$data['is_wed_on'] = l$is_wed_on;
    }
    if (_$data.containsKey('is_thu_on')) {
      final l$is_thu_on = is_thu_on;
      result$data['is_thu_on'] = l$is_thu_on;
    }
    if (_$data.containsKey('is_fri_on')) {
      final l$is_fri_on = is_fri_on;
      result$data['is_fri_on'] = l$is_fri_on;
    }
    if (_$data.containsKey('is_sat_on')) {
      final l$is_sat_on = is_sat_on;
      result$data['is_sat_on'] = l$is_sat_on;
    }
    if (_$data.containsKey('is_sun_on')) {
      final l$is_sun_on = is_sun_on;
      result$data['is_sun_on'] = l$is_sun_on;
    }
    if (_$data.containsKey('short_address')) {
      final l$short_address = short_address;
      result$data['short_address'] = l$short_address;
    }
    return result$data;
  }

  CopyWith$Input$ClubCreateInput<Input$ClubCreateInput> get copyWith =>
      CopyWith$Input$ClubCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClubCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$phone_number = phone_number;
    final lOther$phone_number = other.phone_number;
    if (_$data.containsKey('phone_number') !=
        other._$data.containsKey('phone_number')) {
      return false;
    }
    if (l$phone_number != lOther$phone_number) {
      return false;
    }
    final l$number_of_member = number_of_member;
    final lOther$number_of_member = other.number_of_member;
    if (_$data.containsKey('number_of_member') !=
        other._$data.containsKey('number_of_member')) {
      return false;
    }
    if (l$number_of_member != lOther$number_of_member) {
      return false;
    }
    final l$number_of_courts = number_of_courts;
    final lOther$number_of_courts = other.number_of_courts;
    if (_$data.containsKey('number_of_courts') !=
        other._$data.containsKey('number_of_courts')) {
      return false;
    }
    if (l$number_of_courts != lOther$number_of_courts) {
      return false;
    }
    final l$start_time = start_time;
    final lOther$start_time = other.start_time;
    if (_$data.containsKey('start_time') !=
        other._$data.containsKey('start_time')) {
      return false;
    }
    if (l$start_time != lOther$start_time) {
      return false;
    }
    final l$end_time = end_time;
    final lOther$end_time = other.end_time;
    if (_$data.containsKey('end_time') !=
        other._$data.containsKey('end_time')) {
      return false;
    }
    if (l$end_time != lOther$end_time) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$cost = cost;
    final lOther$cost = other.cost;
    if (_$data.containsKey('cost') != other._$data.containsKey('cost')) {
      return false;
    }
    if (l$cost != lOther$cost) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    final l$country_code = country_code;
    final lOther$country_code = other.country_code;
    if (_$data.containsKey('country_code') !=
        other._$data.containsKey('country_code')) {
      return false;
    }
    if (l$country_code != lOther$country_code) {
      return false;
    }
    final l$start_time_mon = start_time_mon;
    final lOther$start_time_mon = other.start_time_mon;
    if (_$data.containsKey('start_time_mon') !=
        other._$data.containsKey('start_time_mon')) {
      return false;
    }
    if (l$start_time_mon != lOther$start_time_mon) {
      return false;
    }
    final l$end_time_mon = end_time_mon;
    final lOther$end_time_mon = other.end_time_mon;
    if (_$data.containsKey('end_time_mon') !=
        other._$data.containsKey('end_time_mon')) {
      return false;
    }
    if (l$end_time_mon != lOther$end_time_mon) {
      return false;
    }
    final l$start_time_tue = start_time_tue;
    final lOther$start_time_tue = other.start_time_tue;
    if (_$data.containsKey('start_time_tue') !=
        other._$data.containsKey('start_time_tue')) {
      return false;
    }
    if (l$start_time_tue != lOther$start_time_tue) {
      return false;
    }
    final l$end_time_tue = end_time_tue;
    final lOther$end_time_tue = other.end_time_tue;
    if (_$data.containsKey('end_time_tue') !=
        other._$data.containsKey('end_time_tue')) {
      return false;
    }
    if (l$end_time_tue != lOther$end_time_tue) {
      return false;
    }
    final l$start_time_wed = start_time_wed;
    final lOther$start_time_wed = other.start_time_wed;
    if (_$data.containsKey('start_time_wed') !=
        other._$data.containsKey('start_time_wed')) {
      return false;
    }
    if (l$start_time_wed != lOther$start_time_wed) {
      return false;
    }
    final l$end_time_wed = end_time_wed;
    final lOther$end_time_wed = other.end_time_wed;
    if (_$data.containsKey('end_time_wed') !=
        other._$data.containsKey('end_time_wed')) {
      return false;
    }
    if (l$end_time_wed != lOther$end_time_wed) {
      return false;
    }
    final l$start_time_thu = start_time_thu;
    final lOther$start_time_thu = other.start_time_thu;
    if (_$data.containsKey('start_time_thu') !=
        other._$data.containsKey('start_time_thu')) {
      return false;
    }
    if (l$start_time_thu != lOther$start_time_thu) {
      return false;
    }
    final l$end_time_thu = end_time_thu;
    final lOther$end_time_thu = other.end_time_thu;
    if (_$data.containsKey('end_time_thu') !=
        other._$data.containsKey('end_time_thu')) {
      return false;
    }
    if (l$end_time_thu != lOther$end_time_thu) {
      return false;
    }
    final l$start_time_fri = start_time_fri;
    final lOther$start_time_fri = other.start_time_fri;
    if (_$data.containsKey('start_time_fri') !=
        other._$data.containsKey('start_time_fri')) {
      return false;
    }
    if (l$start_time_fri != lOther$start_time_fri) {
      return false;
    }
    final l$end_time_fri = end_time_fri;
    final lOther$end_time_fri = other.end_time_fri;
    if (_$data.containsKey('end_time_fri') !=
        other._$data.containsKey('end_time_fri')) {
      return false;
    }
    if (l$end_time_fri != lOther$end_time_fri) {
      return false;
    }
    final l$start_time_sat = start_time_sat;
    final lOther$start_time_sat = other.start_time_sat;
    if (_$data.containsKey('start_time_sat') !=
        other._$data.containsKey('start_time_sat')) {
      return false;
    }
    if (l$start_time_sat != lOther$start_time_sat) {
      return false;
    }
    final l$end_time_sat = end_time_sat;
    final lOther$end_time_sat = other.end_time_sat;
    if (_$data.containsKey('end_time_sat') !=
        other._$data.containsKey('end_time_sat')) {
      return false;
    }
    if (l$end_time_sat != lOther$end_time_sat) {
      return false;
    }
    final l$start_time_sun = start_time_sun;
    final lOther$start_time_sun = other.start_time_sun;
    if (_$data.containsKey('start_time_sun') !=
        other._$data.containsKey('start_time_sun')) {
      return false;
    }
    if (l$start_time_sun != lOther$start_time_sun) {
      return false;
    }
    final l$end_time_sun = end_time_sun;
    final lOther$end_time_sun = other.end_time_sun;
    if (_$data.containsKey('end_time_sun') !=
        other._$data.containsKey('end_time_sun')) {
      return false;
    }
    if (l$end_time_sun != lOther$end_time_sun) {
      return false;
    }
    final l$is_mon_on = is_mon_on;
    final lOther$is_mon_on = other.is_mon_on;
    if (_$data.containsKey('is_mon_on') !=
        other._$data.containsKey('is_mon_on')) {
      return false;
    }
    if (l$is_mon_on != lOther$is_mon_on) {
      return false;
    }
    final l$is_tue_on = is_tue_on;
    final lOther$is_tue_on = other.is_tue_on;
    if (_$data.containsKey('is_tue_on') !=
        other._$data.containsKey('is_tue_on')) {
      return false;
    }
    if (l$is_tue_on != lOther$is_tue_on) {
      return false;
    }
    final l$is_wed_on = is_wed_on;
    final lOther$is_wed_on = other.is_wed_on;
    if (_$data.containsKey('is_wed_on') !=
        other._$data.containsKey('is_wed_on')) {
      return false;
    }
    if (l$is_wed_on != lOther$is_wed_on) {
      return false;
    }
    final l$is_thu_on = is_thu_on;
    final lOther$is_thu_on = other.is_thu_on;
    if (_$data.containsKey('is_thu_on') !=
        other._$data.containsKey('is_thu_on')) {
      return false;
    }
    if (l$is_thu_on != lOther$is_thu_on) {
      return false;
    }
    final l$is_fri_on = is_fri_on;
    final lOther$is_fri_on = other.is_fri_on;
    if (_$data.containsKey('is_fri_on') !=
        other._$data.containsKey('is_fri_on')) {
      return false;
    }
    if (l$is_fri_on != lOther$is_fri_on) {
      return false;
    }
    final l$is_sat_on = is_sat_on;
    final lOther$is_sat_on = other.is_sat_on;
    if (_$data.containsKey('is_sat_on') !=
        other._$data.containsKey('is_sat_on')) {
      return false;
    }
    if (l$is_sat_on != lOther$is_sat_on) {
      return false;
    }
    final l$is_sun_on = is_sun_on;
    final lOther$is_sun_on = other.is_sun_on;
    if (_$data.containsKey('is_sun_on') !=
        other._$data.containsKey('is_sun_on')) {
      return false;
    }
    if (l$is_sun_on != lOther$is_sun_on) {
      return false;
    }
    final l$short_address = short_address;
    final lOther$short_address = other.short_address;
    if (_$data.containsKey('short_address') !=
        other._$data.containsKey('short_address')) {
      return false;
    }
    if (l$short_address != lOther$short_address) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$image = image;
    final l$file_path = file_path;
    final l$type = type;
    final l$url = url;
    final l$phone_number = phone_number;
    final l$number_of_member = number_of_member;
    final l$number_of_courts = number_of_courts;
    final l$start_time = start_time;
    final l$end_time = end_time;
    final l$is_membership_requre = is_membership_requre;
    final l$cost = cost;
    final l$note = note;
    final l$court_type = court_type;
    final l$country_code = country_code;
    final l$start_time_mon = start_time_mon;
    final l$end_time_mon = end_time_mon;
    final l$start_time_tue = start_time_tue;
    final l$end_time_tue = end_time_tue;
    final l$start_time_wed = start_time_wed;
    final l$end_time_wed = end_time_wed;
    final l$start_time_thu = start_time_thu;
    final l$end_time_thu = end_time_thu;
    final l$start_time_fri = start_time_fri;
    final l$end_time_fri = end_time_fri;
    final l$start_time_sat = start_time_sat;
    final l$end_time_sat = end_time_sat;
    final l$start_time_sun = start_time_sun;
    final l$end_time_sun = end_time_sun;
    final l$is_mon_on = is_mon_on;
    final l$is_tue_on = is_tue_on;
    final l$is_wed_on = is_wed_on;
    final l$is_thu_on = is_thu_on;
    final l$is_fri_on = is_fri_on;
    final l$is_sat_on = is_sat_on;
    final l$is_sun_on = is_sun_on;
    final l$short_address = short_address;
    return Object.hashAll([
      l$name,
      l$address,
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('phone_number') ? l$phone_number : const {},
      _$data.containsKey('number_of_member') ? l$number_of_member : const {},
      _$data.containsKey('number_of_courts') ? l$number_of_courts : const {},
      _$data.containsKey('start_time') ? l$start_time : const {},
      _$data.containsKey('end_time') ? l$end_time : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('cost') ? l$cost : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
      _$data.containsKey('country_code') ? l$country_code : const {},
      _$data.containsKey('start_time_mon') ? l$start_time_mon : const {},
      _$data.containsKey('end_time_mon') ? l$end_time_mon : const {},
      _$data.containsKey('start_time_tue') ? l$start_time_tue : const {},
      _$data.containsKey('end_time_tue') ? l$end_time_tue : const {},
      _$data.containsKey('start_time_wed') ? l$start_time_wed : const {},
      _$data.containsKey('end_time_wed') ? l$end_time_wed : const {},
      _$data.containsKey('start_time_thu') ? l$start_time_thu : const {},
      _$data.containsKey('end_time_thu') ? l$end_time_thu : const {},
      _$data.containsKey('start_time_fri') ? l$start_time_fri : const {},
      _$data.containsKey('end_time_fri') ? l$end_time_fri : const {},
      _$data.containsKey('start_time_sat') ? l$start_time_sat : const {},
      _$data.containsKey('end_time_sat') ? l$end_time_sat : const {},
      _$data.containsKey('start_time_sun') ? l$start_time_sun : const {},
      _$data.containsKey('end_time_sun') ? l$end_time_sun : const {},
      _$data.containsKey('is_mon_on') ? l$is_mon_on : const {},
      _$data.containsKey('is_tue_on') ? l$is_tue_on : const {},
      _$data.containsKey('is_wed_on') ? l$is_wed_on : const {},
      _$data.containsKey('is_thu_on') ? l$is_thu_on : const {},
      _$data.containsKey('is_fri_on') ? l$is_fri_on : const {},
      _$data.containsKey('is_sat_on') ? l$is_sat_on : const {},
      _$data.containsKey('is_sun_on') ? l$is_sun_on : const {},
      _$data.containsKey('short_address') ? l$short_address : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClubCreateInput<TRes> {
  factory CopyWith$Input$ClubCreateInput(
    Input$ClubCreateInput instance,
    TRes Function(Input$ClubCreateInput) then,
  ) = _CopyWithImpl$Input$ClubCreateInput;

  factory CopyWith$Input$ClubCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClubCreateInput;

  TRes call({
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? short_address,
  });
}

class _CopyWithImpl$Input$ClubCreateInput<TRes>
    implements CopyWith$Input$ClubCreateInput<TRes> {
  _CopyWithImpl$Input$ClubCreateInput(
    this._instance,
    this._then,
  );

  final Input$ClubCreateInput _instance;

  final TRes Function(Input$ClubCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? type = _undefined,
    Object? url = _undefined,
    Object? phone_number = _undefined,
    Object? number_of_member = _undefined,
    Object? number_of_courts = _undefined,
    Object? start_time = _undefined,
    Object? end_time = _undefined,
    Object? is_membership_requre = _undefined,
    Object? cost = _undefined,
    Object? note = _undefined,
    Object? court_type = _undefined,
    Object? country_code = _undefined,
    Object? start_time_mon = _undefined,
    Object? end_time_mon = _undefined,
    Object? start_time_tue = _undefined,
    Object? end_time_tue = _undefined,
    Object? start_time_wed = _undefined,
    Object? end_time_wed = _undefined,
    Object? start_time_thu = _undefined,
    Object? end_time_thu = _undefined,
    Object? start_time_fri = _undefined,
    Object? end_time_fri = _undefined,
    Object? start_time_sat = _undefined,
    Object? end_time_sat = _undefined,
    Object? start_time_sun = _undefined,
    Object? end_time_sun = _undefined,
    Object? is_mon_on = _undefined,
    Object? is_tue_on = _undefined,
    Object? is_wed_on = _undefined,
    Object? is_thu_on = _undefined,
    Object? is_fri_on = _undefined,
    Object? is_sat_on = _undefined,
    Object? is_sun_on = _undefined,
    Object? short_address = _undefined,
  }) =>
      _then(Input$ClubCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (type != _undefined) 'type': (type as String?),
        if (url != _undefined) 'url': (url as String?),
        if (phone_number != _undefined)
          'phone_number': (phone_number as String?),
        if (number_of_member != _undefined)
          'number_of_member': (number_of_member as String?),
        if (number_of_courts != _undefined)
          'number_of_courts': (number_of_courts as String?),
        if (start_time != _undefined) 'start_time': (start_time as String?),
        if (end_time != _undefined) 'end_time': (end_time as String?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (cost != _undefined) 'cost': (cost as String?),
        if (note != _undefined) 'note': (note as String?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
        if (country_code != _undefined)
          'country_code': (country_code as String?),
        if (start_time_mon != _undefined)
          'start_time_mon': (start_time_mon as String?),
        if (end_time_mon != _undefined)
          'end_time_mon': (end_time_mon as String?),
        if (start_time_tue != _undefined)
          'start_time_tue': (start_time_tue as String?),
        if (end_time_tue != _undefined)
          'end_time_tue': (end_time_tue as String?),
        if (start_time_wed != _undefined)
          'start_time_wed': (start_time_wed as String?),
        if (end_time_wed != _undefined)
          'end_time_wed': (end_time_wed as String?),
        if (start_time_thu != _undefined)
          'start_time_thu': (start_time_thu as String?),
        if (end_time_thu != _undefined)
          'end_time_thu': (end_time_thu as String?),
        if (start_time_fri != _undefined)
          'start_time_fri': (start_time_fri as String?),
        if (end_time_fri != _undefined)
          'end_time_fri': (end_time_fri as String?),
        if (start_time_sat != _undefined)
          'start_time_sat': (start_time_sat as String?),
        if (end_time_sat != _undefined)
          'end_time_sat': (end_time_sat as String?),
        if (start_time_sun != _undefined)
          'start_time_sun': (start_time_sun as String?),
        if (end_time_sun != _undefined)
          'end_time_sun': (end_time_sun as String?),
        if (is_mon_on != _undefined) 'is_mon_on': (is_mon_on as bool?),
        if (is_tue_on != _undefined) 'is_tue_on': (is_tue_on as bool?),
        if (is_wed_on != _undefined) 'is_wed_on': (is_wed_on as bool?),
        if (is_thu_on != _undefined) 'is_thu_on': (is_thu_on as bool?),
        if (is_fri_on != _undefined) 'is_fri_on': (is_fri_on as bool?),
        if (is_sat_on != _undefined) 'is_sat_on': (is_sat_on as bool?),
        if (is_sun_on != _undefined) 'is_sun_on': (is_sun_on as bool?),
        if (short_address != _undefined)
          'short_address': (short_address as String?),
      }));
}

class _CopyWithStubImpl$Input$ClubCreateInput<TRes>
    implements CopyWith$Input$ClubCreateInput<TRes> {
  _CopyWithStubImpl$Input$ClubCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? short_address,
  }) =>
      _res;
}

class Input$CulbPaginationInput {
  factory Input$CulbPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? state,
    String? is_approve,
    String? no_member,
  }) =>
      Input$CulbPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (club_type != null) r'club_type': club_type,
        if (is_export != null) r'is_export': is_export,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (state != null) r'state': state,
        if (is_approve != null) r'is_approve': is_approve,
        if (no_member != null) r'no_member': no_member,
      });

  Input$CulbPaginationInput._(this._$data);

  factory Input$CulbPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_export')) {
      final l$is_export = data['is_export'];
      result$data['is_export'] = (l$is_export as int?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('is_approve')) {
      final l$is_approve = data['is_approve'];
      result$data['is_approve'] = (l$is_approve as String?);
    }
    if (data.containsKey('no_member')) {
      final l$no_member = data['no_member'];
      result$data['no_member'] = (l$no_member as String?);
    }
    return Input$CulbPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  int? get is_export => (_$data['is_export'] as int?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get is_approve => (_$data['is_approve'] as String?);

  String? get no_member => (_$data['no_member'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_export')) {
      final l$is_export = is_export;
      result$data['is_export'] = l$is_export;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('is_approve')) {
      final l$is_approve = is_approve;
      result$data['is_approve'] = l$is_approve;
    }
    if (_$data.containsKey('no_member')) {
      final l$no_member = no_member;
      result$data['no_member'] = l$no_member;
    }
    return result$data;
  }

  CopyWith$Input$CulbPaginationInput<Input$CulbPaginationInput> get copyWith =>
      CopyWith$Input$CulbPaginationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CulbPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_export = is_export;
    final lOther$is_export = other.is_export;
    if (_$data.containsKey('is_export') !=
        other._$data.containsKey('is_export')) {
      return false;
    }
    if (l$is_export != lOther$is_export) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$is_approve = is_approve;
    final lOther$is_approve = other.is_approve;
    if (_$data.containsKey('is_approve') !=
        other._$data.containsKey('is_approve')) {
      return false;
    }
    if (l$is_approve != lOther$is_approve) {
      return false;
    }
    final l$no_member = no_member;
    final lOther$no_member = other.no_member;
    if (_$data.containsKey('no_member') !=
        other._$data.containsKey('no_member')) {
      return false;
    }
    if (l$no_member != lOther$no_member) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$address = address;
    final l$club_type = club_type;
    final l$is_export = is_export;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$state = state;
    final l$is_approve = is_approve;
    final l$no_member = no_member;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_export') ? l$is_export : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('is_approve') ? l$is_approve : const {},
      _$data.containsKey('no_member') ? l$no_member : const {},
    ]);
  }
}

abstract class CopyWith$Input$CulbPaginationInput<TRes> {
  factory CopyWith$Input$CulbPaginationInput(
    Input$CulbPaginationInput instance,
    TRes Function(Input$CulbPaginationInput) then,
  ) = _CopyWithImpl$Input$CulbPaginationInput;

  factory CopyWith$Input$CulbPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CulbPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? state,
    String? is_approve,
    String? no_member,
  });
}

class _CopyWithImpl$Input$CulbPaginationInput<TRes>
    implements CopyWith$Input$CulbPaginationInput<TRes> {
  _CopyWithImpl$Input$CulbPaginationInput(
    this._instance,
    this._then,
  );

  final Input$CulbPaginationInput _instance;

  final TRes Function(Input$CulbPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? club_type = _undefined,
    Object? is_export = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? state = _undefined,
    Object? is_approve = _undefined,
    Object? no_member = _undefined,
  }) =>
      _then(Input$CulbPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (address != _undefined) 'address': (address as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_export != _undefined) 'is_export': (is_export as int?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (state != _undefined) 'state': (state as String?),
        if (is_approve != _undefined) 'is_approve': (is_approve as String?),
        if (no_member != _undefined) 'no_member': (no_member as String?),
      }));
}

class _CopyWithStubImpl$Input$CulbPaginationInput<TRes>
    implements CopyWith$Input$CulbPaginationInput<TRes> {
  _CopyWithStubImpl$Input$CulbPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? state,
    String? is_approve,
    String? no_member,
  }) =>
      _res;
}

class Input$UpdateStatusInput {
  factory Input$UpdateStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateStatusInput._(this._$data);

  factory Input$UpdateStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateStatusInput<Input$UpdateStatusInput> get copyWith =>
      CopyWith$Input$UpdateStatusInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateStatusInput<TRes> {
  factory CopyWith$Input$UpdateStatusInput(
    Input$UpdateStatusInput instance,
    TRes Function(Input$UpdateStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateStatusInput;

  factory CopyWith$Input$UpdateStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateStatusInput<TRes>
    implements CopyWith$Input$UpdateStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateStatusInput _instance;

  final TRes Function(Input$UpdateStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateStatusInput<TRes>
    implements CopyWith$Input$UpdateStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$viewClubInput {
  factory Input$viewClubInput({required String uuid}) => Input$viewClubInput._({
        r'uuid': uuid,
      });

  Input$viewClubInput._(this._$data);

  factory Input$viewClubInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewClubInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewClubInput<Input$viewClubInput> get copyWith =>
      CopyWith$Input$viewClubInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewClubInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewClubInput<TRes> {
  factory CopyWith$Input$viewClubInput(
    Input$viewClubInput instance,
    TRes Function(Input$viewClubInput) then,
  ) = _CopyWithImpl$Input$viewClubInput;

  factory CopyWith$Input$viewClubInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewClubInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewClubInput<TRes>
    implements CopyWith$Input$viewClubInput<TRes> {
  _CopyWithImpl$Input$viewClubInput(
    this._instance,
    this._then,
  );

  final Input$viewClubInput _instance;

  final TRes Function(Input$viewClubInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewClubInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewClubInput<TRes>
    implements CopyWith$Input$viewClubInput<TRes> {
  _CopyWithStubImpl$Input$viewClubInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$deleteClubInput {
  factory Input$deleteClubInput({required String uuid}) =>
      Input$deleteClubInput._({
        r'uuid': uuid,
      });

  Input$deleteClubInput._(this._$data);

  factory Input$deleteClubInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteClubInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteClubInput<Input$deleteClubInput> get copyWith =>
      CopyWith$Input$deleteClubInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteClubInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteClubInput<TRes> {
  factory CopyWith$Input$deleteClubInput(
    Input$deleteClubInput instance,
    TRes Function(Input$deleteClubInput) then,
  ) = _CopyWithImpl$Input$deleteClubInput;

  factory CopyWith$Input$deleteClubInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteClubInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteClubInput<TRes>
    implements CopyWith$Input$deleteClubInput<TRes> {
  _CopyWithImpl$Input$deleteClubInput(
    this._instance,
    this._then,
  );

  final Input$deleteClubInput _instance;

  final TRes Function(Input$deleteClubInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteClubInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteClubInput<TRes>
    implements CopyWith$Input$deleteClubInput<TRes> {
  _CopyWithStubImpl$Input$deleteClubInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ClubUpdateInput {
  factory Input$ClubUpdateInput({
    required String uuid,
    required String name,
    required String address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? short_address,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
  }) =>
      Input$ClubUpdateInput._({
        r'uuid': uuid,
        r'name': name,
        r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (type != null) r'type': type,
        if (url != null) r'url': url,
        if (phone_number != null) r'phone_number': phone_number,
        if (number_of_member != null) r'number_of_member': number_of_member,
        if (number_of_courts != null) r'number_of_courts': number_of_courts,
        if (start_time != null) r'start_time': start_time,
        if (end_time != null) r'end_time': end_time,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (cost != null) r'cost': cost,
        if (note != null) r'note': note,
        if (short_address != null) r'short_address': short_address,
        if (court_type != null) r'court_type': court_type,
        if (country_code != null) r'country_code': country_code,
        if (start_time_mon != null) r'start_time_mon': start_time_mon,
        if (end_time_mon != null) r'end_time_mon': end_time_mon,
        if (start_time_tue != null) r'start_time_tue': start_time_tue,
        if (end_time_tue != null) r'end_time_tue': end_time_tue,
        if (start_time_wed != null) r'start_time_wed': start_time_wed,
        if (end_time_wed != null) r'end_time_wed': end_time_wed,
        if (start_time_thu != null) r'start_time_thu': start_time_thu,
        if (end_time_thu != null) r'end_time_thu': end_time_thu,
        if (start_time_fri != null) r'start_time_fri': start_time_fri,
        if (end_time_fri != null) r'end_time_fri': end_time_fri,
        if (start_time_sat != null) r'start_time_sat': start_time_sat,
        if (end_time_sat != null) r'end_time_sat': end_time_sat,
        if (start_time_sun != null) r'start_time_sun': start_time_sun,
        if (end_time_sun != null) r'end_time_sun': end_time_sun,
        if (is_mon_on != null) r'is_mon_on': is_mon_on,
        if (is_tue_on != null) r'is_tue_on': is_tue_on,
        if (is_wed_on != null) r'is_wed_on': is_wed_on,
        if (is_thu_on != null) r'is_thu_on': is_thu_on,
        if (is_fri_on != null) r'is_fri_on': is_fri_on,
        if (is_sat_on != null) r'is_sat_on': is_sat_on,
        if (is_sun_on != null) r'is_sun_on': is_sun_on,
      });

  Input$ClubUpdateInput._(this._$data);

  factory Input$ClubUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('phone_number')) {
      final l$phone_number = data['phone_number'];
      result$data['phone_number'] = (l$phone_number as String?);
    }
    if (data.containsKey('number_of_member')) {
      final l$number_of_member = data['number_of_member'];
      result$data['number_of_member'] = (l$number_of_member as String?);
    }
    if (data.containsKey('number_of_courts')) {
      final l$number_of_courts = data['number_of_courts'];
      result$data['number_of_courts'] = (l$number_of_courts as String?);
    }
    if (data.containsKey('start_time')) {
      final l$start_time = data['start_time'];
      result$data['start_time'] = (l$start_time as String?);
    }
    if (data.containsKey('end_time')) {
      final l$end_time = data['end_time'];
      result$data['end_time'] = (l$end_time as String?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('cost')) {
      final l$cost = data['cost'];
      result$data['cost'] = (l$cost as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('short_address')) {
      final l$short_address = data['short_address'];
      result$data['short_address'] = (l$short_address as String?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    if (data.containsKey('country_code')) {
      final l$country_code = data['country_code'];
      result$data['country_code'] = (l$country_code as String?);
    }
    if (data.containsKey('start_time_mon')) {
      final l$start_time_mon = data['start_time_mon'];
      result$data['start_time_mon'] = (l$start_time_mon as String?);
    }
    if (data.containsKey('end_time_mon')) {
      final l$end_time_mon = data['end_time_mon'];
      result$data['end_time_mon'] = (l$end_time_mon as String?);
    }
    if (data.containsKey('start_time_tue')) {
      final l$start_time_tue = data['start_time_tue'];
      result$data['start_time_tue'] = (l$start_time_tue as String?);
    }
    if (data.containsKey('end_time_tue')) {
      final l$end_time_tue = data['end_time_tue'];
      result$data['end_time_tue'] = (l$end_time_tue as String?);
    }
    if (data.containsKey('start_time_wed')) {
      final l$start_time_wed = data['start_time_wed'];
      result$data['start_time_wed'] = (l$start_time_wed as String?);
    }
    if (data.containsKey('end_time_wed')) {
      final l$end_time_wed = data['end_time_wed'];
      result$data['end_time_wed'] = (l$end_time_wed as String?);
    }
    if (data.containsKey('start_time_thu')) {
      final l$start_time_thu = data['start_time_thu'];
      result$data['start_time_thu'] = (l$start_time_thu as String?);
    }
    if (data.containsKey('end_time_thu')) {
      final l$end_time_thu = data['end_time_thu'];
      result$data['end_time_thu'] = (l$end_time_thu as String?);
    }
    if (data.containsKey('start_time_fri')) {
      final l$start_time_fri = data['start_time_fri'];
      result$data['start_time_fri'] = (l$start_time_fri as String?);
    }
    if (data.containsKey('end_time_fri')) {
      final l$end_time_fri = data['end_time_fri'];
      result$data['end_time_fri'] = (l$end_time_fri as String?);
    }
    if (data.containsKey('start_time_sat')) {
      final l$start_time_sat = data['start_time_sat'];
      result$data['start_time_sat'] = (l$start_time_sat as String?);
    }
    if (data.containsKey('end_time_sat')) {
      final l$end_time_sat = data['end_time_sat'];
      result$data['end_time_sat'] = (l$end_time_sat as String?);
    }
    if (data.containsKey('start_time_sun')) {
      final l$start_time_sun = data['start_time_sun'];
      result$data['start_time_sun'] = (l$start_time_sun as String?);
    }
    if (data.containsKey('end_time_sun')) {
      final l$end_time_sun = data['end_time_sun'];
      result$data['end_time_sun'] = (l$end_time_sun as String?);
    }
    if (data.containsKey('is_mon_on')) {
      final l$is_mon_on = data['is_mon_on'];
      result$data['is_mon_on'] = (l$is_mon_on as bool?);
    }
    if (data.containsKey('is_tue_on')) {
      final l$is_tue_on = data['is_tue_on'];
      result$data['is_tue_on'] = (l$is_tue_on as bool?);
    }
    if (data.containsKey('is_wed_on')) {
      final l$is_wed_on = data['is_wed_on'];
      result$data['is_wed_on'] = (l$is_wed_on as bool?);
    }
    if (data.containsKey('is_thu_on')) {
      final l$is_thu_on = data['is_thu_on'];
      result$data['is_thu_on'] = (l$is_thu_on as bool?);
    }
    if (data.containsKey('is_fri_on')) {
      final l$is_fri_on = data['is_fri_on'];
      result$data['is_fri_on'] = (l$is_fri_on as bool?);
    }
    if (data.containsKey('is_sat_on')) {
      final l$is_sat_on = data['is_sat_on'];
      result$data['is_sat_on'] = (l$is_sat_on as bool?);
    }
    if (data.containsKey('is_sun_on')) {
      final l$is_sun_on = data['is_sun_on'];
      result$data['is_sun_on'] = (l$is_sun_on as bool?);
    }
    return Input$ClubUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get name => (_$data['name'] as String);

  String get address => (_$data['address'] as String);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get type => (_$data['type'] as String?);

  String? get url => (_$data['url'] as String?);

  String? get phone_number => (_$data['phone_number'] as String?);

  String? get number_of_member => (_$data['number_of_member'] as String?);

  String? get number_of_courts => (_$data['number_of_courts'] as String?);

  String? get start_time => (_$data['start_time'] as String?);

  String? get end_time => (_$data['end_time'] as String?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get cost => (_$data['cost'] as String?);

  String? get note => (_$data['note'] as String?);

  String? get short_address => (_$data['short_address'] as String?);

  String? get court_type => (_$data['court_type'] as String?);

  String? get country_code => (_$data['country_code'] as String?);

  String? get start_time_mon => (_$data['start_time_mon'] as String?);

  String? get end_time_mon => (_$data['end_time_mon'] as String?);

  String? get start_time_tue => (_$data['start_time_tue'] as String?);

  String? get end_time_tue => (_$data['end_time_tue'] as String?);

  String? get start_time_wed => (_$data['start_time_wed'] as String?);

  String? get end_time_wed => (_$data['end_time_wed'] as String?);

  String? get start_time_thu => (_$data['start_time_thu'] as String?);

  String? get end_time_thu => (_$data['end_time_thu'] as String?);

  String? get start_time_fri => (_$data['start_time_fri'] as String?);

  String? get end_time_fri => (_$data['end_time_fri'] as String?);

  String? get start_time_sat => (_$data['start_time_sat'] as String?);

  String? get end_time_sat => (_$data['end_time_sat'] as String?);

  String? get start_time_sun => (_$data['start_time_sun'] as String?);

  String? get end_time_sun => (_$data['end_time_sun'] as String?);

  bool? get is_mon_on => (_$data['is_mon_on'] as bool?);

  bool? get is_tue_on => (_$data['is_tue_on'] as bool?);

  bool? get is_wed_on => (_$data['is_wed_on'] as bool?);

  bool? get is_thu_on => (_$data['is_thu_on'] as bool?);

  bool? get is_fri_on => (_$data['is_fri_on'] as bool?);

  bool? get is_sat_on => (_$data['is_sat_on'] as bool?);

  bool? get is_sun_on => (_$data['is_sun_on'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$name = name;
    result$data['name'] = l$name;
    final l$address = address;
    result$data['address'] = l$address;
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('phone_number')) {
      final l$phone_number = phone_number;
      result$data['phone_number'] = l$phone_number;
    }
    if (_$data.containsKey('number_of_member')) {
      final l$number_of_member = number_of_member;
      result$data['number_of_member'] = l$number_of_member;
    }
    if (_$data.containsKey('number_of_courts')) {
      final l$number_of_courts = number_of_courts;
      result$data['number_of_courts'] = l$number_of_courts;
    }
    if (_$data.containsKey('start_time')) {
      final l$start_time = start_time;
      result$data['start_time'] = l$start_time;
    }
    if (_$data.containsKey('end_time')) {
      final l$end_time = end_time;
      result$data['end_time'] = l$end_time;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('cost')) {
      final l$cost = cost;
      result$data['cost'] = l$cost;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('short_address')) {
      final l$short_address = short_address;
      result$data['short_address'] = l$short_address;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    if (_$data.containsKey('country_code')) {
      final l$country_code = country_code;
      result$data['country_code'] = l$country_code;
    }
    if (_$data.containsKey('start_time_mon')) {
      final l$start_time_mon = start_time_mon;
      result$data['start_time_mon'] = l$start_time_mon;
    }
    if (_$data.containsKey('end_time_mon')) {
      final l$end_time_mon = end_time_mon;
      result$data['end_time_mon'] = l$end_time_mon;
    }
    if (_$data.containsKey('start_time_tue')) {
      final l$start_time_tue = start_time_tue;
      result$data['start_time_tue'] = l$start_time_tue;
    }
    if (_$data.containsKey('end_time_tue')) {
      final l$end_time_tue = end_time_tue;
      result$data['end_time_tue'] = l$end_time_tue;
    }
    if (_$data.containsKey('start_time_wed')) {
      final l$start_time_wed = start_time_wed;
      result$data['start_time_wed'] = l$start_time_wed;
    }
    if (_$data.containsKey('end_time_wed')) {
      final l$end_time_wed = end_time_wed;
      result$data['end_time_wed'] = l$end_time_wed;
    }
    if (_$data.containsKey('start_time_thu')) {
      final l$start_time_thu = start_time_thu;
      result$data['start_time_thu'] = l$start_time_thu;
    }
    if (_$data.containsKey('end_time_thu')) {
      final l$end_time_thu = end_time_thu;
      result$data['end_time_thu'] = l$end_time_thu;
    }
    if (_$data.containsKey('start_time_fri')) {
      final l$start_time_fri = start_time_fri;
      result$data['start_time_fri'] = l$start_time_fri;
    }
    if (_$data.containsKey('end_time_fri')) {
      final l$end_time_fri = end_time_fri;
      result$data['end_time_fri'] = l$end_time_fri;
    }
    if (_$data.containsKey('start_time_sat')) {
      final l$start_time_sat = start_time_sat;
      result$data['start_time_sat'] = l$start_time_sat;
    }
    if (_$data.containsKey('end_time_sat')) {
      final l$end_time_sat = end_time_sat;
      result$data['end_time_sat'] = l$end_time_sat;
    }
    if (_$data.containsKey('start_time_sun')) {
      final l$start_time_sun = start_time_sun;
      result$data['start_time_sun'] = l$start_time_sun;
    }
    if (_$data.containsKey('end_time_sun')) {
      final l$end_time_sun = end_time_sun;
      result$data['end_time_sun'] = l$end_time_sun;
    }
    if (_$data.containsKey('is_mon_on')) {
      final l$is_mon_on = is_mon_on;
      result$data['is_mon_on'] = l$is_mon_on;
    }
    if (_$data.containsKey('is_tue_on')) {
      final l$is_tue_on = is_tue_on;
      result$data['is_tue_on'] = l$is_tue_on;
    }
    if (_$data.containsKey('is_wed_on')) {
      final l$is_wed_on = is_wed_on;
      result$data['is_wed_on'] = l$is_wed_on;
    }
    if (_$data.containsKey('is_thu_on')) {
      final l$is_thu_on = is_thu_on;
      result$data['is_thu_on'] = l$is_thu_on;
    }
    if (_$data.containsKey('is_fri_on')) {
      final l$is_fri_on = is_fri_on;
      result$data['is_fri_on'] = l$is_fri_on;
    }
    if (_$data.containsKey('is_sat_on')) {
      final l$is_sat_on = is_sat_on;
      result$data['is_sat_on'] = l$is_sat_on;
    }
    if (_$data.containsKey('is_sun_on')) {
      final l$is_sun_on = is_sun_on;
      result$data['is_sun_on'] = l$is_sun_on;
    }
    return result$data;
  }

  CopyWith$Input$ClubUpdateInput<Input$ClubUpdateInput> get copyWith =>
      CopyWith$Input$ClubUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClubUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$phone_number = phone_number;
    final lOther$phone_number = other.phone_number;
    if (_$data.containsKey('phone_number') !=
        other._$data.containsKey('phone_number')) {
      return false;
    }
    if (l$phone_number != lOther$phone_number) {
      return false;
    }
    final l$number_of_member = number_of_member;
    final lOther$number_of_member = other.number_of_member;
    if (_$data.containsKey('number_of_member') !=
        other._$data.containsKey('number_of_member')) {
      return false;
    }
    if (l$number_of_member != lOther$number_of_member) {
      return false;
    }
    final l$number_of_courts = number_of_courts;
    final lOther$number_of_courts = other.number_of_courts;
    if (_$data.containsKey('number_of_courts') !=
        other._$data.containsKey('number_of_courts')) {
      return false;
    }
    if (l$number_of_courts != lOther$number_of_courts) {
      return false;
    }
    final l$start_time = start_time;
    final lOther$start_time = other.start_time;
    if (_$data.containsKey('start_time') !=
        other._$data.containsKey('start_time')) {
      return false;
    }
    if (l$start_time != lOther$start_time) {
      return false;
    }
    final l$end_time = end_time;
    final lOther$end_time = other.end_time;
    if (_$data.containsKey('end_time') !=
        other._$data.containsKey('end_time')) {
      return false;
    }
    if (l$end_time != lOther$end_time) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$cost = cost;
    final lOther$cost = other.cost;
    if (_$data.containsKey('cost') != other._$data.containsKey('cost')) {
      return false;
    }
    if (l$cost != lOther$cost) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$short_address = short_address;
    final lOther$short_address = other.short_address;
    if (_$data.containsKey('short_address') !=
        other._$data.containsKey('short_address')) {
      return false;
    }
    if (l$short_address != lOther$short_address) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    final l$country_code = country_code;
    final lOther$country_code = other.country_code;
    if (_$data.containsKey('country_code') !=
        other._$data.containsKey('country_code')) {
      return false;
    }
    if (l$country_code != lOther$country_code) {
      return false;
    }
    final l$start_time_mon = start_time_mon;
    final lOther$start_time_mon = other.start_time_mon;
    if (_$data.containsKey('start_time_mon') !=
        other._$data.containsKey('start_time_mon')) {
      return false;
    }
    if (l$start_time_mon != lOther$start_time_mon) {
      return false;
    }
    final l$end_time_mon = end_time_mon;
    final lOther$end_time_mon = other.end_time_mon;
    if (_$data.containsKey('end_time_mon') !=
        other._$data.containsKey('end_time_mon')) {
      return false;
    }
    if (l$end_time_mon != lOther$end_time_mon) {
      return false;
    }
    final l$start_time_tue = start_time_tue;
    final lOther$start_time_tue = other.start_time_tue;
    if (_$data.containsKey('start_time_tue') !=
        other._$data.containsKey('start_time_tue')) {
      return false;
    }
    if (l$start_time_tue != lOther$start_time_tue) {
      return false;
    }
    final l$end_time_tue = end_time_tue;
    final lOther$end_time_tue = other.end_time_tue;
    if (_$data.containsKey('end_time_tue') !=
        other._$data.containsKey('end_time_tue')) {
      return false;
    }
    if (l$end_time_tue != lOther$end_time_tue) {
      return false;
    }
    final l$start_time_wed = start_time_wed;
    final lOther$start_time_wed = other.start_time_wed;
    if (_$data.containsKey('start_time_wed') !=
        other._$data.containsKey('start_time_wed')) {
      return false;
    }
    if (l$start_time_wed != lOther$start_time_wed) {
      return false;
    }
    final l$end_time_wed = end_time_wed;
    final lOther$end_time_wed = other.end_time_wed;
    if (_$data.containsKey('end_time_wed') !=
        other._$data.containsKey('end_time_wed')) {
      return false;
    }
    if (l$end_time_wed != lOther$end_time_wed) {
      return false;
    }
    final l$start_time_thu = start_time_thu;
    final lOther$start_time_thu = other.start_time_thu;
    if (_$data.containsKey('start_time_thu') !=
        other._$data.containsKey('start_time_thu')) {
      return false;
    }
    if (l$start_time_thu != lOther$start_time_thu) {
      return false;
    }
    final l$end_time_thu = end_time_thu;
    final lOther$end_time_thu = other.end_time_thu;
    if (_$data.containsKey('end_time_thu') !=
        other._$data.containsKey('end_time_thu')) {
      return false;
    }
    if (l$end_time_thu != lOther$end_time_thu) {
      return false;
    }
    final l$start_time_fri = start_time_fri;
    final lOther$start_time_fri = other.start_time_fri;
    if (_$data.containsKey('start_time_fri') !=
        other._$data.containsKey('start_time_fri')) {
      return false;
    }
    if (l$start_time_fri != lOther$start_time_fri) {
      return false;
    }
    final l$end_time_fri = end_time_fri;
    final lOther$end_time_fri = other.end_time_fri;
    if (_$data.containsKey('end_time_fri') !=
        other._$data.containsKey('end_time_fri')) {
      return false;
    }
    if (l$end_time_fri != lOther$end_time_fri) {
      return false;
    }
    final l$start_time_sat = start_time_sat;
    final lOther$start_time_sat = other.start_time_sat;
    if (_$data.containsKey('start_time_sat') !=
        other._$data.containsKey('start_time_sat')) {
      return false;
    }
    if (l$start_time_sat != lOther$start_time_sat) {
      return false;
    }
    final l$end_time_sat = end_time_sat;
    final lOther$end_time_sat = other.end_time_sat;
    if (_$data.containsKey('end_time_sat') !=
        other._$data.containsKey('end_time_sat')) {
      return false;
    }
    if (l$end_time_sat != lOther$end_time_sat) {
      return false;
    }
    final l$start_time_sun = start_time_sun;
    final lOther$start_time_sun = other.start_time_sun;
    if (_$data.containsKey('start_time_sun') !=
        other._$data.containsKey('start_time_sun')) {
      return false;
    }
    if (l$start_time_sun != lOther$start_time_sun) {
      return false;
    }
    final l$end_time_sun = end_time_sun;
    final lOther$end_time_sun = other.end_time_sun;
    if (_$data.containsKey('end_time_sun') !=
        other._$data.containsKey('end_time_sun')) {
      return false;
    }
    if (l$end_time_sun != lOther$end_time_sun) {
      return false;
    }
    final l$is_mon_on = is_mon_on;
    final lOther$is_mon_on = other.is_mon_on;
    if (_$data.containsKey('is_mon_on') !=
        other._$data.containsKey('is_mon_on')) {
      return false;
    }
    if (l$is_mon_on != lOther$is_mon_on) {
      return false;
    }
    final l$is_tue_on = is_tue_on;
    final lOther$is_tue_on = other.is_tue_on;
    if (_$data.containsKey('is_tue_on') !=
        other._$data.containsKey('is_tue_on')) {
      return false;
    }
    if (l$is_tue_on != lOther$is_tue_on) {
      return false;
    }
    final l$is_wed_on = is_wed_on;
    final lOther$is_wed_on = other.is_wed_on;
    if (_$data.containsKey('is_wed_on') !=
        other._$data.containsKey('is_wed_on')) {
      return false;
    }
    if (l$is_wed_on != lOther$is_wed_on) {
      return false;
    }
    final l$is_thu_on = is_thu_on;
    final lOther$is_thu_on = other.is_thu_on;
    if (_$data.containsKey('is_thu_on') !=
        other._$data.containsKey('is_thu_on')) {
      return false;
    }
    if (l$is_thu_on != lOther$is_thu_on) {
      return false;
    }
    final l$is_fri_on = is_fri_on;
    final lOther$is_fri_on = other.is_fri_on;
    if (_$data.containsKey('is_fri_on') !=
        other._$data.containsKey('is_fri_on')) {
      return false;
    }
    if (l$is_fri_on != lOther$is_fri_on) {
      return false;
    }
    final l$is_sat_on = is_sat_on;
    final lOther$is_sat_on = other.is_sat_on;
    if (_$data.containsKey('is_sat_on') !=
        other._$data.containsKey('is_sat_on')) {
      return false;
    }
    if (l$is_sat_on != lOther$is_sat_on) {
      return false;
    }
    final l$is_sun_on = is_sun_on;
    final lOther$is_sun_on = other.is_sun_on;
    if (_$data.containsKey('is_sun_on') !=
        other._$data.containsKey('is_sun_on')) {
      return false;
    }
    if (l$is_sun_on != lOther$is_sun_on) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$image = image;
    final l$file_path = file_path;
    final l$type = type;
    final l$url = url;
    final l$phone_number = phone_number;
    final l$number_of_member = number_of_member;
    final l$number_of_courts = number_of_courts;
    final l$start_time = start_time;
    final l$end_time = end_time;
    final l$is_membership_requre = is_membership_requre;
    final l$cost = cost;
    final l$note = note;
    final l$short_address = short_address;
    final l$court_type = court_type;
    final l$country_code = country_code;
    final l$start_time_mon = start_time_mon;
    final l$end_time_mon = end_time_mon;
    final l$start_time_tue = start_time_tue;
    final l$end_time_tue = end_time_tue;
    final l$start_time_wed = start_time_wed;
    final l$end_time_wed = end_time_wed;
    final l$start_time_thu = start_time_thu;
    final l$end_time_thu = end_time_thu;
    final l$start_time_fri = start_time_fri;
    final l$end_time_fri = end_time_fri;
    final l$start_time_sat = start_time_sat;
    final l$end_time_sat = end_time_sat;
    final l$start_time_sun = start_time_sun;
    final l$end_time_sun = end_time_sun;
    final l$is_mon_on = is_mon_on;
    final l$is_tue_on = is_tue_on;
    final l$is_wed_on = is_wed_on;
    final l$is_thu_on = is_thu_on;
    final l$is_fri_on = is_fri_on;
    final l$is_sat_on = is_sat_on;
    final l$is_sun_on = is_sun_on;
    return Object.hashAll([
      l$uuid,
      l$name,
      l$address,
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('phone_number') ? l$phone_number : const {},
      _$data.containsKey('number_of_member') ? l$number_of_member : const {},
      _$data.containsKey('number_of_courts') ? l$number_of_courts : const {},
      _$data.containsKey('start_time') ? l$start_time : const {},
      _$data.containsKey('end_time') ? l$end_time : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('cost') ? l$cost : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('short_address') ? l$short_address : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
      _$data.containsKey('country_code') ? l$country_code : const {},
      _$data.containsKey('start_time_mon') ? l$start_time_mon : const {},
      _$data.containsKey('end_time_mon') ? l$end_time_mon : const {},
      _$data.containsKey('start_time_tue') ? l$start_time_tue : const {},
      _$data.containsKey('end_time_tue') ? l$end_time_tue : const {},
      _$data.containsKey('start_time_wed') ? l$start_time_wed : const {},
      _$data.containsKey('end_time_wed') ? l$end_time_wed : const {},
      _$data.containsKey('start_time_thu') ? l$start_time_thu : const {},
      _$data.containsKey('end_time_thu') ? l$end_time_thu : const {},
      _$data.containsKey('start_time_fri') ? l$start_time_fri : const {},
      _$data.containsKey('end_time_fri') ? l$end_time_fri : const {},
      _$data.containsKey('start_time_sat') ? l$start_time_sat : const {},
      _$data.containsKey('end_time_sat') ? l$end_time_sat : const {},
      _$data.containsKey('start_time_sun') ? l$start_time_sun : const {},
      _$data.containsKey('end_time_sun') ? l$end_time_sun : const {},
      _$data.containsKey('is_mon_on') ? l$is_mon_on : const {},
      _$data.containsKey('is_tue_on') ? l$is_tue_on : const {},
      _$data.containsKey('is_wed_on') ? l$is_wed_on : const {},
      _$data.containsKey('is_thu_on') ? l$is_thu_on : const {},
      _$data.containsKey('is_fri_on') ? l$is_fri_on : const {},
      _$data.containsKey('is_sat_on') ? l$is_sat_on : const {},
      _$data.containsKey('is_sun_on') ? l$is_sun_on : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClubUpdateInput<TRes> {
  factory CopyWith$Input$ClubUpdateInput(
    Input$ClubUpdateInput instance,
    TRes Function(Input$ClubUpdateInput) then,
  ) = _CopyWithImpl$Input$ClubUpdateInput;

  factory CopyWith$Input$ClubUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClubUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? short_address,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
  });
}

class _CopyWithImpl$Input$ClubUpdateInput<TRes>
    implements CopyWith$Input$ClubUpdateInput<TRes> {
  _CopyWithImpl$Input$ClubUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ClubUpdateInput _instance;

  final TRes Function(Input$ClubUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? type = _undefined,
    Object? url = _undefined,
    Object? phone_number = _undefined,
    Object? number_of_member = _undefined,
    Object? number_of_courts = _undefined,
    Object? start_time = _undefined,
    Object? end_time = _undefined,
    Object? is_membership_requre = _undefined,
    Object? cost = _undefined,
    Object? note = _undefined,
    Object? short_address = _undefined,
    Object? court_type = _undefined,
    Object? country_code = _undefined,
    Object? start_time_mon = _undefined,
    Object? end_time_mon = _undefined,
    Object? start_time_tue = _undefined,
    Object? end_time_tue = _undefined,
    Object? start_time_wed = _undefined,
    Object? end_time_wed = _undefined,
    Object? start_time_thu = _undefined,
    Object? end_time_thu = _undefined,
    Object? start_time_fri = _undefined,
    Object? end_time_fri = _undefined,
    Object? start_time_sat = _undefined,
    Object? end_time_sat = _undefined,
    Object? start_time_sun = _undefined,
    Object? end_time_sun = _undefined,
    Object? is_mon_on = _undefined,
    Object? is_tue_on = _undefined,
    Object? is_wed_on = _undefined,
    Object? is_thu_on = _undefined,
    Object? is_fri_on = _undefined,
    Object? is_sat_on = _undefined,
    Object? is_sun_on = _undefined,
  }) =>
      _then(Input$ClubUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (type != _undefined) 'type': (type as String?),
        if (url != _undefined) 'url': (url as String?),
        if (phone_number != _undefined)
          'phone_number': (phone_number as String?),
        if (number_of_member != _undefined)
          'number_of_member': (number_of_member as String?),
        if (number_of_courts != _undefined)
          'number_of_courts': (number_of_courts as String?),
        if (start_time != _undefined) 'start_time': (start_time as String?),
        if (end_time != _undefined) 'end_time': (end_time as String?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (cost != _undefined) 'cost': (cost as String?),
        if (note != _undefined) 'note': (note as String?),
        if (short_address != _undefined)
          'short_address': (short_address as String?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
        if (country_code != _undefined)
          'country_code': (country_code as String?),
        if (start_time_mon != _undefined)
          'start_time_mon': (start_time_mon as String?),
        if (end_time_mon != _undefined)
          'end_time_mon': (end_time_mon as String?),
        if (start_time_tue != _undefined)
          'start_time_tue': (start_time_tue as String?),
        if (end_time_tue != _undefined)
          'end_time_tue': (end_time_tue as String?),
        if (start_time_wed != _undefined)
          'start_time_wed': (start_time_wed as String?),
        if (end_time_wed != _undefined)
          'end_time_wed': (end_time_wed as String?),
        if (start_time_thu != _undefined)
          'start_time_thu': (start_time_thu as String?),
        if (end_time_thu != _undefined)
          'end_time_thu': (end_time_thu as String?),
        if (start_time_fri != _undefined)
          'start_time_fri': (start_time_fri as String?),
        if (end_time_fri != _undefined)
          'end_time_fri': (end_time_fri as String?),
        if (start_time_sat != _undefined)
          'start_time_sat': (start_time_sat as String?),
        if (end_time_sat != _undefined)
          'end_time_sat': (end_time_sat as String?),
        if (start_time_sun != _undefined)
          'start_time_sun': (start_time_sun as String?),
        if (end_time_sun != _undefined)
          'end_time_sun': (end_time_sun as String?),
        if (is_mon_on != _undefined) 'is_mon_on': (is_mon_on as bool?),
        if (is_tue_on != _undefined) 'is_tue_on': (is_tue_on as bool?),
        if (is_wed_on != _undefined) 'is_wed_on': (is_wed_on as bool?),
        if (is_thu_on != _undefined) 'is_thu_on': (is_thu_on as bool?),
        if (is_fri_on != _undefined) 'is_fri_on': (is_fri_on as bool?),
        if (is_sat_on != _undefined) 'is_sat_on': (is_sat_on as bool?),
        if (is_sun_on != _undefined) 'is_sun_on': (is_sun_on as bool?),
      }));
}

class _CopyWithStubImpl$Input$ClubUpdateInput<TRes>
    implements CopyWith$Input$ClubUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ClubUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? address,
    String? latitude,
    String? longitude,
    String? image,
    String? file_path,
    String? type,
    String? url,
    String? phone_number,
    String? number_of_member,
    String? number_of_courts,
    String? start_time,
    String? end_time,
    String? is_membership_requre,
    String? cost,
    String? note,
    String? short_address,
    String? court_type,
    String? country_code,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
  }) =>
      _res;
}

class Input$MemberPaginationInput {
  factory Input$MemberPaginationInput({
    required int offset,
    int? limit,
    String? uuid,
    String? full_name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$MemberPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (uuid != null) r'uuid': uuid,
        if (full_name != null) r'full_name': full_name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$MemberPaginationInput._(this._$data);

  factory Input$MemberPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$MemberPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get uuid => (_$data['uuid'] as String?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$MemberPaginationInput<Input$MemberPaginationInput>
      get copyWith => CopyWith$Input$MemberPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MemberPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$uuid = uuid;
    final l$full_name = full_name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$MemberPaginationInput<TRes> {
  factory CopyWith$Input$MemberPaginationInput(
    Input$MemberPaginationInput instance,
    TRes Function(Input$MemberPaginationInput) then,
  ) = _CopyWithImpl$Input$MemberPaginationInput;

  factory CopyWith$Input$MemberPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MemberPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? uuid,
    String? full_name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$MemberPaginationInput<TRes>
    implements CopyWith$Input$MemberPaginationInput<TRes> {
  _CopyWithImpl$Input$MemberPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MemberPaginationInput _instance;

  final TRes Function(Input$MemberPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? uuid = _undefined,
    Object? full_name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$MemberPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$MemberPaginationInput<TRes>
    implements CopyWith$Input$MemberPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MemberPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? uuid,
    String? full_name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$exportCulbPaginationInput {
  factory Input$exportCulbPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? sort_column,
    String? sort_order,
    String? start_date,
    String? end_date,
    String? state,
    String? is_approve,
    String? no_member,
  }) =>
      Input$exportCulbPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (address != null) r'address': address,
        if (club_type != null) r'club_type': club_type,
        if (is_export != null) r'is_export': is_export,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (state != null) r'state': state,
        if (is_approve != null) r'is_approve': is_approve,
        if (no_member != null) r'no_member': no_member,
      });

  Input$exportCulbPaginationInput._(this._$data);

  factory Input$exportCulbPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_export')) {
      final l$is_export = data['is_export'];
      result$data['is_export'] = (l$is_export as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('is_approve')) {
      final l$is_approve = data['is_approve'];
      result$data['is_approve'] = (l$is_approve as String?);
    }
    if (data.containsKey('no_member')) {
      final l$no_member = data['no_member'];
      result$data['no_member'] = (l$no_member as String?);
    }
    return Input$exportCulbPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  int? get is_export => (_$data['is_export'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get is_approve => (_$data['is_approve'] as String?);

  String? get no_member => (_$data['no_member'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_export')) {
      final l$is_export = is_export;
      result$data['is_export'] = l$is_export;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('is_approve')) {
      final l$is_approve = is_approve;
      result$data['is_approve'] = l$is_approve;
    }
    if (_$data.containsKey('no_member')) {
      final l$no_member = no_member;
      result$data['no_member'] = l$no_member;
    }
    return result$data;
  }

  CopyWith$Input$exportCulbPaginationInput<Input$exportCulbPaginationInput>
      get copyWith => CopyWith$Input$exportCulbPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$exportCulbPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_export = is_export;
    final lOther$is_export = other.is_export;
    if (_$data.containsKey('is_export') !=
        other._$data.containsKey('is_export')) {
      return false;
    }
    if (l$is_export != lOther$is_export) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$is_approve = is_approve;
    final lOther$is_approve = other.is_approve;
    if (_$data.containsKey('is_approve') !=
        other._$data.containsKey('is_approve')) {
      return false;
    }
    if (l$is_approve != lOther$is_approve) {
      return false;
    }
    final l$no_member = no_member;
    final lOther$no_member = other.no_member;
    if (_$data.containsKey('no_member') !=
        other._$data.containsKey('no_member')) {
      return false;
    }
    if (l$no_member != lOther$no_member) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$address = address;
    final l$club_type = club_type;
    final l$is_export = is_export;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$state = state;
    final l$is_approve = is_approve;
    final l$no_member = no_member;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_export') ? l$is_export : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('is_approve') ? l$is_approve : const {},
      _$data.containsKey('no_member') ? l$no_member : const {},
    ]);
  }
}

abstract class CopyWith$Input$exportCulbPaginationInput<TRes> {
  factory CopyWith$Input$exportCulbPaginationInput(
    Input$exportCulbPaginationInput instance,
    TRes Function(Input$exportCulbPaginationInput) then,
  ) = _CopyWithImpl$Input$exportCulbPaginationInput;

  factory CopyWith$Input$exportCulbPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$exportCulbPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? sort_column,
    String? sort_order,
    String? start_date,
    String? end_date,
    String? state,
    String? is_approve,
    String? no_member,
  });
}

class _CopyWithImpl$Input$exportCulbPaginationInput<TRes>
    implements CopyWith$Input$exportCulbPaginationInput<TRes> {
  _CopyWithImpl$Input$exportCulbPaginationInput(
    this._instance,
    this._then,
  );

  final Input$exportCulbPaginationInput _instance;

  final TRes Function(Input$exportCulbPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? address = _undefined,
    Object? club_type = _undefined,
    Object? is_export = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? state = _undefined,
    Object? is_approve = _undefined,
    Object? no_member = _undefined,
  }) =>
      _then(Input$exportCulbPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (address != _undefined) 'address': (address as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_export != _undefined) 'is_export': (is_export as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (state != _undefined) 'state': (state as String?),
        if (is_approve != _undefined) 'is_approve': (is_approve as String?),
        if (no_member != _undefined) 'no_member': (no_member as String?),
      }));
}

class _CopyWithStubImpl$Input$exportCulbPaginationInput<TRes>
    implements CopyWith$Input$exportCulbPaginationInput<TRes> {
  _CopyWithStubImpl$Input$exportCulbPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? address,
    String? club_type,
    int? is_export,
    String? sort_column,
    String? sort_order,
    String? start_date,
    String? end_date,
    String? state,
    String? is_approve,
    String? no_member,
  }) =>
      _res;
}

class Input$ApproveClubInput {
  factory Input$ApproveClubInput({
    required String uuid,
    required int is_approve,
  }) =>
      Input$ApproveClubInput._({
        r'uuid': uuid,
        r'is_approve': is_approve,
      });

  Input$ApproveClubInput._(this._$data);

  factory Input$ApproveClubInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$is_approve = data['is_approve'];
    result$data['is_approve'] = (l$is_approve as int);
    return Input$ApproveClubInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  int get is_approve => (_$data['is_approve'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$is_approve = is_approve;
    result$data['is_approve'] = l$is_approve;
    return result$data;
  }

  CopyWith$Input$ApproveClubInput<Input$ApproveClubInput> get copyWith =>
      CopyWith$Input$ApproveClubInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApproveClubInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$is_approve = is_approve;
    final lOther$is_approve = other.is_approve;
    if (l$is_approve != lOther$is_approve) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$is_approve = is_approve;
    return Object.hashAll([
      l$uuid,
      l$is_approve,
    ]);
  }
}

abstract class CopyWith$Input$ApproveClubInput<TRes> {
  factory CopyWith$Input$ApproveClubInput(
    Input$ApproveClubInput instance,
    TRes Function(Input$ApproveClubInput) then,
  ) = _CopyWithImpl$Input$ApproveClubInput;

  factory CopyWith$Input$ApproveClubInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveClubInput;

  TRes call({
    String? uuid,
    int? is_approve,
  });
}

class _CopyWithImpl$Input$ApproveClubInput<TRes>
    implements CopyWith$Input$ApproveClubInput<TRes> {
  _CopyWithImpl$Input$ApproveClubInput(
    this._instance,
    this._then,
  );

  final Input$ApproveClubInput _instance;

  final TRes Function(Input$ApproveClubInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? is_approve = _undefined,
  }) =>
      _then(Input$ApproveClubInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (is_approve != _undefined && is_approve != null)
          'is_approve': (is_approve as int),
      }));
}

class _CopyWithStubImpl$Input$ApproveClubInput<TRes>
    implements CopyWith$Input$ApproveClubInput<TRes> {
  _CopyWithStubImpl$Input$ApproveClubInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? is_approve,
  }) =>
      _res;
}

class Input$SplashScreen {
  factory Input$SplashScreen({
    required String image,
    required String file_path,
    required String title,
    required String description,
  }) =>
      Input$SplashScreen._({
        r'image': image,
        r'file_path': file_path,
        r'title': title,
        r'description': description,
      });

  Input$SplashScreen._(this._$data);

  factory Input$SplashScreen.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$image = data['image'];
    result$data['image'] = (l$image as String);
    final l$file_path = data['file_path'];
    result$data['file_path'] = (l$file_path as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$SplashScreen._(result$data);
  }

  Map<String, dynamic> _$data;

  String get image => (_$data['image'] as String);

  String get file_path => (_$data['file_path'] as String);

  String get title => (_$data['title'] as String);

  String get description => (_$data['description'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$image = image;
    result$data['image'] = l$image;
    final l$file_path = file_path;
    result$data['file_path'] = l$file_path;
    final l$title = title;
    result$data['title'] = l$title;
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$SplashScreen<Input$SplashScreen> get copyWith =>
      CopyWith$Input$SplashScreen(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SplashScreen) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$image = image;
    final l$file_path = file_path;
    final l$title = title;
    final l$description = description;
    return Object.hashAll([
      l$image,
      l$file_path,
      l$title,
      l$description,
    ]);
  }
}

abstract class CopyWith$Input$SplashScreen<TRes> {
  factory CopyWith$Input$SplashScreen(
    Input$SplashScreen instance,
    TRes Function(Input$SplashScreen) then,
  ) = _CopyWithImpl$Input$SplashScreen;

  factory CopyWith$Input$SplashScreen.stub(TRes res) =
      _CopyWithStubImpl$Input$SplashScreen;

  TRes call({
    String? image,
    String? file_path,
    String? title,
    String? description,
  });
}

class _CopyWithImpl$Input$SplashScreen<TRes>
    implements CopyWith$Input$SplashScreen<TRes> {
  _CopyWithImpl$Input$SplashScreen(
    this._instance,
    this._then,
  );

  final Input$SplashScreen _instance;

  final TRes Function(Input$SplashScreen) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$SplashScreen._({
        ..._instance._$data,
        if (image != _undefined && image != null) 'image': (image as String),
        if (file_path != _undefined && file_path != null)
          'file_path': (file_path as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$SplashScreen<TRes>
    implements CopyWith$Input$SplashScreen<TRes> {
  _CopyWithStubImpl$Input$SplashScreen(this._res);

  TRes _res;

  call({
    String? image,
    String? file_path,
    String? title,
    String? description,
  }) =>
      _res;
}

class Input$SplashScreenPaginationInput {
  factory Input$SplashScreenPaginationInput({
    required int offset,
    int? limit,
    String? status,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$SplashScreenPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (status != null) r'status': status,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$SplashScreenPaginationInput._(this._$data);

  factory Input$SplashScreenPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$SplashScreenPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get status => (_$data['status'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$SplashScreenPaginationInput<Input$SplashScreenPaginationInput>
      get copyWith => CopyWith$Input$SplashScreenPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SplashScreenPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$status = status;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$SplashScreenPaginationInput<TRes> {
  factory CopyWith$Input$SplashScreenPaginationInput(
    Input$SplashScreenPaginationInput instance,
    TRes Function(Input$SplashScreenPaginationInput) then,
  ) = _CopyWithImpl$Input$SplashScreenPaginationInput;

  factory CopyWith$Input$SplashScreenPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SplashScreenPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? status,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$SplashScreenPaginationInput<TRes>
    implements CopyWith$Input$SplashScreenPaginationInput<TRes> {
  _CopyWithImpl$Input$SplashScreenPaginationInput(
    this._instance,
    this._then,
  );

  final Input$SplashScreenPaginationInput _instance;

  final TRes Function(Input$SplashScreenPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? status = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$SplashScreenPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (status != _undefined) 'status': (status as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$SplashScreenPaginationInput<TRes>
    implements CopyWith$Input$SplashScreenPaginationInput<TRes> {
  _CopyWithStubImpl$Input$SplashScreenPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? status,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$UpdateSplashScreenStatusInput {
  factory Input$UpdateSplashScreenStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateSplashScreenStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateSplashScreenStatusInput._(this._$data);

  factory Input$UpdateSplashScreenStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateSplashScreenStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateSplashScreenStatusInput<
          Input$UpdateSplashScreenStatusInput>
      get copyWith => CopyWith$Input$UpdateSplashScreenStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSplashScreenStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateSplashScreenStatusInput<TRes> {
  factory CopyWith$Input$UpdateSplashScreenStatusInput(
    Input$UpdateSplashScreenStatusInput instance,
    TRes Function(Input$UpdateSplashScreenStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateSplashScreenStatusInput;

  factory CopyWith$Input$UpdateSplashScreenStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSplashScreenStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateSplashScreenStatusInput<TRes>
    implements CopyWith$Input$UpdateSplashScreenStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateSplashScreenStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSplashScreenStatusInput _instance;

  final TRes Function(Input$UpdateSplashScreenStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateSplashScreenStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateSplashScreenStatusInput<TRes>
    implements CopyWith$Input$UpdateSplashScreenStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSplashScreenStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$viewSplashScreenInput {
  factory Input$viewSplashScreenInput({required String uuid}) =>
      Input$viewSplashScreenInput._({
        r'uuid': uuid,
      });

  Input$viewSplashScreenInput._(this._$data);

  factory Input$viewSplashScreenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewSplashScreenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewSplashScreenInput<Input$viewSplashScreenInput>
      get copyWith => CopyWith$Input$viewSplashScreenInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewSplashScreenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewSplashScreenInput<TRes> {
  factory CopyWith$Input$viewSplashScreenInput(
    Input$viewSplashScreenInput instance,
    TRes Function(Input$viewSplashScreenInput) then,
  ) = _CopyWithImpl$Input$viewSplashScreenInput;

  factory CopyWith$Input$viewSplashScreenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewSplashScreenInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewSplashScreenInput<TRes>
    implements CopyWith$Input$viewSplashScreenInput<TRes> {
  _CopyWithImpl$Input$viewSplashScreenInput(
    this._instance,
    this._then,
  );

  final Input$viewSplashScreenInput _instance;

  final TRes Function(Input$viewSplashScreenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$viewSplashScreenInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewSplashScreenInput<TRes>
    implements CopyWith$Input$viewSplashScreenInput<TRes> {
  _CopyWithStubImpl$Input$viewSplashScreenInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$SplashscreenUpdateInput {
  factory Input$SplashscreenUpdateInput({
    required String uuid,
    String? image,
    String? name,
    String? title,
    String? file_path,
    String? description,
    String? status,
  }) =>
      Input$SplashscreenUpdateInput._({
        r'uuid': uuid,
        if (image != null) r'image': image,
        if (name != null) r'name': name,
        if (title != null) r'title': title,
        if (file_path != null) r'file_path': file_path,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
      });

  Input$SplashscreenUpdateInput._(this._$data);

  factory Input$SplashscreenUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$SplashscreenUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get image => (_$data['image'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$SplashscreenUpdateInput<Input$SplashscreenUpdateInput>
      get copyWith => CopyWith$Input$SplashscreenUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SplashscreenUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$image = image;
    final l$name = name;
    final l$title = title;
    final l$file_path = file_path;
    final l$description = description;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$SplashscreenUpdateInput<TRes> {
  factory CopyWith$Input$SplashscreenUpdateInput(
    Input$SplashscreenUpdateInput instance,
    TRes Function(Input$SplashscreenUpdateInput) then,
  ) = _CopyWithImpl$Input$SplashscreenUpdateInput;

  factory CopyWith$Input$SplashscreenUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SplashscreenUpdateInput;

  TRes call({
    String? uuid,
    String? image,
    String? name,
    String? title,
    String? file_path,
    String? description,
    String? status,
  });
}

class _CopyWithImpl$Input$SplashscreenUpdateInput<TRes>
    implements CopyWith$Input$SplashscreenUpdateInput<TRes> {
  _CopyWithImpl$Input$SplashscreenUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SplashscreenUpdateInput _instance;

  final TRes Function(Input$SplashscreenUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? image = _undefined,
    Object? name = _undefined,
    Object? title = _undefined,
    Object? file_path = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$SplashscreenUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (image != _undefined) 'image': (image as String?),
        if (name != _undefined) 'name': (name as String?),
        if (title != _undefined) 'title': (title as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$SplashscreenUpdateInput<TRes>
    implements CopyWith$Input$SplashscreenUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SplashscreenUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? image,
    String? name,
    String? title,
    String? file_path,
    String? description,
    String? status,
  }) =>
      _res;
}

class Input$Banner {
  factory Input$Banner({
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? end_date,
    String? start_time,
    String? end_time,
    String? url,
    int? order,
    String? banner_type,
  }) =>
      Input$Banner._({
        if (file_name != null) r'file_name': file_name,
        if (file_type != null) r'file_type': file_type,
        if (file_path != null) r'file_path': file_path,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (start_time != null) r'start_time': start_time,
        if (end_time != null) r'end_time': end_time,
        if (url != null) r'url': url,
        if (order != null) r'order': order,
        if (banner_type != null) r'banner_type': banner_type,
      });

  Input$Banner._(this._$data);

  factory Input$Banner.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('file_name')) {
      final l$file_name = data['file_name'];
      result$data['file_name'] = (l$file_name as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('start_time')) {
      final l$start_time = data['start_time'];
      result$data['start_time'] = (l$start_time as String?);
    }
    if (data.containsKey('end_time')) {
      final l$end_time = data['end_time'];
      result$data['end_time'] = (l$end_time as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('order')) {
      final l$order = data['order'];
      result$data['order'] = (l$order as int?);
    }
    if (data.containsKey('banner_type')) {
      final l$banner_type = data['banner_type'];
      result$data['banner_type'] = (l$banner_type as String?);
    }
    return Input$Banner._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get file_name => (_$data['file_name'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get start_time => (_$data['start_time'] as String?);

  String? get end_time => (_$data['end_time'] as String?);

  String? get url => (_$data['url'] as String?);

  int? get order => (_$data['order'] as int?);

  String? get banner_type => (_$data['banner_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('file_name')) {
      final l$file_name = file_name;
      result$data['file_name'] = l$file_name;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('start_time')) {
      final l$start_time = start_time;
      result$data['start_time'] = l$start_time;
    }
    if (_$data.containsKey('end_time')) {
      final l$end_time = end_time;
      result$data['end_time'] = l$end_time;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('order')) {
      final l$order = order;
      result$data['order'] = l$order;
    }
    if (_$data.containsKey('banner_type')) {
      final l$banner_type = banner_type;
      result$data['banner_type'] = l$banner_type;
    }
    return result$data;
  }

  CopyWith$Input$Banner<Input$Banner> get copyWith => CopyWith$Input$Banner(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$Banner) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$file_name = file_name;
    final lOther$file_name = other.file_name;
    if (_$data.containsKey('file_name') !=
        other._$data.containsKey('file_name')) {
      return false;
    }
    if (l$file_name != lOther$file_name) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$start_time = start_time;
    final lOther$start_time = other.start_time;
    if (_$data.containsKey('start_time') !=
        other._$data.containsKey('start_time')) {
      return false;
    }
    if (l$start_time != lOther$start_time) {
      return false;
    }
    final l$end_time = end_time;
    final lOther$end_time = other.end_time;
    if (_$data.containsKey('end_time') !=
        other._$data.containsKey('end_time')) {
      return false;
    }
    if (l$end_time != lOther$end_time) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$order = order;
    final lOther$order = other.order;
    if (_$data.containsKey('order') != other._$data.containsKey('order')) {
      return false;
    }
    if (l$order != lOther$order) {
      return false;
    }
    final l$banner_type = banner_type;
    final lOther$banner_type = other.banner_type;
    if (_$data.containsKey('banner_type') !=
        other._$data.containsKey('banner_type')) {
      return false;
    }
    if (l$banner_type != lOther$banner_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$file_name = file_name;
    final l$file_type = file_type;
    final l$file_path = file_path;
    final l$title = title;
    final l$description = description;
    final l$status = status;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$start_time = start_time;
    final l$end_time = end_time;
    final l$url = url;
    final l$order = order;
    final l$banner_type = banner_type;
    return Object.hashAll([
      _$data.containsKey('file_name') ? l$file_name : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('start_time') ? l$start_time : const {},
      _$data.containsKey('end_time') ? l$end_time : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('order') ? l$order : const {},
      _$data.containsKey('banner_type') ? l$banner_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$Banner<TRes> {
  factory CopyWith$Input$Banner(
    Input$Banner instance,
    TRes Function(Input$Banner) then,
  ) = _CopyWithImpl$Input$Banner;

  factory CopyWith$Input$Banner.stub(TRes res) = _CopyWithStubImpl$Input$Banner;

  TRes call({
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? end_date,
    String? start_time,
    String? end_time,
    String? url,
    int? order,
    String? banner_type,
  });
}

class _CopyWithImpl$Input$Banner<TRes> implements CopyWith$Input$Banner<TRes> {
  _CopyWithImpl$Input$Banner(
    this._instance,
    this._then,
  );

  final Input$Banner _instance;

  final TRes Function(Input$Banner) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? file_name = _undefined,
    Object? file_type = _undefined,
    Object? file_path = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? start_time = _undefined,
    Object? end_time = _undefined,
    Object? url = _undefined,
    Object? order = _undefined,
    Object? banner_type = _undefined,
  }) =>
      _then(Input$Banner._({
        ..._instance._$data,
        if (file_name != _undefined) 'file_name': (file_name as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (start_time != _undefined) 'start_time': (start_time as String?),
        if (end_time != _undefined) 'end_time': (end_time as String?),
        if (url != _undefined) 'url': (url as String?),
        if (order != _undefined) 'order': (order as int?),
        if (banner_type != _undefined) 'banner_type': (banner_type as String?),
      }));
}

class _CopyWithStubImpl$Input$Banner<TRes>
    implements CopyWith$Input$Banner<TRes> {
  _CopyWithStubImpl$Input$Banner(this._res);

  TRes _res;

  call({
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? end_date,
    String? start_time,
    String? end_time,
    String? url,
    int? order,
    String? banner_type,
  }) =>
      _res;
}

class Input$UpdateBannerStatusInput {
  factory Input$UpdateBannerStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateBannerStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateBannerStatusInput._(this._$data);

  factory Input$UpdateBannerStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateBannerStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateBannerStatusInput<Input$UpdateBannerStatusInput>
      get copyWith => CopyWith$Input$UpdateBannerStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBannerStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateBannerStatusInput<TRes> {
  factory CopyWith$Input$UpdateBannerStatusInput(
    Input$UpdateBannerStatusInput instance,
    TRes Function(Input$UpdateBannerStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateBannerStatusInput;

  factory CopyWith$Input$UpdateBannerStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBannerStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateBannerStatusInput<TRes>
    implements CopyWith$Input$UpdateBannerStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateBannerStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBannerStatusInput _instance;

  final TRes Function(Input$UpdateBannerStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateBannerStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateBannerStatusInput<TRes>
    implements CopyWith$Input$UpdateBannerStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBannerStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$viewBannerInput {
  factory Input$viewBannerInput({required String uuid}) =>
      Input$viewBannerInput._({
        r'uuid': uuid,
      });

  Input$viewBannerInput._(this._$data);

  factory Input$viewBannerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewBannerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewBannerInput<Input$viewBannerInput> get copyWith =>
      CopyWith$Input$viewBannerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewBannerInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewBannerInput<TRes> {
  factory CopyWith$Input$viewBannerInput(
    Input$viewBannerInput instance,
    TRes Function(Input$viewBannerInput) then,
  ) = _CopyWithImpl$Input$viewBannerInput;

  factory CopyWith$Input$viewBannerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewBannerInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewBannerInput<TRes>
    implements CopyWith$Input$viewBannerInput<TRes> {
  _CopyWithImpl$Input$viewBannerInput(
    this._instance,
    this._then,
  );

  final Input$viewBannerInput _instance;

  final TRes Function(Input$viewBannerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewBannerInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewBannerInput<TRes>
    implements CopyWith$Input$viewBannerInput<TRes> {
  _CopyWithStubImpl$Input$viewBannerInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$BannerUpdateInput {
  factory Input$BannerUpdateInput({
    required String uuid,
    String? file_name,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? start_time,
    String? end_time,
    String? end_date,
    String? file_path,
    String? url,
    int? order,
    String? banner_type,
  }) =>
      Input$BannerUpdateInput._({
        r'uuid': uuid,
        if (file_name != null) r'file_name': file_name,
        if (file_type != null) r'file_type': file_type,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
        if (start_date != null) r'start_date': start_date,
        if (start_time != null) r'start_time': start_time,
        if (end_time != null) r'end_time': end_time,
        if (end_date != null) r'end_date': end_date,
        if (file_path != null) r'file_path': file_path,
        if (url != null) r'url': url,
        if (order != null) r'order': order,
        if (banner_type != null) r'banner_type': banner_type,
      });

  Input$BannerUpdateInput._(this._$data);

  factory Input$BannerUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('file_name')) {
      final l$file_name = data['file_name'];
      result$data['file_name'] = (l$file_name as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('start_time')) {
      final l$start_time = data['start_time'];
      result$data['start_time'] = (l$start_time as String?);
    }
    if (data.containsKey('end_time')) {
      final l$end_time = data['end_time'];
      result$data['end_time'] = (l$end_time as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('order')) {
      final l$order = data['order'];
      result$data['order'] = (l$order as int?);
    }
    if (data.containsKey('banner_type')) {
      final l$banner_type = data['banner_type'];
      result$data['banner_type'] = (l$banner_type as String?);
    }
    return Input$BannerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get file_name => (_$data['file_name'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get start_time => (_$data['start_time'] as String?);

  String? get end_time => (_$data['end_time'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get url => (_$data['url'] as String?);

  int? get order => (_$data['order'] as int?);

  String? get banner_type => (_$data['banner_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('file_name')) {
      final l$file_name = file_name;
      result$data['file_name'] = l$file_name;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('start_time')) {
      final l$start_time = start_time;
      result$data['start_time'] = l$start_time;
    }
    if (_$data.containsKey('end_time')) {
      final l$end_time = end_time;
      result$data['end_time'] = l$end_time;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('order')) {
      final l$order = order;
      result$data['order'] = l$order;
    }
    if (_$data.containsKey('banner_type')) {
      final l$banner_type = banner_type;
      result$data['banner_type'] = l$banner_type;
    }
    return result$data;
  }

  CopyWith$Input$BannerUpdateInput<Input$BannerUpdateInput> get copyWith =>
      CopyWith$Input$BannerUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BannerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$file_name = file_name;
    final lOther$file_name = other.file_name;
    if (_$data.containsKey('file_name') !=
        other._$data.containsKey('file_name')) {
      return false;
    }
    if (l$file_name != lOther$file_name) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$start_time = start_time;
    final lOther$start_time = other.start_time;
    if (_$data.containsKey('start_time') !=
        other._$data.containsKey('start_time')) {
      return false;
    }
    if (l$start_time != lOther$start_time) {
      return false;
    }
    final l$end_time = end_time;
    final lOther$end_time = other.end_time;
    if (_$data.containsKey('end_time') !=
        other._$data.containsKey('end_time')) {
      return false;
    }
    if (l$end_time != lOther$end_time) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$order = order;
    final lOther$order = other.order;
    if (_$data.containsKey('order') != other._$data.containsKey('order')) {
      return false;
    }
    if (l$order != lOther$order) {
      return false;
    }
    final l$banner_type = banner_type;
    final lOther$banner_type = other.banner_type;
    if (_$data.containsKey('banner_type') !=
        other._$data.containsKey('banner_type')) {
      return false;
    }
    if (l$banner_type != lOther$banner_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$file_name = file_name;
    final l$file_type = file_type;
    final l$title = title;
    final l$description = description;
    final l$status = status;
    final l$start_date = start_date;
    final l$start_time = start_time;
    final l$end_time = end_time;
    final l$end_date = end_date;
    final l$file_path = file_path;
    final l$url = url;
    final l$order = order;
    final l$banner_type = banner_type;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('file_name') ? l$file_name : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('start_time') ? l$start_time : const {},
      _$data.containsKey('end_time') ? l$end_time : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('order') ? l$order : const {},
      _$data.containsKey('banner_type') ? l$banner_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$BannerUpdateInput<TRes> {
  factory CopyWith$Input$BannerUpdateInput(
    Input$BannerUpdateInput instance,
    TRes Function(Input$BannerUpdateInput) then,
  ) = _CopyWithImpl$Input$BannerUpdateInput;

  factory CopyWith$Input$BannerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BannerUpdateInput;

  TRes call({
    String? uuid,
    String? file_name,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? start_time,
    String? end_time,
    String? end_date,
    String? file_path,
    String? url,
    int? order,
    String? banner_type,
  });
}

class _CopyWithImpl$Input$BannerUpdateInput<TRes>
    implements CopyWith$Input$BannerUpdateInput<TRes> {
  _CopyWithImpl$Input$BannerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$BannerUpdateInput _instance;

  final TRes Function(Input$BannerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? file_name = _undefined,
    Object? file_type = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? start_date = _undefined,
    Object? start_time = _undefined,
    Object? end_time = _undefined,
    Object? end_date = _undefined,
    Object? file_path = _undefined,
    Object? url = _undefined,
    Object? order = _undefined,
    Object? banner_type = _undefined,
  }) =>
      _then(Input$BannerUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (file_name != _undefined) 'file_name': (file_name as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (start_time != _undefined) 'start_time': (start_time as String?),
        if (end_time != _undefined) 'end_time': (end_time as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (url != _undefined) 'url': (url as String?),
        if (order != _undefined) 'order': (order as int?),
        if (banner_type != _undefined) 'banner_type': (banner_type as String?),
      }));
}

class _CopyWithStubImpl$Input$BannerUpdateInput<TRes>
    implements CopyWith$Input$BannerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$BannerUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? file_name,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? start_date,
    String? start_time,
    String? end_time,
    String? end_date,
    String? file_path,
    String? url,
    int? order,
    String? banner_type,
  }) =>
      _res;
}

class Input$BannerPaginationInput {
  factory Input$BannerPaginationInput({
    required int offset,
    required int limit,
    String? banner_title,
    String? file_type,
    String? file_path,
    String? file_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? banner_type,
  }) =>
      Input$BannerPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        if (banner_title != null) r'banner_title': banner_title,
        if (file_type != null) r'file_type': file_type,
        if (file_path != null) r'file_path': file_path,
        if (file_name != null) r'file_name': file_name,
        if (status != null) r'status': status,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (banner_type != null) r'banner_type': banner_type,
      });

  Input$BannerPaginationInput._(this._$data);

  factory Input$BannerPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    if (data.containsKey('banner_title')) {
      final l$banner_title = data['banner_title'];
      result$data['banner_title'] = (l$banner_title as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('file_name')) {
      final l$file_name = data['file_name'];
      result$data['file_name'] = (l$file_name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('banner_type')) {
      final l$banner_type = data['banner_type'];
      result$data['banner_type'] = (l$banner_type as String?);
    }
    return Input$BannerPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String? get banner_title => (_$data['banner_title'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get file_name => (_$data['file_name'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get banner_type => (_$data['banner_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    if (_$data.containsKey('banner_title')) {
      final l$banner_title = banner_title;
      result$data['banner_title'] = l$banner_title;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('file_name')) {
      final l$file_name = file_name;
      result$data['file_name'] = l$file_name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('banner_type')) {
      final l$banner_type = banner_type;
      result$data['banner_type'] = l$banner_type;
    }
    return result$data;
  }

  CopyWith$Input$BannerPaginationInput<Input$BannerPaginationInput>
      get copyWith => CopyWith$Input$BannerPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BannerPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$banner_title = banner_title;
    final lOther$banner_title = other.banner_title;
    if (_$data.containsKey('banner_title') !=
        other._$data.containsKey('banner_title')) {
      return false;
    }
    if (l$banner_title != lOther$banner_title) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$file_name = file_name;
    final lOther$file_name = other.file_name;
    if (_$data.containsKey('file_name') !=
        other._$data.containsKey('file_name')) {
      return false;
    }
    if (l$file_name != lOther$file_name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$banner_type = banner_type;
    final lOther$banner_type = other.banner_type;
    if (_$data.containsKey('banner_type') !=
        other._$data.containsKey('banner_type')) {
      return false;
    }
    if (l$banner_type != lOther$banner_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$banner_title = banner_title;
    final l$file_type = file_type;
    final l$file_path = file_path;
    final l$file_name = file_name;
    final l$status = status;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$banner_type = banner_type;
    return Object.hashAll([
      l$offset,
      l$limit,
      _$data.containsKey('banner_title') ? l$banner_title : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('file_name') ? l$file_name : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('banner_type') ? l$banner_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$BannerPaginationInput<TRes> {
  factory CopyWith$Input$BannerPaginationInput(
    Input$BannerPaginationInput instance,
    TRes Function(Input$BannerPaginationInput) then,
  ) = _CopyWithImpl$Input$BannerPaginationInput;

  factory CopyWith$Input$BannerPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BannerPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? banner_title,
    String? file_type,
    String? file_path,
    String? file_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? banner_type,
  });
}

class _CopyWithImpl$Input$BannerPaginationInput<TRes>
    implements CopyWith$Input$BannerPaginationInput<TRes> {
  _CopyWithImpl$Input$BannerPaginationInput(
    this._instance,
    this._then,
  );

  final Input$BannerPaginationInput _instance;

  final TRes Function(Input$BannerPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? banner_title = _undefined,
    Object? file_type = _undefined,
    Object? file_path = _undefined,
    Object? file_name = _undefined,
    Object? status = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? banner_type = _undefined,
  }) =>
      _then(Input$BannerPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (banner_title != _undefined)
          'banner_title': (banner_title as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (file_name != _undefined) 'file_name': (file_name as String?),
        if (status != _undefined) 'status': (status as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (banner_type != _undefined) 'banner_type': (banner_type as String?),
      }));
}

class _CopyWithStubImpl$Input$BannerPaginationInput<TRes>
    implements CopyWith$Input$BannerPaginationInput<TRes> {
  _CopyWithStubImpl$Input$BannerPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? banner_title,
    String? file_type,
    String? file_path,
    String? file_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? banner_type,
  }) =>
      _res;
}

class Input$DeleteBannerInput {
  factory Input$DeleteBannerInput({required String uuid}) =>
      Input$DeleteBannerInput._({
        r'uuid': uuid,
      });

  Input$DeleteBannerInput._(this._$data);

  factory Input$DeleteBannerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteBannerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteBannerInput<Input$DeleteBannerInput> get copyWith =>
      CopyWith$Input$DeleteBannerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteBannerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteBannerInput<TRes> {
  factory CopyWith$Input$DeleteBannerInput(
    Input$DeleteBannerInput instance,
    TRes Function(Input$DeleteBannerInput) then,
  ) = _CopyWithImpl$Input$DeleteBannerInput;

  factory CopyWith$Input$DeleteBannerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteBannerInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteBannerInput<TRes>
    implements CopyWith$Input$DeleteBannerInput<TRes> {
  _CopyWithImpl$Input$DeleteBannerInput(
    this._instance,
    this._then,
  );

  final Input$DeleteBannerInput _instance;

  final TRes Function(Input$DeleteBannerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteBannerInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteBannerInput<TRes>
    implements CopyWith$Input$DeleteBannerInput<TRes> {
  _CopyWithStubImpl$Input$DeleteBannerInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$GroupDetailsInput {
  factory Input$GroupDetailsInput({
    required String name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  }) =>
      Input$GroupDetailsInput._({
        r'name': name,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (club != null) r'club': club,
        if (type != null) r'type': type,
        if (rating_id != null) r'rating_id': rating_id,
        if (status != null) r'status': status,
        if (description != null) r'description': description,
        if (member_count != null) r'member_count': member_count,
        if (is_private != null) r'is_private': is_private,
      });

  Input$GroupDetailsInput._(this._$data);

  factory Input$GroupDetailsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          (l$type as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('rating_id')) {
      final l$rating_id = data['rating_id'];
      result$data['rating_id'] = (l$rating_id as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('member_count')) {
      final l$member_count = data['member_count'];
      result$data['member_count'] = (l$member_count as int?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    return Input$GroupDetailsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  List<String?>? get type => (_$data['type'] as List<String?>?);

  String? get rating_id => (_$data['rating_id'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get description => (_$data['description'] as String?);

  int? get member_count => (_$data['member_count'] as int?);

  int? get is_private => (_$data['is_private'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.map((e) => e).toList();
    }
    if (_$data.containsKey('rating_id')) {
      final l$rating_id = rating_id;
      result$data['rating_id'] = l$rating_id;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('member_count')) {
      final l$member_count = member_count;
      result$data['member_count'] = l$member_count;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    return result$data;
  }

  CopyWith$Input$GroupDetailsInput<Input$GroupDetailsInput> get copyWith =>
      CopyWith$Input$GroupDetailsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupDetailsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != null && lOther$type != null) {
      if (l$type.length != lOther$type.length) {
        return false;
      }
      for (int i = 0; i < l$type.length; i++) {
        final l$type$entry = l$type[i];
        final lOther$type$entry = lOther$type[i];
        if (l$type$entry != lOther$type$entry) {
          return false;
        }
      }
    } else if (l$type != lOther$type) {
      return false;
    }
    final l$rating_id = rating_id;
    final lOther$rating_id = other.rating_id;
    if (_$data.containsKey('rating_id') !=
        other._$data.containsKey('rating_id')) {
      return false;
    }
    if (l$rating_id != lOther$rating_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$member_count = member_count;
    final lOther$member_count = other.member_count;
    if (_$data.containsKey('member_count') !=
        other._$data.containsKey('member_count')) {
      return false;
    }
    if (l$member_count != lOther$member_count) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$image = image;
    final l$file_path = file_path;
    final l$club = club;
    final l$type = type;
    final l$rating_id = rating_id;
    final l$status = status;
    final l$description = description;
    final l$member_count = member_count;
    final l$is_private = is_private;
    return Object.hashAll([
      l$name,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('type')
          ? l$type == null
              ? null
              : Object.hashAll(l$type.map((v) => v))
          : const {},
      _$data.containsKey('rating_id') ? l$rating_id : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('member_count') ? l$member_count : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupDetailsInput<TRes> {
  factory CopyWith$Input$GroupDetailsInput(
    Input$GroupDetailsInput instance,
    TRes Function(Input$GroupDetailsInput) then,
  ) = _CopyWithImpl$Input$GroupDetailsInput;

  factory CopyWith$Input$GroupDetailsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupDetailsInput;

  TRes call({
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  });
}

class _CopyWithImpl$Input$GroupDetailsInput<TRes>
    implements CopyWith$Input$GroupDetailsInput<TRes> {
  _CopyWithImpl$Input$GroupDetailsInput(
    this._instance,
    this._then,
  );

  final Input$GroupDetailsInput _instance;

  final TRes Function(Input$GroupDetailsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? club = _undefined,
    Object? type = _undefined,
    Object? rating_id = _undefined,
    Object? status = _undefined,
    Object? description = _undefined,
    Object? member_count = _undefined,
    Object? is_private = _undefined,
  }) =>
      _then(Input$GroupDetailsInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (type != _undefined) 'type': (type as List<String?>?),
        if (rating_id != _undefined) 'rating_id': (rating_id as String?),
        if (status != _undefined) 'status': (status as String?),
        if (description != _undefined) 'description': (description as String?),
        if (member_count != _undefined) 'member_count': (member_count as int?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
      }));
}

class _CopyWithStubImpl$Input$GroupDetailsInput<TRes>
    implements CopyWith$Input$GroupDetailsInput<TRes> {
  _CopyWithStubImpl$Input$GroupDetailsInput(this._res);

  TRes _res;

  call({
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  }) =>
      _res;
}

class Input$UpdateGroupStatusInput {
  factory Input$UpdateGroupStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateGroupStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateGroupStatusInput._(this._$data);

  factory Input$UpdateGroupStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateGroupStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateGroupStatusInput<Input$UpdateGroupStatusInput>
      get copyWith => CopyWith$Input$UpdateGroupStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateGroupStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateGroupStatusInput<TRes> {
  factory CopyWith$Input$UpdateGroupStatusInput(
    Input$UpdateGroupStatusInput instance,
    TRes Function(Input$UpdateGroupStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateGroupStatusInput;

  factory CopyWith$Input$UpdateGroupStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateGroupStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateGroupStatusInput<TRes>
    implements CopyWith$Input$UpdateGroupStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateGroupStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateGroupStatusInput _instance;

  final TRes Function(Input$UpdateGroupStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateGroupStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateGroupStatusInput<TRes>
    implements CopyWith$Input$UpdateGroupStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateGroupStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$GroupDataPaginationInput {
  factory Input$GroupDataPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? owner_name,
    String? group_type,
    String? club_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? is_private,
  }) =>
      Input$GroupDataPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (owner_name != null) r'owner_name': owner_name,
        if (group_type != null) r'group_type': group_type,
        if (club_name != null) r'club_name': club_name,
        if (status != null) r'status': status,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_private != null) r'is_private': is_private,
      });

  Input$GroupDataPaginationInput._(this._$data);

  factory Input$GroupDataPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('owner_name')) {
      final l$owner_name = data['owner_name'];
      result$data['owner_name'] = (l$owner_name as String?);
    }
    if (data.containsKey('group_type')) {
      final l$group_type = data['group_type'];
      result$data['group_type'] = (l$group_type as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as String?);
    }
    return Input$GroupDataPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get owner_name => (_$data['owner_name'] as String?);

  String? get group_type => (_$data['group_type'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get is_private => (_$data['is_private'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('owner_name')) {
      final l$owner_name = owner_name;
      result$data['owner_name'] = l$owner_name;
    }
    if (_$data.containsKey('group_type')) {
      final l$group_type = group_type;
      result$data['group_type'] = l$group_type;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    return result$data;
  }

  CopyWith$Input$GroupDataPaginationInput<Input$GroupDataPaginationInput>
      get copyWith => CopyWith$Input$GroupDataPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupDataPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$owner_name = owner_name;
    final lOther$owner_name = other.owner_name;
    if (_$data.containsKey('owner_name') !=
        other._$data.containsKey('owner_name')) {
      return false;
    }
    if (l$owner_name != lOther$owner_name) {
      return false;
    }
    final l$group_type = group_type;
    final lOther$group_type = other.group_type;
    if (_$data.containsKey('group_type') !=
        other._$data.containsKey('group_type')) {
      return false;
    }
    if (l$group_type != lOther$group_type) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$owner_name = owner_name;
    final l$group_type = group_type;
    final l$club_name = club_name;
    final l$status = status;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_private = is_private;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('owner_name') ? l$owner_name : const {},
      _$data.containsKey('group_type') ? l$group_type : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupDataPaginationInput<TRes> {
  factory CopyWith$Input$GroupDataPaginationInput(
    Input$GroupDataPaginationInput instance,
    TRes Function(Input$GroupDataPaginationInput) then,
  ) = _CopyWithImpl$Input$GroupDataPaginationInput;

  factory CopyWith$Input$GroupDataPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupDataPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? owner_name,
    String? group_type,
    String? club_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? is_private,
  });
}

class _CopyWithImpl$Input$GroupDataPaginationInput<TRes>
    implements CopyWith$Input$GroupDataPaginationInput<TRes> {
  _CopyWithImpl$Input$GroupDataPaginationInput(
    this._instance,
    this._then,
  );

  final Input$GroupDataPaginationInput _instance;

  final TRes Function(Input$GroupDataPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? owner_name = _undefined,
    Object? group_type = _undefined,
    Object? club_name = _undefined,
    Object? status = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_private = _undefined,
  }) =>
      _then(Input$GroupDataPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (owner_name != _undefined) 'owner_name': (owner_name as String?),
        if (group_type != _undefined) 'group_type': (group_type as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (status != _undefined) 'status': (status as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_private != _undefined) 'is_private': (is_private as String?),
      }));
}

class _CopyWithStubImpl$Input$GroupDataPaginationInput<TRes>
    implements CopyWith$Input$GroupDataPaginationInput<TRes> {
  _CopyWithStubImpl$Input$GroupDataPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? owner_name,
    String? group_type,
    String? club_name,
    String? status,
    String? sort_column,
    String? sort_order,
    String? is_private,
  }) =>
      _res;
}

class Input$viewGroupDetailInput {
  factory Input$viewGroupDetailInput({required String uuid}) =>
      Input$viewGroupDetailInput._({
        r'uuid': uuid,
      });

  Input$viewGroupDetailInput._(this._$data);

  factory Input$viewGroupDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewGroupDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewGroupDetailInput<Input$viewGroupDetailInput>
      get copyWith => CopyWith$Input$viewGroupDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewGroupDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewGroupDetailInput<TRes> {
  factory CopyWith$Input$viewGroupDetailInput(
    Input$viewGroupDetailInput instance,
    TRes Function(Input$viewGroupDetailInput) then,
  ) = _CopyWithImpl$Input$viewGroupDetailInput;

  factory CopyWith$Input$viewGroupDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewGroupDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewGroupDetailInput<TRes>
    implements CopyWith$Input$viewGroupDetailInput<TRes> {
  _CopyWithImpl$Input$viewGroupDetailInput(
    this._instance,
    this._then,
  );

  final Input$viewGroupDetailInput _instance;

  final TRes Function(Input$viewGroupDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewGroupDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewGroupDetailInput<TRes>
    implements CopyWith$Input$viewGroupDetailInput<TRes> {
  _CopyWithStubImpl$Input$viewGroupDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$BannerGroupInput {
  factory Input$BannerGroupInput({
    required String uuid,
    required String name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  }) =>
      Input$BannerGroupInput._({
        r'uuid': uuid,
        r'name': name,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (club != null) r'club': club,
        if (type != null) r'type': type,
        if (rating_id != null) r'rating_id': rating_id,
        if (status != null) r'status': status,
        if (description != null) r'description': description,
        if (member_count != null) r'member_count': member_count,
        if (is_private != null) r'is_private': is_private,
      });

  Input$BannerGroupInput._(this._$data);

  factory Input$BannerGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          (l$type as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('rating_id')) {
      final l$rating_id = data['rating_id'];
      result$data['rating_id'] = (l$rating_id as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('member_count')) {
      final l$member_count = data['member_count'];
      result$data['member_count'] = (l$member_count as int?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    return Input$BannerGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get name => (_$data['name'] as String);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  List<String?>? get type => (_$data['type'] as List<String?>?);

  String? get rating_id => (_$data['rating_id'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get description => (_$data['description'] as String?);

  int? get member_count => (_$data['member_count'] as int?);

  int? get is_private => (_$data['is_private'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.map((e) => e).toList();
    }
    if (_$data.containsKey('rating_id')) {
      final l$rating_id = rating_id;
      result$data['rating_id'] = l$rating_id;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('member_count')) {
      final l$member_count = member_count;
      result$data['member_count'] = l$member_count;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    return result$data;
  }

  CopyWith$Input$BannerGroupInput<Input$BannerGroupInput> get copyWith =>
      CopyWith$Input$BannerGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BannerGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != null && lOther$type != null) {
      if (l$type.length != lOther$type.length) {
        return false;
      }
      for (int i = 0; i < l$type.length; i++) {
        final l$type$entry = l$type[i];
        final lOther$type$entry = lOther$type[i];
        if (l$type$entry != lOther$type$entry) {
          return false;
        }
      }
    } else if (l$type != lOther$type) {
      return false;
    }
    final l$rating_id = rating_id;
    final lOther$rating_id = other.rating_id;
    if (_$data.containsKey('rating_id') !=
        other._$data.containsKey('rating_id')) {
      return false;
    }
    if (l$rating_id != lOther$rating_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$member_count = member_count;
    final lOther$member_count = other.member_count;
    if (_$data.containsKey('member_count') !=
        other._$data.containsKey('member_count')) {
      return false;
    }
    if (l$member_count != lOther$member_count) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$image = image;
    final l$file_path = file_path;
    final l$club = club;
    final l$type = type;
    final l$rating_id = rating_id;
    final l$status = status;
    final l$description = description;
    final l$member_count = member_count;
    final l$is_private = is_private;
    return Object.hashAll([
      l$uuid,
      l$name,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('type')
          ? l$type == null
              ? null
              : Object.hashAll(l$type.map((v) => v))
          : const {},
      _$data.containsKey('rating_id') ? l$rating_id : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('member_count') ? l$member_count : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
    ]);
  }
}

abstract class CopyWith$Input$BannerGroupInput<TRes> {
  factory CopyWith$Input$BannerGroupInput(
    Input$BannerGroupInput instance,
    TRes Function(Input$BannerGroupInput) then,
  ) = _CopyWithImpl$Input$BannerGroupInput;

  factory CopyWith$Input$BannerGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BannerGroupInput;

  TRes call({
    String? uuid,
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  });
}

class _CopyWithImpl$Input$BannerGroupInput<TRes>
    implements CopyWith$Input$BannerGroupInput<TRes> {
  _CopyWithImpl$Input$BannerGroupInput(
    this._instance,
    this._then,
  );

  final Input$BannerGroupInput _instance;

  final TRes Function(Input$BannerGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? club = _undefined,
    Object? type = _undefined,
    Object? rating_id = _undefined,
    Object? status = _undefined,
    Object? description = _undefined,
    Object? member_count = _undefined,
    Object? is_private = _undefined,
  }) =>
      _then(Input$BannerGroupInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (type != _undefined) 'type': (type as List<String?>?),
        if (rating_id != _undefined) 'rating_id': (rating_id as String?),
        if (status != _undefined) 'status': (status as String?),
        if (description != _undefined) 'description': (description as String?),
        if (member_count != _undefined) 'member_count': (member_count as int?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
      }));
}

class _CopyWithStubImpl$Input$BannerGroupInput<TRes>
    implements CopyWith$Input$BannerGroupInput<TRes> {
  _CopyWithStubImpl$Input$BannerGroupInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? status,
    String? description,
    int? member_count,
    int? is_private,
  }) =>
      _res;
}

class Input$DeleteGroupInput {
  factory Input$DeleteGroupInput({required String uuid}) =>
      Input$DeleteGroupInput._({
        r'uuid': uuid,
      });

  Input$DeleteGroupInput._(this._$data);

  factory Input$DeleteGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteGroupInput<Input$DeleteGroupInput> get copyWith =>
      CopyWith$Input$DeleteGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteGroupInput<TRes> {
  factory CopyWith$Input$DeleteGroupInput(
    Input$DeleteGroupInput instance,
    TRes Function(Input$DeleteGroupInput) then,
  ) = _CopyWithImpl$Input$DeleteGroupInput;

  factory CopyWith$Input$DeleteGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteGroupInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteGroupInput<TRes>
    implements CopyWith$Input$DeleteGroupInput<TRes> {
  _CopyWithImpl$Input$DeleteGroupInput(
    this._instance,
    this._then,
  );

  final Input$DeleteGroupInput _instance;

  final TRes Function(Input$DeleteGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteGroupInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteGroupInput<TRes>
    implements CopyWith$Input$DeleteGroupInput<TRes> {
  _CopyWithStubImpl$Input$DeleteGroupInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AddGroupMemberInput {
  factory Input$AddGroupMemberInput({
    required String group_uuid,
    required List<String?> user,
  }) =>
      Input$AddGroupMemberInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$AddGroupMemberInput._(this._$data);

  factory Input$AddGroupMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] = (l$group_uuid as String);
    final l$user = data['user'];
    result$data['user'] =
        (l$user as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$AddGroupMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_uuid => (_$data['group_uuid'] as String);

  List<String?> get user => (_$data['user'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid;
    final l$user = user;
    result$data['user'] = l$user.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$AddGroupMemberInput<Input$AddGroupMemberInput> get copyWith =>
      CopyWith$Input$AddGroupMemberInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddGroupMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid != lOther$group_uuid) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user.length != lOther$user.length) {
      return false;
    }
    for (int i = 0; i < l$user.length; i++) {
      final l$user$entry = l$user[i];
      final lOther$user$entry = lOther$user[i];
      if (l$user$entry != lOther$user$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      l$group_uuid,
      Object.hashAll(l$user.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$AddGroupMemberInput<TRes> {
  factory CopyWith$Input$AddGroupMemberInput(
    Input$AddGroupMemberInput instance,
    TRes Function(Input$AddGroupMemberInput) then,
  ) = _CopyWithImpl$Input$AddGroupMemberInput;

  factory CopyWith$Input$AddGroupMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddGroupMemberInput;

  TRes call({
    String? group_uuid,
    List<String?>? user,
  });
}

class _CopyWithImpl$Input$AddGroupMemberInput<TRes>
    implements CopyWith$Input$AddGroupMemberInput<TRes> {
  _CopyWithImpl$Input$AddGroupMemberInput(
    this._instance,
    this._then,
  );

  final Input$AddGroupMemberInput _instance;

  final TRes Function(Input$AddGroupMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$AddGroupMemberInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as String),
        if (user != _undefined && user != null) 'user': (user as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$AddGroupMemberInput<TRes>
    implements CopyWith$Input$AddGroupMemberInput<TRes> {
  _CopyWithStubImpl$Input$AddGroupMemberInput(this._res);

  TRes _res;

  call({
    String? group_uuid,
    List<String?>? user,
  }) =>
      _res;
}

class Input$viewGroupMemberInput {
  factory Input$viewGroupMemberInput({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$viewGroupMemberInput._({
        if (uuid != null) r'uuid': uuid,
        if (full_name != null) r'full_name': full_name,
        if (rating != null) r'rating': rating,
        if (gender != null) r'gender': gender,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (recommendation != null) r'recommendation': recommendation,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$viewGroupMemberInput._(this._$data);

  factory Input$viewGroupMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$viewGroupMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get gender => (_$data['gender'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  String? get recommendation => (_$data['recommendation'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$viewGroupMemberInput<Input$viewGroupMemberInput>
      get copyWith => CopyWith$Input$viewGroupMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewGroupMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$full_name = full_name;
    final l$rating = rating;
    final l$gender = gender;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$recommendation = recommendation;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$viewGroupMemberInput<TRes> {
  factory CopyWith$Input$viewGroupMemberInput(
    Input$viewGroupMemberInput instance,
    TRes Function(Input$viewGroupMemberInput) then,
  ) = _CopyWithImpl$Input$viewGroupMemberInput;

  factory CopyWith$Input$viewGroupMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewGroupMemberInput;

  TRes call({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$viewGroupMemberInput<TRes>
    implements CopyWith$Input$viewGroupMemberInput<TRes> {
  _CopyWithImpl$Input$viewGroupMemberInput(
    this._instance,
    this._then,
  );

  final Input$viewGroupMemberInput _instance;

  final TRes Function(Input$viewGroupMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? full_name = _undefined,
    Object? rating = _undefined,
    Object? gender = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? recommendation = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$viewGroupMemberInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$viewGroupMemberInput<TRes>
    implements CopyWith$Input$viewGroupMemberInput<TRes> {
  _CopyWithStubImpl$Input$viewGroupMemberInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$RemoveGroupUserInput {
  factory Input$RemoveGroupUserInput({
    required String group_uuid,
    required List<String?> user,
  }) =>
      Input$RemoveGroupUserInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$RemoveGroupUserInput._(this._$data);

  factory Input$RemoveGroupUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] = (l$group_uuid as String);
    final l$user = data['user'];
    result$data['user'] =
        (l$user as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$RemoveGroupUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_uuid => (_$data['group_uuid'] as String);

  List<String?> get user => (_$data['user'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid;
    final l$user = user;
    result$data['user'] = l$user.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RemoveGroupUserInput<Input$RemoveGroupUserInput>
      get copyWith => CopyWith$Input$RemoveGroupUserInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveGroupUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid != lOther$group_uuid) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user.length != lOther$user.length) {
      return false;
    }
    for (int i = 0; i < l$user.length; i++) {
      final l$user$entry = l$user[i];
      final lOther$user$entry = lOther$user[i];
      if (l$user$entry != lOther$user$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      l$group_uuid,
      Object.hashAll(l$user.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RemoveGroupUserInput<TRes> {
  factory CopyWith$Input$RemoveGroupUserInput(
    Input$RemoveGroupUserInput instance,
    TRes Function(Input$RemoveGroupUserInput) then,
  ) = _CopyWithImpl$Input$RemoveGroupUserInput;

  factory CopyWith$Input$RemoveGroupUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveGroupUserInput;

  TRes call({
    String? group_uuid,
    List<String?>? user,
  });
}

class _CopyWithImpl$Input$RemoveGroupUserInput<TRes>
    implements CopyWith$Input$RemoveGroupUserInput<TRes> {
  _CopyWithImpl$Input$RemoveGroupUserInput(
    this._instance,
    this._then,
  );

  final Input$RemoveGroupUserInput _instance;

  final TRes Function(Input$RemoveGroupUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$RemoveGroupUserInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as String),
        if (user != _undefined && user != null) 'user': (user as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$RemoveGroupUserInput<TRes>
    implements CopyWith$Input$RemoveGroupUserInput<TRes> {
  _CopyWithStubImpl$Input$RemoveGroupUserInput(this._res);

  TRes _res;

  call({
    String? group_uuid,
    List<String?>? user,
  }) =>
      _res;
}

class Input$UserRatingPaginationInput {
  factory Input$UserRatingPaginationInput({
    required int offset,
    required int limit,
    String? player_name,
    List<String?>? given_by,
    String? sort_column,
    String? sort_order,
    String? rating_type,
  }) =>
      Input$UserRatingPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        if (player_name != null) r'player_name': player_name,
        if (given_by != null) r'given_by': given_by,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (rating_type != null) r'rating_type': rating_type,
      });

  Input$UserRatingPaginationInput._(this._$data);

  factory Input$UserRatingPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    if (data.containsKey('player_name')) {
      final l$player_name = data['player_name'];
      result$data['player_name'] = (l$player_name as String?);
    }
    if (data.containsKey('given_by')) {
      final l$given_by = data['given_by'];
      result$data['given_by'] =
          (l$given_by as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('rating_type')) {
      final l$rating_type = data['rating_type'];
      result$data['rating_type'] = (l$rating_type as String?);
    }
    return Input$UserRatingPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String? get player_name => (_$data['player_name'] as String?);

  List<String?>? get given_by => (_$data['given_by'] as List<String?>?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get rating_type => (_$data['rating_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    if (_$data.containsKey('player_name')) {
      final l$player_name = player_name;
      result$data['player_name'] = l$player_name;
    }
    if (_$data.containsKey('given_by')) {
      final l$given_by = given_by;
      result$data['given_by'] = l$given_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('rating_type')) {
      final l$rating_type = rating_type;
      result$data['rating_type'] = l$rating_type;
    }
    return result$data;
  }

  CopyWith$Input$UserRatingPaginationInput<Input$UserRatingPaginationInput>
      get copyWith => CopyWith$Input$UserRatingPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRatingPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$player_name = player_name;
    final lOther$player_name = other.player_name;
    if (_$data.containsKey('player_name') !=
        other._$data.containsKey('player_name')) {
      return false;
    }
    if (l$player_name != lOther$player_name) {
      return false;
    }
    final l$given_by = given_by;
    final lOther$given_by = other.given_by;
    if (_$data.containsKey('given_by') !=
        other._$data.containsKey('given_by')) {
      return false;
    }
    if (l$given_by != null && lOther$given_by != null) {
      if (l$given_by.length != lOther$given_by.length) {
        return false;
      }
      for (int i = 0; i < l$given_by.length; i++) {
        final l$given_by$entry = l$given_by[i];
        final lOther$given_by$entry = lOther$given_by[i];
        if (l$given_by$entry != lOther$given_by$entry) {
          return false;
        }
      }
    } else if (l$given_by != lOther$given_by) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$rating_type = rating_type;
    final lOther$rating_type = other.rating_type;
    if (_$data.containsKey('rating_type') !=
        other._$data.containsKey('rating_type')) {
      return false;
    }
    if (l$rating_type != lOther$rating_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$player_name = player_name;
    final l$given_by = given_by;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$rating_type = rating_type;
    return Object.hashAll([
      l$offset,
      l$limit,
      _$data.containsKey('player_name') ? l$player_name : const {},
      _$data.containsKey('given_by')
          ? l$given_by == null
              ? null
              : Object.hashAll(l$given_by.map((v) => v))
          : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('rating_type') ? l$rating_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRatingPaginationInput<TRes> {
  factory CopyWith$Input$UserRatingPaginationInput(
    Input$UserRatingPaginationInput instance,
    TRes Function(Input$UserRatingPaginationInput) then,
  ) = _CopyWithImpl$Input$UserRatingPaginationInput;

  factory CopyWith$Input$UserRatingPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRatingPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? player_name,
    List<String?>? given_by,
    String? sort_column,
    String? sort_order,
    String? rating_type,
  });
}

class _CopyWithImpl$Input$UserRatingPaginationInput<TRes>
    implements CopyWith$Input$UserRatingPaginationInput<TRes> {
  _CopyWithImpl$Input$UserRatingPaginationInput(
    this._instance,
    this._then,
  );

  final Input$UserRatingPaginationInput _instance;

  final TRes Function(Input$UserRatingPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? player_name = _undefined,
    Object? given_by = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? rating_type = _undefined,
  }) =>
      _then(Input$UserRatingPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (player_name != _undefined) 'player_name': (player_name as String?),
        if (given_by != _undefined) 'given_by': (given_by as List<String?>?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (rating_type != _undefined) 'rating_type': (rating_type as String?),
      }));
}

class _CopyWithStubImpl$Input$UserRatingPaginationInput<TRes>
    implements CopyWith$Input$UserRatingPaginationInput<TRes> {
  _CopyWithStubImpl$Input$UserRatingPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? player_name,
    List<String?>? given_by,
    String? sort_column,
    String? sort_order,
    String? rating_type,
  }) =>
      _res;
}

class Input$UserListPaginationInput {
  factory Input$UserListPaginationInput({
    required int offset,
    required int limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$UserListPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$UserListPaginationInput._(this._$data);

  factory Input$UserListPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$UserListPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$UserListPaginationInput<Input$UserListPaginationInput>
      get copyWith => CopyWith$Input$UserListPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserListPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      l$limit,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserListPaginationInput<TRes> {
  factory CopyWith$Input$UserListPaginationInput(
    Input$UserListPaginationInput instance,
    TRes Function(Input$UserListPaginationInput) then,
  ) = _CopyWithImpl$Input$UserListPaginationInput;

  factory CopyWith$Input$UserListPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserListPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$UserListPaginationInput<TRes>
    implements CopyWith$Input$UserListPaginationInput<TRes> {
  _CopyWithImpl$Input$UserListPaginationInput(
    this._instance,
    this._then,
  );

  final Input$UserListPaginationInput _instance;

  final TRes Function(Input$UserListPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$UserListPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$UserListPaginationInput<TRes>
    implements CopyWith$Input$UserListPaginationInput<TRes> {
  _CopyWithStubImpl$Input$UserListPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$getRatingInput {
  factory Input$getRatingInput({
    String? version,
    String? platform,
    String? rating,
  }) =>
      Input$getRatingInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (rating != null) r'rating': rating,
      });

  Input$getRatingInput._(this._$data);

  factory Input$getRatingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    return Input$getRatingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get rating => (_$data['rating'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    return result$data;
  }

  CopyWith$Input$getRatingInput<Input$getRatingInput> get copyWith =>
      CopyWith$Input$getRatingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getRatingInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$rating = rating;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('rating') ? l$rating : const {},
    ]);
  }
}

abstract class CopyWith$Input$getRatingInput<TRes> {
  factory CopyWith$Input$getRatingInput(
    Input$getRatingInput instance,
    TRes Function(Input$getRatingInput) then,
  ) = _CopyWithImpl$Input$getRatingInput;

  factory CopyWith$Input$getRatingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getRatingInput;

  TRes call({
    String? version,
    String? platform,
    String? rating,
  });
}

class _CopyWithImpl$Input$getRatingInput<TRes>
    implements CopyWith$Input$getRatingInput<TRes> {
  _CopyWithImpl$Input$getRatingInput(
    this._instance,
    this._then,
  );

  final Input$getRatingInput _instance;

  final TRes Function(Input$getRatingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? rating = _undefined,
  }) =>
      _then(Input$getRatingInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (rating != _undefined) 'rating': (rating as String?),
      }));
}

class _CopyWithStubImpl$Input$getRatingInput<TRes>
    implements CopyWith$Input$getRatingInput<TRes> {
  _CopyWithStubImpl$Input$getRatingInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? rating,
  }) =>
      _res;
}

class Input$getCmsInput {
  factory Input$getCmsInput({String? slug}) => Input$getCmsInput._({
        if (slug != null) r'slug': slug,
      });

  Input$getCmsInput._(this._$data);

  factory Input$getCmsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    return Input$getCmsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    return result$data;
  }

  CopyWith$Input$getCmsInput<Input$getCmsInput> get copyWith =>
      CopyWith$Input$getCmsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getCmsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    return Object.hashAll([_$data.containsKey('slug') ? l$slug : const {}]);
  }
}

abstract class CopyWith$Input$getCmsInput<TRes> {
  factory CopyWith$Input$getCmsInput(
    Input$getCmsInput instance,
    TRes Function(Input$getCmsInput) then,
  ) = _CopyWithImpl$Input$getCmsInput;

  factory CopyWith$Input$getCmsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getCmsInput;

  TRes call({String? slug});
}

class _CopyWithImpl$Input$getCmsInput<TRes>
    implements CopyWith$Input$getCmsInput<TRes> {
  _CopyWithImpl$Input$getCmsInput(
    this._instance,
    this._then,
  );

  final Input$getCmsInput _instance;

  final TRes Function(Input$getCmsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? slug = _undefined}) => _then(Input$getCmsInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
      }));
}

class _CopyWithStubImpl$Input$getCmsInput<TRes>
    implements CopyWith$Input$getCmsInput<TRes> {
  _CopyWithStubImpl$Input$getCmsInput(this._res);

  TRes _res;

  call({String? slug}) => _res;
}

class Input$AddNewsInputs {
  factory Input$AddNewsInputs({
    String? file_name,
    String? file_path,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  }) =>
      Input$AddNewsInputs._({
        if (file_name != null) r'file_name': file_name,
        if (file_path != null) r'file_path': file_path,
        if (file_type != null) r'file_type': file_type,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
        if (country_id != null) r'country_id': country_id,
        if (country_name != null) r'country_name': country_name,
        if (url != null) r'url': url,
      });

  Input$AddNewsInputs._(this._$data);

  factory Input$AddNewsInputs.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('file_name')) {
      final l$file_name = data['file_name'];
      result$data['file_name'] = (l$file_name as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('country_id')) {
      final l$country_id = data['country_id'];
      result$data['country_id'] = (l$country_id as String?);
    }
    if (data.containsKey('country_name')) {
      final l$country_name = data['country_name'];
      result$data['country_name'] = (l$country_name as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    return Input$AddNewsInputs._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get file_name => (_$data['file_name'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get country_id => (_$data['country_id'] as String?);

  String? get country_name => (_$data['country_name'] as String?);

  String? get url => (_$data['url'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('file_name')) {
      final l$file_name = file_name;
      result$data['file_name'] = l$file_name;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('country_id')) {
      final l$country_id = country_id;
      result$data['country_id'] = l$country_id;
    }
    if (_$data.containsKey('country_name')) {
      final l$country_name = country_name;
      result$data['country_name'] = l$country_name;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    return result$data;
  }

  CopyWith$Input$AddNewsInputs<Input$AddNewsInputs> get copyWith =>
      CopyWith$Input$AddNewsInputs(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddNewsInputs) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$file_name = file_name;
    final lOther$file_name = other.file_name;
    if (_$data.containsKey('file_name') !=
        other._$data.containsKey('file_name')) {
      return false;
    }
    if (l$file_name != lOther$file_name) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$country_id = country_id;
    final lOther$country_id = other.country_id;
    if (_$data.containsKey('country_id') !=
        other._$data.containsKey('country_id')) {
      return false;
    }
    if (l$country_id != lOther$country_id) {
      return false;
    }
    final l$country_name = country_name;
    final lOther$country_name = other.country_name;
    if (_$data.containsKey('country_name') !=
        other._$data.containsKey('country_name')) {
      return false;
    }
    if (l$country_name != lOther$country_name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$file_name = file_name;
    final l$file_path = file_path;
    final l$file_type = file_type;
    final l$title = title;
    final l$description = description;
    final l$status = status;
    final l$country_id = country_id;
    final l$country_name = country_name;
    final l$url = url;
    return Object.hashAll([
      _$data.containsKey('file_name') ? l$file_name : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('country_id') ? l$country_id : const {},
      _$data.containsKey('country_name') ? l$country_name : const {},
      _$data.containsKey('url') ? l$url : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddNewsInputs<TRes> {
  factory CopyWith$Input$AddNewsInputs(
    Input$AddNewsInputs instance,
    TRes Function(Input$AddNewsInputs) then,
  ) = _CopyWithImpl$Input$AddNewsInputs;

  factory CopyWith$Input$AddNewsInputs.stub(TRes res) =
      _CopyWithStubImpl$Input$AddNewsInputs;

  TRes call({
    String? file_name,
    String? file_path,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  });
}

class _CopyWithImpl$Input$AddNewsInputs<TRes>
    implements CopyWith$Input$AddNewsInputs<TRes> {
  _CopyWithImpl$Input$AddNewsInputs(
    this._instance,
    this._then,
  );

  final Input$AddNewsInputs _instance;

  final TRes Function(Input$AddNewsInputs) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? file_name = _undefined,
    Object? file_path = _undefined,
    Object? file_type = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? country_id = _undefined,
    Object? country_name = _undefined,
    Object? url = _undefined,
  }) =>
      _then(Input$AddNewsInputs._({
        ..._instance._$data,
        if (file_name != _undefined) 'file_name': (file_name as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
        if (country_id != _undefined) 'country_id': (country_id as String?),
        if (country_name != _undefined)
          'country_name': (country_name as String?),
        if (url != _undefined) 'url': (url as String?),
      }));
}

class _CopyWithStubImpl$Input$AddNewsInputs<TRes>
    implements CopyWith$Input$AddNewsInputs<TRes> {
  _CopyWithStubImpl$Input$AddNewsInputs(this._res);

  TRes _res;

  call({
    String? file_name,
    String? file_path,
    String? file_type,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  }) =>
      _res;
}

class Input$UpdateNewsStatusInput {
  factory Input$UpdateNewsStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateNewsStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateNewsStatusInput._(this._$data);

  factory Input$UpdateNewsStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateNewsStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateNewsStatusInput<Input$UpdateNewsStatusInput>
      get copyWith => CopyWith$Input$UpdateNewsStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateNewsStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateNewsStatusInput<TRes> {
  factory CopyWith$Input$UpdateNewsStatusInput(
    Input$UpdateNewsStatusInput instance,
    TRes Function(Input$UpdateNewsStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateNewsStatusInput;

  factory CopyWith$Input$UpdateNewsStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateNewsStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateNewsStatusInput<TRes>
    implements CopyWith$Input$UpdateNewsStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateNewsStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNewsStatusInput _instance;

  final TRes Function(Input$UpdateNewsStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateNewsStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateNewsStatusInput<TRes>
    implements CopyWith$Input$UpdateNewsStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNewsStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$NewsUpdateInput {
  factory Input$NewsUpdateInput({
    required String uuid,
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  }) =>
      Input$NewsUpdateInput._({
        r'uuid': uuid,
        if (file_name != null) r'file_name': file_name,
        if (file_type != null) r'file_type': file_type,
        if (file_path != null) r'file_path': file_path,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
        if (country_id != null) r'country_id': country_id,
        if (country_name != null) r'country_name': country_name,
        if (url != null) r'url': url,
      });

  Input$NewsUpdateInput._(this._$data);

  factory Input$NewsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('file_name')) {
      final l$file_name = data['file_name'];
      result$data['file_name'] = (l$file_name as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('country_id')) {
      final l$country_id = data['country_id'];
      result$data['country_id'] = (l$country_id as String?);
    }
    if (data.containsKey('country_name')) {
      final l$country_name = data['country_name'];
      result$data['country_name'] = (l$country_name as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    return Input$NewsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get file_name => (_$data['file_name'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get country_id => (_$data['country_id'] as String?);

  String? get country_name => (_$data['country_name'] as String?);

  String? get url => (_$data['url'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('file_name')) {
      final l$file_name = file_name;
      result$data['file_name'] = l$file_name;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('country_id')) {
      final l$country_id = country_id;
      result$data['country_id'] = l$country_id;
    }
    if (_$data.containsKey('country_name')) {
      final l$country_name = country_name;
      result$data['country_name'] = l$country_name;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    return result$data;
  }

  CopyWith$Input$NewsUpdateInput<Input$NewsUpdateInput> get copyWith =>
      CopyWith$Input$NewsUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$file_name = file_name;
    final lOther$file_name = other.file_name;
    if (_$data.containsKey('file_name') !=
        other._$data.containsKey('file_name')) {
      return false;
    }
    if (l$file_name != lOther$file_name) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$country_id = country_id;
    final lOther$country_id = other.country_id;
    if (_$data.containsKey('country_id') !=
        other._$data.containsKey('country_id')) {
      return false;
    }
    if (l$country_id != lOther$country_id) {
      return false;
    }
    final l$country_name = country_name;
    final lOther$country_name = other.country_name;
    if (_$data.containsKey('country_name') !=
        other._$data.containsKey('country_name')) {
      return false;
    }
    if (l$country_name != lOther$country_name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$file_name = file_name;
    final l$file_type = file_type;
    final l$file_path = file_path;
    final l$title = title;
    final l$description = description;
    final l$status = status;
    final l$country_id = country_id;
    final l$country_name = country_name;
    final l$url = url;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('file_name') ? l$file_name : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('country_id') ? l$country_id : const {},
      _$data.containsKey('country_name') ? l$country_name : const {},
      _$data.containsKey('url') ? l$url : const {},
    ]);
  }
}

abstract class CopyWith$Input$NewsUpdateInput<TRes> {
  factory CopyWith$Input$NewsUpdateInput(
    Input$NewsUpdateInput instance,
    TRes Function(Input$NewsUpdateInput) then,
  ) = _CopyWithImpl$Input$NewsUpdateInput;

  factory CopyWith$Input$NewsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsUpdateInput;

  TRes call({
    String? uuid,
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  });
}

class _CopyWithImpl$Input$NewsUpdateInput<TRes>
    implements CopyWith$Input$NewsUpdateInput<TRes> {
  _CopyWithImpl$Input$NewsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$NewsUpdateInput _instance;

  final TRes Function(Input$NewsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? file_name = _undefined,
    Object? file_type = _undefined,
    Object? file_path = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? country_id = _undefined,
    Object? country_name = _undefined,
    Object? url = _undefined,
  }) =>
      _then(Input$NewsUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (file_name != _undefined) 'file_name': (file_name as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
        if (country_id != _undefined) 'country_id': (country_id as String?),
        if (country_name != _undefined)
          'country_name': (country_name as String?),
        if (url != _undefined) 'url': (url as String?),
      }));
}

class _CopyWithStubImpl$Input$NewsUpdateInput<TRes>
    implements CopyWith$Input$NewsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$NewsUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? file_name,
    String? file_type,
    String? file_path,
    String? title,
    String? description,
    String? status,
    String? country_id,
    String? country_name,
    String? url,
  }) =>
      _res;
}

class Input$viewNewsInput {
  factory Input$viewNewsInput({required String uuid}) => Input$viewNewsInput._({
        r'uuid': uuid,
      });

  Input$viewNewsInput._(this._$data);

  factory Input$viewNewsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewNewsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewNewsInput<Input$viewNewsInput> get copyWith =>
      CopyWith$Input$viewNewsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewNewsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewNewsInput<TRes> {
  factory CopyWith$Input$viewNewsInput(
    Input$viewNewsInput instance,
    TRes Function(Input$viewNewsInput) then,
  ) = _CopyWithImpl$Input$viewNewsInput;

  factory CopyWith$Input$viewNewsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewNewsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewNewsInput<TRes>
    implements CopyWith$Input$viewNewsInput<TRes> {
  _CopyWithImpl$Input$viewNewsInput(
    this._instance,
    this._then,
  );

  final Input$viewNewsInput _instance;

  final TRes Function(Input$viewNewsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewNewsInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewNewsInput<TRes>
    implements CopyWith$Input$viewNewsInput<TRes> {
  _CopyWithStubImpl$Input$viewNewsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$NewsPaginationInput {
  factory Input$NewsPaginationInput({
    required int offset,
    required int limit,
    String? title,
    String? file_type,
    String? status,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? country_id,
  }) =>
      Input$NewsPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        if (title != null) r'title': title,
        if (file_type != null) r'file_type': file_type,
        if (status != null) r'status': status,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (country_id != null) r'country_id': country_id,
      });

  Input$NewsPaginationInput._(this._$data);

  factory Input$NewsPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('file_type')) {
      final l$file_type = data['file_type'];
      result$data['file_type'] = (l$file_type as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('country_id')) {
      final l$country_id = data['country_id'];
      result$data['country_id'] = (l$country_id as String?);
    }
    return Input$NewsPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String? get title => (_$data['title'] as String?);

  String? get file_type => (_$data['file_type'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get country_id => (_$data['country_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('file_type')) {
      final l$file_type = file_type;
      result$data['file_type'] = l$file_type;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('country_id')) {
      final l$country_id = country_id;
      result$data['country_id'] = l$country_id;
    }
    return result$data;
  }

  CopyWith$Input$NewsPaginationInput<Input$NewsPaginationInput> get copyWith =>
      CopyWith$Input$NewsPaginationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$file_type = file_type;
    final lOther$file_type = other.file_type;
    if (_$data.containsKey('file_type') !=
        other._$data.containsKey('file_type')) {
      return false;
    }
    if (l$file_type != lOther$file_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$country_id = country_id;
    final lOther$country_id = other.country_id;
    if (_$data.containsKey('country_id') !=
        other._$data.containsKey('country_id')) {
      return false;
    }
    if (l$country_id != lOther$country_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$file_type = file_type;
    final l$status = status;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$country_id = country_id;
    return Object.hashAll([
      l$offset,
      l$limit,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('file_type') ? l$file_type : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('country_id') ? l$country_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$NewsPaginationInput<TRes> {
  factory CopyWith$Input$NewsPaginationInput(
    Input$NewsPaginationInput instance,
    TRes Function(Input$NewsPaginationInput) then,
  ) = _CopyWithImpl$Input$NewsPaginationInput;

  factory CopyWith$Input$NewsPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? file_type,
    String? status,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? country_id,
  });
}

class _CopyWithImpl$Input$NewsPaginationInput<TRes>
    implements CopyWith$Input$NewsPaginationInput<TRes> {
  _CopyWithImpl$Input$NewsPaginationInput(
    this._instance,
    this._then,
  );

  final Input$NewsPaginationInput _instance;

  final TRes Function(Input$NewsPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? file_type = _undefined,
    Object? status = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? country_id = _undefined,
  }) =>
      _then(Input$NewsPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (title != _undefined) 'title': (title as String?),
        if (file_type != _undefined) 'file_type': (file_type as String?),
        if (status != _undefined) 'status': (status as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (country_id != _undefined) 'country_id': (country_id as String?),
      }));
}

class _CopyWithStubImpl$Input$NewsPaginationInput<TRes>
    implements CopyWith$Input$NewsPaginationInput<TRes> {
  _CopyWithStubImpl$Input$NewsPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? file_type,
    String? status,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? country_id,
  }) =>
      _res;
}

class Input$DeleteNewsInput {
  factory Input$DeleteNewsInput({required String uuid}) =>
      Input$DeleteNewsInput._({
        r'uuid': uuid,
      });

  Input$DeleteNewsInput._(this._$data);

  factory Input$DeleteNewsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteNewsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteNewsInput<Input$DeleteNewsInput> get copyWith =>
      CopyWith$Input$DeleteNewsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteNewsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteNewsInput<TRes> {
  factory CopyWith$Input$DeleteNewsInput(
    Input$DeleteNewsInput instance,
    TRes Function(Input$DeleteNewsInput) then,
  ) = _CopyWithImpl$Input$DeleteNewsInput;

  factory CopyWith$Input$DeleteNewsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteNewsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteNewsInput<TRes>
    implements CopyWith$Input$DeleteNewsInput<TRes> {
  _CopyWithImpl$Input$DeleteNewsInput(
    this._instance,
    this._then,
  );

  final Input$DeleteNewsInput _instance;

  final TRes Function(Input$DeleteNewsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteNewsInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteNewsInput<TRes>
    implements CopyWith$Input$DeleteNewsInput<TRes> {
  _CopyWithStubImpl$Input$DeleteNewsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$GroupFrontInput {
  factory Input$GroupFrontInput({
    required String name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  }) =>
      Input$GroupFrontInput._({
        r'name': name,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (club != null) r'club': club,
        if (type != null) r'type': type,
        if (rating_id != null) r'rating_id': rating_id,
        if (description != null) r'description': description,
        if (is_private != null) r'is_private': is_private,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
      });

  Input$GroupFrontInput._(this._$data);

  factory Input$GroupFrontInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          (l$type as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('rating_id')) {
      final l$rating_id = data['rating_id'];
      result$data['rating_id'] = (l$rating_id as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    return Input$GroupFrontInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  List<String?>? get type => (_$data['type'] as List<String?>?);

  String? get rating_id => (_$data['rating_id'] as String?);

  String? get description => (_$data['description'] as String?);

  int? get is_private => (_$data['is_private'] as int?);

  String? get location => (_$data['location'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.map((e) => e).toList();
    }
    if (_$data.containsKey('rating_id')) {
      final l$rating_id = rating_id;
      result$data['rating_id'] = l$rating_id;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    return result$data;
  }

  CopyWith$Input$GroupFrontInput<Input$GroupFrontInput> get copyWith =>
      CopyWith$Input$GroupFrontInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupFrontInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != null && lOther$type != null) {
      if (l$type.length != lOther$type.length) {
        return false;
      }
      for (int i = 0; i < l$type.length; i++) {
        final l$type$entry = l$type[i];
        final lOther$type$entry = lOther$type[i];
        if (l$type$entry != lOther$type$entry) {
          return false;
        }
      }
    } else if (l$type != lOther$type) {
      return false;
    }
    final l$rating_id = rating_id;
    final lOther$rating_id = other.rating_id;
    if (_$data.containsKey('rating_id') !=
        other._$data.containsKey('rating_id')) {
      return false;
    }
    if (l$rating_id != lOther$rating_id) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$image = image;
    final l$file_path = file_path;
    final l$club = club;
    final l$type = type;
    final l$rating_id = rating_id;
    final l$description = description;
    final l$is_private = is_private;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    return Object.hashAll([
      l$name,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('type')
          ? l$type == null
              ? null
              : Object.hashAll(l$type.map((v) => v))
          : const {},
      _$data.containsKey('rating_id') ? l$rating_id : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupFrontInput<TRes> {
  factory CopyWith$Input$GroupFrontInput(
    Input$GroupFrontInput instance,
    TRes Function(Input$GroupFrontInput) then,
  ) = _CopyWithImpl$Input$GroupFrontInput;

  factory CopyWith$Input$GroupFrontInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupFrontInput;

  TRes call({
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  });
}

class _CopyWithImpl$Input$GroupFrontInput<TRes>
    implements CopyWith$Input$GroupFrontInput<TRes> {
  _CopyWithImpl$Input$GroupFrontInput(
    this._instance,
    this._then,
  );

  final Input$GroupFrontInput _instance;

  final TRes Function(Input$GroupFrontInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? club = _undefined,
    Object? type = _undefined,
    Object? rating_id = _undefined,
    Object? description = _undefined,
    Object? is_private = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
  }) =>
      _then(Input$GroupFrontInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (type != _undefined) 'type': (type as List<String?>?),
        if (rating_id != _undefined) 'rating_id': (rating_id as String?),
        if (description != _undefined) 'description': (description as String?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
      }));
}

class _CopyWithStubImpl$Input$GroupFrontInput<TRes>
    implements CopyWith$Input$GroupFrontInput<TRes> {
  _CopyWithStubImpl$Input$GroupFrontInput(this._res);

  TRes _res;

  call({
    String? name,
    String? image,
    String? file_path,
    List<String?>? club,
    List<String?>? type,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  }) =>
      _res;
}

class Input$viewGroupFrontInput {
  factory Input$viewGroupFrontInput({required String uuid}) =>
      Input$viewGroupFrontInput._({
        r'uuid': uuid,
      });

  Input$viewGroupFrontInput._(this._$data);

  factory Input$viewGroupFrontInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewGroupFrontInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewGroupFrontInput<Input$viewGroupFrontInput> get copyWith =>
      CopyWith$Input$viewGroupFrontInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewGroupFrontInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewGroupFrontInput<TRes> {
  factory CopyWith$Input$viewGroupFrontInput(
    Input$viewGroupFrontInput instance,
    TRes Function(Input$viewGroupFrontInput) then,
  ) = _CopyWithImpl$Input$viewGroupFrontInput;

  factory CopyWith$Input$viewGroupFrontInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewGroupFrontInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewGroupFrontInput<TRes>
    implements CopyWith$Input$viewGroupFrontInput<TRes> {
  _CopyWithImpl$Input$viewGroupFrontInput(
    this._instance,
    this._then,
  );

  final Input$viewGroupFrontInput _instance;

  final TRes Function(Input$viewGroupFrontInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewGroupFrontInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewGroupFrontInput<TRes>
    implements CopyWith$Input$viewGroupFrontInput<TRes> {
  _CopyWithStubImpl$Input$viewGroupFrontInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$GroupPaginationInput {
  factory Input$GroupPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    bool? is_explore_list,
    String? user_uuid,
    String? sort_column,
    String? sort_order,
    String? is_owner,
    bool? is_my_group,
    String? group_for,
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      Input$GroupPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (status != null) r'status': status,
        if (group_type != null) r'group_type': group_type,
        if (skill != null) r'skill': skill,
        if (club != null) r'club': club,
        if (is_explore_list != null) r'is_explore_list': is_explore_list,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_owner != null) r'is_owner': is_owner,
        if (is_my_group != null) r'is_my_group': is_my_group,
        if (group_for != null) r'group_for': group_for,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
      });

  Input$GroupPaginationInput._(this._$data);

  factory Input$GroupPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('group_type')) {
      final l$group_type = data['group_type'];
      result$data['group_type'] = (l$group_type as String?);
    }
    if (data.containsKey('skill')) {
      final l$skill = data['skill'];
      result$data['skill'] = (l$skill as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] = (l$club as String?);
    }
    if (data.containsKey('is_explore_list')) {
      final l$is_explore_list = data['is_explore_list'];
      result$data['is_explore_list'] = (l$is_explore_list as bool?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_owner')) {
      final l$is_owner = data['is_owner'];
      result$data['is_owner'] = (l$is_owner as String?);
    }
    if (data.containsKey('is_my_group')) {
      final l$is_my_group = data['is_my_group'];
      result$data['is_my_group'] = (l$is_my_group as bool?);
    }
    if (data.containsKey('group_for')) {
      final l$group_for = data['group_for'];
      result$data['group_for'] = (l$group_for as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    return Input$GroupPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get group_type => (_$data['group_type'] as String?);

  String? get skill => (_$data['skill'] as String?);

  String? get club => (_$data['club'] as String?);

  bool? get is_explore_list => (_$data['is_explore_list'] as bool?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get is_owner => (_$data['is_owner'] as String?);

  bool? get is_my_group => (_$data['is_my_group'] as bool?);

  String? get group_for => (_$data['group_for'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('group_type')) {
      final l$group_type = group_type;
      result$data['group_type'] = l$group_type;
    }
    if (_$data.containsKey('skill')) {
      final l$skill = skill;
      result$data['skill'] = l$skill;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club;
    }
    if (_$data.containsKey('is_explore_list')) {
      final l$is_explore_list = is_explore_list;
      result$data['is_explore_list'] = l$is_explore_list;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_owner')) {
      final l$is_owner = is_owner;
      result$data['is_owner'] = l$is_owner;
    }
    if (_$data.containsKey('is_my_group')) {
      final l$is_my_group = is_my_group;
      result$data['is_my_group'] = l$is_my_group;
    }
    if (_$data.containsKey('group_for')) {
      final l$group_for = group_for;
      result$data['group_for'] = l$group_for;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    return result$data;
  }

  CopyWith$Input$GroupPaginationInput<Input$GroupPaginationInput>
      get copyWith => CopyWith$Input$GroupPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$group_type = group_type;
    final lOther$group_type = other.group_type;
    if (_$data.containsKey('group_type') !=
        other._$data.containsKey('group_type')) {
      return false;
    }
    if (l$group_type != lOther$group_type) {
      return false;
    }
    final l$skill = skill;
    final lOther$skill = other.skill;
    if (_$data.containsKey('skill') != other._$data.containsKey('skill')) {
      return false;
    }
    if (l$skill != lOther$skill) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != lOther$club) {
      return false;
    }
    final l$is_explore_list = is_explore_list;
    final lOther$is_explore_list = other.is_explore_list;
    if (_$data.containsKey('is_explore_list') !=
        other._$data.containsKey('is_explore_list')) {
      return false;
    }
    if (l$is_explore_list != lOther$is_explore_list) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_owner = is_owner;
    final lOther$is_owner = other.is_owner;
    if (_$data.containsKey('is_owner') !=
        other._$data.containsKey('is_owner')) {
      return false;
    }
    if (l$is_owner != lOther$is_owner) {
      return false;
    }
    final l$is_my_group = is_my_group;
    final lOther$is_my_group = other.is_my_group;
    if (_$data.containsKey('is_my_group') !=
        other._$data.containsKey('is_my_group')) {
      return false;
    }
    if (l$is_my_group != lOther$is_my_group) {
      return false;
    }
    final l$group_for = group_for;
    final lOther$group_for = other.group_for;
    if (_$data.containsKey('group_for') !=
        other._$data.containsKey('group_for')) {
      return false;
    }
    if (l$group_for != lOther$group_for) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$status = status;
    final l$group_type = group_type;
    final l$skill = skill;
    final l$club = club;
    final l$is_explore_list = is_explore_list;
    final l$user_uuid = user_uuid;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_owner = is_owner;
    final l$is_my_group = is_my_group;
    final l$group_for = group_for;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('group_type') ? l$group_type : const {},
      _$data.containsKey('skill') ? l$skill : const {},
      _$data.containsKey('club') ? l$club : const {},
      _$data.containsKey('is_explore_list') ? l$is_explore_list : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_owner') ? l$is_owner : const {},
      _$data.containsKey('is_my_group') ? l$is_my_group : const {},
      _$data.containsKey('group_for') ? l$group_for : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupPaginationInput<TRes> {
  factory CopyWith$Input$GroupPaginationInput(
    Input$GroupPaginationInput instance,
    TRes Function(Input$GroupPaginationInput) then,
  ) = _CopyWithImpl$Input$GroupPaginationInput;

  factory CopyWith$Input$GroupPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    bool? is_explore_list,
    String? user_uuid,
    String? sort_column,
    String? sort_order,
    String? is_owner,
    bool? is_my_group,
    String? group_for,
    double? latitude,
    double? longitude,
    int? radius,
  });
}

class _CopyWithImpl$Input$GroupPaginationInput<TRes>
    implements CopyWith$Input$GroupPaginationInput<TRes> {
  _CopyWithImpl$Input$GroupPaginationInput(
    this._instance,
    this._then,
  );

  final Input$GroupPaginationInput _instance;

  final TRes Function(Input$GroupPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
    Object? group_type = _undefined,
    Object? skill = _undefined,
    Object? club = _undefined,
    Object? is_explore_list = _undefined,
    Object? user_uuid = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_owner = _undefined,
    Object? is_my_group = _undefined,
    Object? group_for = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
  }) =>
      _then(Input$GroupPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (status != _undefined) 'status': (status as String?),
        if (group_type != _undefined) 'group_type': (group_type as String?),
        if (skill != _undefined) 'skill': (skill as String?),
        if (club != _undefined) 'club': (club as String?),
        if (is_explore_list != _undefined)
          'is_explore_list': (is_explore_list as bool?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_owner != _undefined) 'is_owner': (is_owner as String?),
        if (is_my_group != _undefined) 'is_my_group': (is_my_group as bool?),
        if (group_for != _undefined) 'group_for': (group_for as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
      }));
}

class _CopyWithStubImpl$Input$GroupPaginationInput<TRes>
    implements CopyWith$Input$GroupPaginationInput<TRes> {
  _CopyWithStubImpl$Input$GroupPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    bool? is_explore_list,
    String? user_uuid,
    String? sort_column,
    String? sort_order,
    String? is_owner,
    bool? is_my_group,
    String? group_for,
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      _res;
}

class Input$GroupInput {
  factory Input$GroupInput({
    required String uuid,
    required String name,
    List<String?>? club,
    List<String?>? type,
    String? image,
    String? file_path,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  }) =>
      Input$GroupInput._({
        r'uuid': uuid,
        r'name': name,
        if (club != null) r'club': club,
        if (type != null) r'type': type,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (rating_id != null) r'rating_id': rating_id,
        if (description != null) r'description': description,
        if (is_private != null) r'is_private': is_private,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
      });

  Input$GroupInput._(this._$data);

  factory Input$GroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] =
          (l$club as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] =
          (l$type as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('rating_id')) {
      final l$rating_id = data['rating_id'];
      result$data['rating_id'] = (l$rating_id as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    return Input$GroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get name => (_$data['name'] as String);

  List<String?>? get club => (_$data['club'] as List<String?>?);

  List<String?>? get type => (_$data['type'] as List<String?>?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get rating_id => (_$data['rating_id'] as String?);

  String? get description => (_$data['description'] as String?);

  int? get is_private => (_$data['is_private'] as int?);

  String? get location => (_$data['location'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type?.map((e) => e).toList();
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('rating_id')) {
      final l$rating_id = rating_id;
      result$data['rating_id'] = l$rating_id;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    return result$data;
  }

  CopyWith$Input$GroupInput<Input$GroupInput> get copyWith =>
      CopyWith$Input$GroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != null && lOther$club != null) {
      if (l$club.length != lOther$club.length) {
        return false;
      }
      for (int i = 0; i < l$club.length; i++) {
        final l$club$entry = l$club[i];
        final lOther$club$entry = lOther$club[i];
        if (l$club$entry != lOther$club$entry) {
          return false;
        }
      }
    } else if (l$club != lOther$club) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != null && lOther$type != null) {
      if (l$type.length != lOther$type.length) {
        return false;
      }
      for (int i = 0; i < l$type.length; i++) {
        final l$type$entry = l$type[i];
        final lOther$type$entry = lOther$type[i];
        if (l$type$entry != lOther$type$entry) {
          return false;
        }
      }
    } else if (l$type != lOther$type) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$rating_id = rating_id;
    final lOther$rating_id = other.rating_id;
    if (_$data.containsKey('rating_id') !=
        other._$data.containsKey('rating_id')) {
      return false;
    }
    if (l$rating_id != lOther$rating_id) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$club = club;
    final l$type = type;
    final l$image = image;
    final l$file_path = file_path;
    final l$rating_id = rating_id;
    final l$description = description;
    final l$is_private = is_private;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    return Object.hashAll([
      l$uuid,
      l$name,
      _$data.containsKey('club')
          ? l$club == null
              ? null
              : Object.hashAll(l$club.map((v) => v))
          : const {},
      _$data.containsKey('type')
          ? l$type == null
              ? null
              : Object.hashAll(l$type.map((v) => v))
          : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('rating_id') ? l$rating_id : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupInput<TRes> {
  factory CopyWith$Input$GroupInput(
    Input$GroupInput instance,
    TRes Function(Input$GroupInput) then,
  ) = _CopyWithImpl$Input$GroupInput;

  factory CopyWith$Input$GroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupInput;

  TRes call({
    String? uuid,
    String? name,
    List<String?>? club,
    List<String?>? type,
    String? image,
    String? file_path,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  });
}

class _CopyWithImpl$Input$GroupInput<TRes>
    implements CopyWith$Input$GroupInput<TRes> {
  _CopyWithImpl$Input$GroupInput(
    this._instance,
    this._then,
  );

  final Input$GroupInput _instance;

  final TRes Function(Input$GroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? club = _undefined,
    Object? type = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? rating_id = _undefined,
    Object? description = _undefined,
    Object? is_private = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
  }) =>
      _then(Input$GroupInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (club != _undefined) 'club': (club as List<String?>?),
        if (type != _undefined) 'type': (type as List<String?>?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (rating_id != _undefined) 'rating_id': (rating_id as String?),
        if (description != _undefined) 'description': (description as String?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
      }));
}

class _CopyWithStubImpl$Input$GroupInput<TRes>
    implements CopyWith$Input$GroupInput<TRes> {
  _CopyWithStubImpl$Input$GroupInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    List<String?>? club,
    List<String?>? type,
    String? image,
    String? file_path,
    String? rating_id,
    String? description,
    int? is_private,
    String? location,
    String? latitude,
    String? longitude,
  }) =>
      _res;
}

class Input$exploreClubInput {
  factory Input$exploreClubInput({
    required int offset,
    int? limit,
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? court_type,
    int? no_courts,
    int? no_member,
    String? type,
  }) =>
      Input$exploreClubInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (court_type != null) r'court_type': court_type,
        if (no_courts != null) r'no_courts': no_courts,
        if (no_member != null) r'no_member': no_member,
        if (type != null) r'type': type,
      });

  Input$exploreClubInput._(this._$data);

  factory Input$exploreClubInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    if (data.containsKey('no_courts')) {
      final l$no_courts = data['no_courts'];
      result$data['no_courts'] = (l$no_courts as int?);
    }
    if (data.containsKey('no_member')) {
      final l$no_member = data['no_member'];
      result$data['no_member'] = (l$no_member as int?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    return Input$exploreClubInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get court_type => (_$data['court_type'] as String?);

  int? get no_courts => (_$data['no_courts'] as int?);

  int? get no_member => (_$data['no_member'] as int?);

  String? get type => (_$data['type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    if (_$data.containsKey('no_courts')) {
      final l$no_courts = no_courts;
      result$data['no_courts'] = l$no_courts;
    }
    if (_$data.containsKey('no_member')) {
      final l$no_member = no_member;
      result$data['no_member'] = l$no_member;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    return result$data;
  }

  CopyWith$Input$exploreClubInput<Input$exploreClubInput> get copyWith =>
      CopyWith$Input$exploreClubInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$exploreClubInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    final l$no_courts = no_courts;
    final lOther$no_courts = other.no_courts;
    if (_$data.containsKey('no_courts') !=
        other._$data.containsKey('no_courts')) {
      return false;
    }
    if (l$no_courts != lOther$no_courts) {
      return false;
    }
    final l$no_member = no_member;
    final lOther$no_member = other.no_member;
    if (_$data.containsKey('no_member') !=
        other._$data.containsKey('no_member')) {
      return false;
    }
    if (l$no_member != lOther$no_member) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$is_membership_requre = is_membership_requre;
    final l$court_type = court_type;
    final l$no_courts = no_courts;
    final l$no_member = no_member;
    final l$type = type;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
      _$data.containsKey('no_courts') ? l$no_courts : const {},
      _$data.containsKey('no_member') ? l$no_member : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$exploreClubInput<TRes> {
  factory CopyWith$Input$exploreClubInput(
    Input$exploreClubInput instance,
    TRes Function(Input$exploreClubInput) then,
  ) = _CopyWithImpl$Input$exploreClubInput;

  factory CopyWith$Input$exploreClubInput.stub(TRes res) =
      _CopyWithStubImpl$Input$exploreClubInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? court_type,
    int? no_courts,
    int? no_member,
    String? type,
  });
}

class _CopyWithImpl$Input$exploreClubInput<TRes>
    implements CopyWith$Input$exploreClubInput<TRes> {
  _CopyWithImpl$Input$exploreClubInput(
    this._instance,
    this._then,
  );

  final Input$exploreClubInput _instance;

  final TRes Function(Input$exploreClubInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? is_membership_requre = _undefined,
    Object? court_type = _undefined,
    Object? no_courts = _undefined,
    Object? no_member = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$exploreClubInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
        if (no_courts != _undefined) 'no_courts': (no_courts as int?),
        if (no_member != _undefined) 'no_member': (no_member as int?),
        if (type != _undefined) 'type': (type as String?),
      }));
}

class _CopyWithStubImpl$Input$exploreClubInput<TRes>
    implements CopyWith$Input$exploreClubInput<TRes> {
  _CopyWithStubImpl$Input$exploreClubInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    double? latitude,
    double? longitude,
    int? radius,
    String? is_membership_requre,
    String? court_type,
    int? no_courts,
    int? no_member,
    String? type,
  }) =>
      _res;
}

class Input$joinGroupInput {
  factory Input$joinGroupInput({
    required String group_id,
    required String user_id,
    String? status,
  }) =>
      Input$joinGroupInput._({
        r'group_id': group_id,
        r'user_id': user_id,
        if (status != null) r'status': status,
      });

  Input$joinGroupInput._(this._$data);

  factory Input$joinGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_id = data['group_id'];
    result$data['group_id'] = (l$group_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$joinGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_id => (_$data['group_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_id = group_id;
    result$data['group_id'] = l$group_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$joinGroupInput<Input$joinGroupInput> get copyWith =>
      CopyWith$Input$joinGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$joinGroupInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_id = group_id;
    final lOther$group_id = other.group_id;
    if (l$group_id != lOther$group_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_id = group_id;
    final l$user_id = user_id;
    final l$status = status;
    return Object.hashAll([
      l$group_id,
      l$user_id,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$joinGroupInput<TRes> {
  factory CopyWith$Input$joinGroupInput(
    Input$joinGroupInput instance,
    TRes Function(Input$joinGroupInput) then,
  ) = _CopyWithImpl$Input$joinGroupInput;

  factory CopyWith$Input$joinGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$joinGroupInput;

  TRes call({
    String? group_id,
    String? user_id,
    String? status,
  });
}

class _CopyWithImpl$Input$joinGroupInput<TRes>
    implements CopyWith$Input$joinGroupInput<TRes> {
  _CopyWithImpl$Input$joinGroupInput(
    this._instance,
    this._then,
  );

  final Input$joinGroupInput _instance;

  final TRes Function(Input$joinGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_id = _undefined,
    Object? user_id = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$joinGroupInput._({
        ..._instance._$data,
        if (group_id != _undefined && group_id != null)
          'group_id': (group_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$joinGroupInput<TRes>
    implements CopyWith$Input$joinGroupInput<TRes> {
  _CopyWithStubImpl$Input$joinGroupInput(this._res);

  TRes _res;

  call({
    String? group_id,
    String? user_id,
    String? status,
  }) =>
      _res;
}

class Input$sendRequestToJoinInput {
  factory Input$sendRequestToJoinInput({
    required List<String?> group_uuid,
    required String user,
  }) =>
      Input$sendRequestToJoinInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$sendRequestToJoinInput._(this._$data);

  factory Input$sendRequestToJoinInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] =
        (l$group_uuid as List<dynamic>).map((e) => (e as String?)).toList();
    final l$user = data['user'];
    result$data['user'] = (l$user as String);
    return Input$sendRequestToJoinInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?> get group_uuid => (_$data['group_uuid'] as List<String?>);

  String get user => (_$data['user'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid.map((e) => e).toList();
    final l$user = user;
    result$data['user'] = l$user;
    return result$data;
  }

  CopyWith$Input$sendRequestToJoinInput<Input$sendRequestToJoinInput>
      get copyWith => CopyWith$Input$sendRequestToJoinInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$sendRequestToJoinInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid.length != lOther$group_uuid.length) {
      return false;
    }
    for (int i = 0; i < l$group_uuid.length; i++) {
      final l$group_uuid$entry = l$group_uuid[i];
      final lOther$group_uuid$entry = lOther$group_uuid[i];
      if (l$group_uuid$entry != lOther$group_uuid$entry) {
        return false;
      }
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      Object.hashAll(l$group_uuid.map((v) => v)),
      l$user,
    ]);
  }
}

abstract class CopyWith$Input$sendRequestToJoinInput<TRes> {
  factory CopyWith$Input$sendRequestToJoinInput(
    Input$sendRequestToJoinInput instance,
    TRes Function(Input$sendRequestToJoinInput) then,
  ) = _CopyWithImpl$Input$sendRequestToJoinInput;

  factory CopyWith$Input$sendRequestToJoinInput.stub(TRes res) =
      _CopyWithStubImpl$Input$sendRequestToJoinInput;

  TRes call({
    List<String?>? group_uuid,
    String? user,
  });
}

class _CopyWithImpl$Input$sendRequestToJoinInput<TRes>
    implements CopyWith$Input$sendRequestToJoinInput<TRes> {
  _CopyWithImpl$Input$sendRequestToJoinInput(
    this._instance,
    this._then,
  );

  final Input$sendRequestToJoinInput _instance;

  final TRes Function(Input$sendRequestToJoinInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$sendRequestToJoinInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as List<String?>),
        if (user != _undefined && user != null) 'user': (user as String),
      }));
}

class _CopyWithStubImpl$Input$sendRequestToJoinInput<TRes>
    implements CopyWith$Input$sendRequestToJoinInput<TRes> {
  _CopyWithStubImpl$Input$sendRequestToJoinInput(this._res);

  TRes _res;

  call({
    List<String?>? group_uuid,
    String? user,
  }) =>
      _res;
}

class Input$publicGroupJoinInput {
  factory Input$publicGroupJoinInput({
    required String group_id,
    required String user_id,
    required String status,
  }) =>
      Input$publicGroupJoinInput._({
        r'group_id': group_id,
        r'user_id': user_id,
        r'status': status,
      });

  Input$publicGroupJoinInput._(this._$data);

  factory Input$publicGroupJoinInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_id = data['group_id'];
    result$data['group_id'] = (l$group_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$publicGroupJoinInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_id => (_$data['group_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_id = group_id;
    result$data['group_id'] = l$group_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$publicGroupJoinInput<Input$publicGroupJoinInput>
      get copyWith => CopyWith$Input$publicGroupJoinInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$publicGroupJoinInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_id = group_id;
    final lOther$group_id = other.group_id;
    if (l$group_id != lOther$group_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_id = group_id;
    final l$user_id = user_id;
    final l$status = status;
    return Object.hashAll([
      l$group_id,
      l$user_id,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$publicGroupJoinInput<TRes> {
  factory CopyWith$Input$publicGroupJoinInput(
    Input$publicGroupJoinInput instance,
    TRes Function(Input$publicGroupJoinInput) then,
  ) = _CopyWithImpl$Input$publicGroupJoinInput;

  factory CopyWith$Input$publicGroupJoinInput.stub(TRes res) =
      _CopyWithStubImpl$Input$publicGroupJoinInput;

  TRes call({
    String? group_id,
    String? user_id,
    String? status,
  });
}

class _CopyWithImpl$Input$publicGroupJoinInput<TRes>
    implements CopyWith$Input$publicGroupJoinInput<TRes> {
  _CopyWithImpl$Input$publicGroupJoinInput(
    this._instance,
    this._then,
  );

  final Input$publicGroupJoinInput _instance;

  final TRes Function(Input$publicGroupJoinInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_id = _undefined,
    Object? user_id = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$publicGroupJoinInput._({
        ..._instance._$data,
        if (group_id != _undefined && group_id != null)
          'group_id': (group_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$publicGroupJoinInput<TRes>
    implements CopyWith$Input$publicGroupJoinInput<TRes> {
  _CopyWithStubImpl$Input$publicGroupJoinInput(this._res);

  TRes _res;

  call({
    String? group_id,
    String? user_id,
    String? status,
  }) =>
      _res;
}

class Input$UserAddGroupInput {
  factory Input$UserAddGroupInput({
    required List<String?> group_uuid,
    required String user,
  }) =>
      Input$UserAddGroupInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$UserAddGroupInput._(this._$data);

  factory Input$UserAddGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] =
        (l$group_uuid as List<dynamic>).map((e) => (e as String?)).toList();
    final l$user = data['user'];
    result$data['user'] = (l$user as String);
    return Input$UserAddGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?> get group_uuid => (_$data['group_uuid'] as List<String?>);

  String get user => (_$data['user'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid.map((e) => e).toList();
    final l$user = user;
    result$data['user'] = l$user;
    return result$data;
  }

  CopyWith$Input$UserAddGroupInput<Input$UserAddGroupInput> get copyWith =>
      CopyWith$Input$UserAddGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserAddGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid.length != lOther$group_uuid.length) {
      return false;
    }
    for (int i = 0; i < l$group_uuid.length; i++) {
      final l$group_uuid$entry = l$group_uuid[i];
      final lOther$group_uuid$entry = lOther$group_uuid[i];
      if (l$group_uuid$entry != lOther$group_uuid$entry) {
        return false;
      }
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      Object.hashAll(l$group_uuid.map((v) => v)),
      l$user,
    ]);
  }
}

abstract class CopyWith$Input$UserAddGroupInput<TRes> {
  factory CopyWith$Input$UserAddGroupInput(
    Input$UserAddGroupInput instance,
    TRes Function(Input$UserAddGroupInput) then,
  ) = _CopyWithImpl$Input$UserAddGroupInput;

  factory CopyWith$Input$UserAddGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserAddGroupInput;

  TRes call({
    List<String?>? group_uuid,
    String? user,
  });
}

class _CopyWithImpl$Input$UserAddGroupInput<TRes>
    implements CopyWith$Input$UserAddGroupInput<TRes> {
  _CopyWithImpl$Input$UserAddGroupInput(
    this._instance,
    this._then,
  );

  final Input$UserAddGroupInput _instance;

  final TRes Function(Input$UserAddGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$UserAddGroupInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as List<String?>),
        if (user != _undefined && user != null) 'user': (user as String),
      }));
}

class _CopyWithStubImpl$Input$UserAddGroupInput<TRes>
    implements CopyWith$Input$UserAddGroupInput<TRes> {
  _CopyWithStubImpl$Input$UserAddGroupInput(this._res);

  TRes _res;

  call({
    List<String?>? group_uuid,
    String? user,
  }) =>
      _res;
}

class Input$RemoveGroupMemberInput {
  factory Input$RemoveGroupMemberInput({
    required String group_uuid,
    required List<String?> user,
  }) =>
      Input$RemoveGroupMemberInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$RemoveGroupMemberInput._(this._$data);

  factory Input$RemoveGroupMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] = (l$group_uuid as String);
    final l$user = data['user'];
    result$data['user'] =
        (l$user as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$RemoveGroupMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_uuid => (_$data['group_uuid'] as String);

  List<String?> get user => (_$data['user'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid;
    final l$user = user;
    result$data['user'] = l$user.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RemoveGroupMemberInput<Input$RemoveGroupMemberInput>
      get copyWith => CopyWith$Input$RemoveGroupMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveGroupMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid != lOther$group_uuid) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user.length != lOther$user.length) {
      return false;
    }
    for (int i = 0; i < l$user.length; i++) {
      final l$user$entry = l$user[i];
      final lOther$user$entry = lOther$user[i];
      if (l$user$entry != lOther$user$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      l$group_uuid,
      Object.hashAll(l$user.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RemoveGroupMemberInput<TRes> {
  factory CopyWith$Input$RemoveGroupMemberInput(
    Input$RemoveGroupMemberInput instance,
    TRes Function(Input$RemoveGroupMemberInput) then,
  ) = _CopyWithImpl$Input$RemoveGroupMemberInput;

  factory CopyWith$Input$RemoveGroupMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveGroupMemberInput;

  TRes call({
    String? group_uuid,
    List<String?>? user,
  });
}

class _CopyWithImpl$Input$RemoveGroupMemberInput<TRes>
    implements CopyWith$Input$RemoveGroupMemberInput<TRes> {
  _CopyWithImpl$Input$RemoveGroupMemberInput(
    this._instance,
    this._then,
  );

  final Input$RemoveGroupMemberInput _instance;

  final TRes Function(Input$RemoveGroupMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$RemoveGroupMemberInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as String),
        if (user != _undefined && user != null) 'user': (user as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$RemoveGroupMemberInput<TRes>
    implements CopyWith$Input$RemoveGroupMemberInput<TRes> {
  _CopyWithStubImpl$Input$RemoveGroupMemberInput(this._res);

  TRes _res;

  call({
    String? group_uuid,
    List<String?>? user,
  }) =>
      _res;
}

class Input$ViewGroupMemberAddGroupInput {
  factory Input$ViewGroupMemberAddGroupInput({
    String? uuid,
    int? offset,
    int? limit,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$ViewGroupMemberAddGroupInput._({
        if (uuid != null) r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (full_name != null) r'full_name': full_name,
        if (rating != null) r'rating': rating,
        if (gender != null) r'gender': gender,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (recommendation != null) r'recommendation': recommendation,
        if (is_friend != null) r'is_friend': is_friend,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$ViewGroupMemberAddGroupInput._(this._$data);

  factory Input$ViewGroupMemberAddGroupInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('is_friend')) {
      final l$is_friend = data['is_friend'];
      result$data['is_friend'] = (l$is_friend as bool?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$ViewGroupMemberAddGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get gender => (_$data['gender'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  String? get recommendation => (_$data['recommendation'] as String?);

  bool? get is_friend => (_$data['is_friend'] as bool?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('is_friend')) {
      final l$is_friend = is_friend;
      result$data['is_friend'] = l$is_friend;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$ViewGroupMemberAddGroupInput<
          Input$ViewGroupMemberAddGroupInput>
      get copyWith => CopyWith$Input$ViewGroupMemberAddGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ViewGroupMemberAddGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$is_friend = is_friend;
    final lOther$is_friend = other.is_friend;
    if (_$data.containsKey('is_friend') !=
        other._$data.containsKey('is_friend')) {
      return false;
    }
    if (l$is_friend != lOther$is_friend) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$full_name = full_name;
    final l$rating = rating;
    final l$gender = gender;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$recommendation = recommendation;
    final l$is_friend = is_friend;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('is_friend') ? l$is_friend : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$ViewGroupMemberAddGroupInput<TRes> {
  factory CopyWith$Input$ViewGroupMemberAddGroupInput(
    Input$ViewGroupMemberAddGroupInput instance,
    TRes Function(Input$ViewGroupMemberAddGroupInput) then,
  ) = _CopyWithImpl$Input$ViewGroupMemberAddGroupInput;

  factory CopyWith$Input$ViewGroupMemberAddGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ViewGroupMemberAddGroupInput;

  TRes call({
    String? uuid,
    int? offset,
    int? limit,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$ViewGroupMemberAddGroupInput<TRes>
    implements CopyWith$Input$ViewGroupMemberAddGroupInput<TRes> {
  _CopyWithImpl$Input$ViewGroupMemberAddGroupInput(
    this._instance,
    this._then,
  );

  final Input$ViewGroupMemberAddGroupInput _instance;

  final TRes Function(Input$ViewGroupMemberAddGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? full_name = _undefined,
    Object? rating = _undefined,
    Object? gender = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? recommendation = _undefined,
    Object? is_friend = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$ViewGroupMemberAddGroupInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (is_friend != _undefined) 'is_friend': (is_friend as bool?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$ViewGroupMemberAddGroupInput<TRes>
    implements CopyWith$Input$ViewGroupMemberAddGroupInput<TRes> {
  _CopyWithStubImpl$Input$ViewGroupMemberAddGroupInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? offset,
    int? limit,
    String? full_name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? recommendation,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$UserRemoveGroupInput {
  factory Input$UserRemoveGroupInput({
    required String group_uuid,
    required List<String?> user,
  }) =>
      Input$UserRemoveGroupInput._({
        r'group_uuid': group_uuid,
        r'user': user,
      });

  Input$UserRemoveGroupInput._(this._$data);

  factory Input$UserRemoveGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$group_uuid = data['group_uuid'];
    result$data['group_uuid'] = (l$group_uuid as String);
    final l$user = data['user'];
    result$data['user'] =
        (l$user as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$UserRemoveGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get group_uuid => (_$data['group_uuid'] as String);

  List<String?> get user => (_$data['user'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$group_uuid = group_uuid;
    result$data['group_uuid'] = l$group_uuid;
    final l$user = user;
    result$data['user'] = l$user.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$UserRemoveGroupInput<Input$UserRemoveGroupInput>
      get copyWith => CopyWith$Input$UserRemoveGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRemoveGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_uuid = group_uuid;
    final lOther$group_uuid = other.group_uuid;
    if (l$group_uuid != lOther$group_uuid) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user.length != lOther$user.length) {
      return false;
    }
    for (int i = 0; i < l$user.length; i++) {
      final l$user$entry = l$user[i];
      final lOther$user$entry = lOther$user[i];
      if (l$user$entry != lOther$user$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_uuid = group_uuid;
    final l$user = user;
    return Object.hashAll([
      l$group_uuid,
      Object.hashAll(l$user.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UserRemoveGroupInput<TRes> {
  factory CopyWith$Input$UserRemoveGroupInput(
    Input$UserRemoveGroupInput instance,
    TRes Function(Input$UserRemoveGroupInput) then,
  ) = _CopyWithImpl$Input$UserRemoveGroupInput;

  factory CopyWith$Input$UserRemoveGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRemoveGroupInput;

  TRes call({
    String? group_uuid,
    List<String?>? user,
  });
}

class _CopyWithImpl$Input$UserRemoveGroupInput<TRes>
    implements CopyWith$Input$UserRemoveGroupInput<TRes> {
  _CopyWithImpl$Input$UserRemoveGroupInput(
    this._instance,
    this._then,
  );

  final Input$UserRemoveGroupInput _instance;

  final TRes Function(Input$UserRemoveGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$UserRemoveGroupInput._({
        ..._instance._$data,
        if (group_uuid != _undefined && group_uuid != null)
          'group_uuid': (group_uuid as String),
        if (user != _undefined && user != null) 'user': (user as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$UserRemoveGroupInput<TRes>
    implements CopyWith$Input$UserRemoveGroupInput<TRes> {
  _CopyWithStubImpl$Input$UserRemoveGroupInput(this._res);

  TRes _res;

  call({
    String? group_uuid,
    List<String?>? user,
  }) =>
      _res;
}

class Input$CMSCreateInput {
  factory Input$CMSCreateInput({
    String? title,
    String? description,
    String? status,
  }) =>
      Input$CMSCreateInput._({
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
      });

  Input$CMSCreateInput._(this._$data);

  factory Input$CMSCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$CMSCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$CMSCreateInput<Input$CMSCreateInput> get copyWith =>
      CopyWith$Input$CMSCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CMSCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$description = description;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$CMSCreateInput<TRes> {
  factory CopyWith$Input$CMSCreateInput(
    Input$CMSCreateInput instance,
    TRes Function(Input$CMSCreateInput) then,
  ) = _CopyWithImpl$Input$CMSCreateInput;

  factory CopyWith$Input$CMSCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CMSCreateInput;

  TRes call({
    String? title,
    String? description,
    String? status,
  });
}

class _CopyWithImpl$Input$CMSCreateInput<TRes>
    implements CopyWith$Input$CMSCreateInput<TRes> {
  _CopyWithImpl$Input$CMSCreateInput(
    this._instance,
    this._then,
  );

  final Input$CMSCreateInput _instance;

  final TRes Function(Input$CMSCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CMSCreateInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$CMSCreateInput<TRes>
    implements CopyWith$Input$CMSCreateInput<TRes> {
  _CopyWithStubImpl$Input$CMSCreateInput(this._res);

  TRes _res;

  call({
    String? title,
    String? description,
    String? status,
  }) =>
      _res;
}

class Input$viewCmsInput {
  factory Input$viewCmsInput({String? uuid}) => Input$viewCmsInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewCmsInput._(this._$data);

  factory Input$viewCmsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewCmsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewCmsInput<Input$viewCmsInput> get copyWith =>
      CopyWith$Input$viewCmsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewCmsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewCmsInput<TRes> {
  factory CopyWith$Input$viewCmsInput(
    Input$viewCmsInput instance,
    TRes Function(Input$viewCmsInput) then,
  ) = _CopyWithImpl$Input$viewCmsInput;

  factory CopyWith$Input$viewCmsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewCmsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewCmsInput<TRes>
    implements CopyWith$Input$viewCmsInput<TRes> {
  _CopyWithImpl$Input$viewCmsInput(
    this._instance,
    this._then,
  );

  final Input$viewCmsInput _instance;

  final TRes Function(Input$viewCmsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewCmsInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewCmsInput<TRes>
    implements CopyWith$Input$viewCmsInput<TRes> {
  _CopyWithStubImpl$Input$viewCmsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$UpdateCMSStatusInput {
  factory Input$UpdateCMSStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateCMSStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateCMSStatusInput._(this._$data);

  factory Input$UpdateCMSStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateCMSStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateCMSStatusInput<Input$UpdateCMSStatusInput>
      get copyWith => CopyWith$Input$UpdateCMSStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCMSStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateCMSStatusInput<TRes> {
  factory CopyWith$Input$UpdateCMSStatusInput(
    Input$UpdateCMSStatusInput instance,
    TRes Function(Input$UpdateCMSStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateCMSStatusInput;

  factory CopyWith$Input$UpdateCMSStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCMSStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateCMSStatusInput<TRes>
    implements CopyWith$Input$UpdateCMSStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateCMSStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCMSStatusInput _instance;

  final TRes Function(Input$UpdateCMSStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateCMSStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateCMSStatusInput<TRes>
    implements CopyWith$Input$UpdateCMSStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCMSStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$deleteCMSInput {
  factory Input$deleteCMSInput({required String uuid}) =>
      Input$deleteCMSInput._({
        r'uuid': uuid,
      });

  Input$deleteCMSInput._(this._$data);

  factory Input$deleteCMSInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteCMSInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteCMSInput<Input$deleteCMSInput> get copyWith =>
      CopyWith$Input$deleteCMSInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteCMSInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteCMSInput<TRes> {
  factory CopyWith$Input$deleteCMSInput(
    Input$deleteCMSInput instance,
    TRes Function(Input$deleteCMSInput) then,
  ) = _CopyWithImpl$Input$deleteCMSInput;

  factory CopyWith$Input$deleteCMSInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteCMSInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteCMSInput<TRes>
    implements CopyWith$Input$deleteCMSInput<TRes> {
  _CopyWithImpl$Input$deleteCMSInput(
    this._instance,
    this._then,
  );

  final Input$deleteCMSInput _instance;

  final TRes Function(Input$deleteCMSInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteCMSInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteCMSInput<TRes>
    implements CopyWith$Input$deleteCMSInput<TRes> {
  _CopyWithStubImpl$Input$deleteCMSInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CMSUpdateInput {
  factory Input$CMSUpdateInput({
    required String uuid,
    String? title,
    String? description,
    String? status,
    List<Input$TermsData?>? terms,
  }) =>
      Input$CMSUpdateInput._({
        r'uuid': uuid,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
        if (terms != null) r'terms': terms,
      });

  Input$CMSUpdateInput._(this._$data);

  factory Input$CMSUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('terms')) {
      final l$terms = data['terms'];
      result$data['terms'] = (l$terms as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$TermsData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CMSUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  List<Input$TermsData?>? get terms =>
      (_$data['terms'] as List<Input$TermsData?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('terms')) {
      final l$terms = terms;
      result$data['terms'] = l$terms?.map((e) => e?.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CMSUpdateInput<Input$CMSUpdateInput> get copyWith =>
      CopyWith$Input$CMSUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CMSUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$terms = terms;
    final lOther$terms = other.terms;
    if (_$data.containsKey('terms') != other._$data.containsKey('terms')) {
      return false;
    }
    if (l$terms != null && lOther$terms != null) {
      if (l$terms.length != lOther$terms.length) {
        return false;
      }
      for (int i = 0; i < l$terms.length; i++) {
        final l$terms$entry = l$terms[i];
        final lOther$terms$entry = lOther$terms[i];
        if (l$terms$entry != lOther$terms$entry) {
          return false;
        }
      }
    } else if (l$terms != lOther$terms) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$title = title;
    final l$description = description;
    final l$status = status;
    final l$terms = terms;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('terms')
          ? l$terms == null
              ? null
              : Object.hashAll(l$terms.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CMSUpdateInput<TRes> {
  factory CopyWith$Input$CMSUpdateInput(
    Input$CMSUpdateInput instance,
    TRes Function(Input$CMSUpdateInput) then,
  ) = _CopyWithImpl$Input$CMSUpdateInput;

  factory CopyWith$Input$CMSUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CMSUpdateInput;

  TRes call({
    String? uuid,
    String? title,
    String? description,
    String? status,
    List<Input$TermsData?>? terms,
  });
  TRes terms(
      Iterable<Input$TermsData?>? Function(
              Iterable<CopyWith$Input$TermsData<Input$TermsData>?>?)
          _fn);
}

class _CopyWithImpl$Input$CMSUpdateInput<TRes>
    implements CopyWith$Input$CMSUpdateInput<TRes> {
  _CopyWithImpl$Input$CMSUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CMSUpdateInput _instance;

  final TRes Function(Input$CMSUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
    Object? terms = _undefined,
  }) =>
      _then(Input$CMSUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
        if (terms != _undefined) 'terms': (terms as List<Input$TermsData?>?),
      }));

  TRes terms(
          Iterable<Input$TermsData?>? Function(
                  Iterable<CopyWith$Input$TermsData<Input$TermsData>?>?)
              _fn) =>
      call(
          terms: _fn(_instance.terms?.map((e) => e == null
              ? null
              : CopyWith$Input$TermsData(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$CMSUpdateInput<TRes>
    implements CopyWith$Input$CMSUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CMSUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? title,
    String? description,
    String? status,
    List<Input$TermsData?>? terms,
  }) =>
      _res;

  terms(_fn) => _res;
}

class Input$TermsData {
  factory Input$TermsData({
    String? title,
    String? description,
  }) =>
      Input$TermsData._({
        if (title != null) r'title': title,
        if (description != null) r'description': description,
      });

  Input$TermsData._(this._$data);

  factory Input$TermsData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$TermsData._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$TermsData<Input$TermsData> get copyWith =>
      CopyWith$Input$TermsData(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TermsData) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TermsData<TRes> {
  factory CopyWith$Input$TermsData(
    Input$TermsData instance,
    TRes Function(Input$TermsData) then,
  ) = _CopyWithImpl$Input$TermsData;

  factory CopyWith$Input$TermsData.stub(TRes res) =
      _CopyWithStubImpl$Input$TermsData;

  TRes call({
    String? title,
    String? description,
  });
}

class _CopyWithImpl$Input$TermsData<TRes>
    implements CopyWith$Input$TermsData<TRes> {
  _CopyWithImpl$Input$TermsData(
    this._instance,
    this._then,
  );

  final Input$TermsData _instance;

  final TRes Function(Input$TermsData) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TermsData._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$TermsData<TRes>
    implements CopyWith$Input$TermsData<TRes> {
  _CopyWithStubImpl$Input$TermsData(this._res);

  TRes _res;

  call({
    String? title,
    String? description,
  }) =>
      _res;
}

class Input$CMSPaginationInput {
  factory Input$CMSPaginationInput({
    required int offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$CMSPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$CMSPaginationInput._(this._$data);

  factory Input$CMSPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$CMSPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$CMSPaginationInput<Input$CMSPaginationInput> get copyWith =>
      CopyWith$Input$CMSPaginationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CMSPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$CMSPaginationInput<TRes> {
  factory CopyWith$Input$CMSPaginationInput(
    Input$CMSPaginationInput instance,
    TRes Function(Input$CMSPaginationInput) then,
  ) = _CopyWithImpl$Input$CMSPaginationInput;

  factory CopyWith$Input$CMSPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CMSPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$CMSPaginationInput<TRes>
    implements CopyWith$Input$CMSPaginationInput<TRes> {
  _CopyWithImpl$Input$CMSPaginationInput(
    this._instance,
    this._then,
  );

  final Input$CMSPaginationInput _instance;

  final TRes Function(Input$CMSPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$CMSPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$CMSPaginationInput<TRes>
    implements CopyWith$Input$CMSPaginationInput<TRes> {
  _CopyWithStubImpl$Input$CMSPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewCmsFrontInput {
  factory Input$viewCmsFrontInput({String? slug}) => Input$viewCmsFrontInput._({
        if (slug != null) r'slug': slug,
      });

  Input$viewCmsFrontInput._(this._$data);

  factory Input$viewCmsFrontInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('slug')) {
      final l$slug = data['slug'];
      result$data['slug'] = (l$slug as String?);
    }
    return Input$viewCmsFrontInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get slug => (_$data['slug'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('slug')) {
      final l$slug = slug;
      result$data['slug'] = l$slug;
    }
    return result$data;
  }

  CopyWith$Input$viewCmsFrontInput<Input$viewCmsFrontInput> get copyWith =>
      CopyWith$Input$viewCmsFrontInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewCmsFrontInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (_$data.containsKey('slug') != other._$data.containsKey('slug')) {
      return false;
    }
    if (l$slug != lOther$slug) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    return Object.hashAll([_$data.containsKey('slug') ? l$slug : const {}]);
  }
}

abstract class CopyWith$Input$viewCmsFrontInput<TRes> {
  factory CopyWith$Input$viewCmsFrontInput(
    Input$viewCmsFrontInput instance,
    TRes Function(Input$viewCmsFrontInput) then,
  ) = _CopyWithImpl$Input$viewCmsFrontInput;

  factory CopyWith$Input$viewCmsFrontInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewCmsFrontInput;

  TRes call({String? slug});
}

class _CopyWithImpl$Input$viewCmsFrontInput<TRes>
    implements CopyWith$Input$viewCmsFrontInput<TRes> {
  _CopyWithImpl$Input$viewCmsFrontInput(
    this._instance,
    this._then,
  );

  final Input$viewCmsFrontInput _instance;

  final TRes Function(Input$viewCmsFrontInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? slug = _undefined}) => _then(Input$viewCmsFrontInput._({
        ..._instance._$data,
        if (slug != _undefined) 'slug': (slug as String?),
      }));
}

class _CopyWithStubImpl$Input$viewCmsFrontInput<TRes>
    implements CopyWith$Input$viewCmsFrontInput<TRes> {
  _CopyWithStubImpl$Input$viewCmsFrontInput(this._res);

  TRes _res;

  call({String? slug}) => _res;
}

class Input$RatingPaginationInput {
  factory Input$RatingPaginationInput({
    required int offset,
    int? limit,
    String? rating,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$RatingPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (rating != null) r'rating': rating,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$RatingPaginationInput._(this._$data);

  factory Input$RatingPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$RatingPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get rating => (_$data['rating'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$RatingPaginationInput<Input$RatingPaginationInput>
      get copyWith => CopyWith$Input$RatingPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RatingPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$rating = rating;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$RatingPaginationInput<TRes> {
  factory CopyWith$Input$RatingPaginationInput(
    Input$RatingPaginationInput instance,
    TRes Function(Input$RatingPaginationInput) then,
  ) = _CopyWithImpl$Input$RatingPaginationInput;

  factory CopyWith$Input$RatingPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RatingPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? rating,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$RatingPaginationInput<TRes>
    implements CopyWith$Input$RatingPaginationInput<TRes> {
  _CopyWithImpl$Input$RatingPaginationInput(
    this._instance,
    this._then,
  );

  final Input$RatingPaginationInput _instance;

  final TRes Function(Input$RatingPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? rating = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$RatingPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$RatingPaginationInput<TRes>
    implements CopyWith$Input$RatingPaginationInput<TRes> {
  _CopyWithStubImpl$Input$RatingPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? rating,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewRatingInput {
  factory Input$viewRatingInput({String? uuid}) => Input$viewRatingInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewRatingInput._(this._$data);

  factory Input$viewRatingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewRatingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewRatingInput<Input$viewRatingInput> get copyWith =>
      CopyWith$Input$viewRatingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewRatingInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewRatingInput<TRes> {
  factory CopyWith$Input$viewRatingInput(
    Input$viewRatingInput instance,
    TRes Function(Input$viewRatingInput) then,
  ) = _CopyWithImpl$Input$viewRatingInput;

  factory CopyWith$Input$viewRatingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewRatingInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewRatingInput<TRes>
    implements CopyWith$Input$viewRatingInput<TRes> {
  _CopyWithImpl$Input$viewRatingInput(
    this._instance,
    this._then,
  );

  final Input$viewRatingInput _instance;

  final TRes Function(Input$viewRatingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewRatingInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewRatingInput<TRes>
    implements CopyWith$Input$viewRatingInput<TRes> {
  _CopyWithStubImpl$Input$viewRatingInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$RatingCreateInput {
  factory Input$RatingCreateInput({
    required String rating,
    String? details,
    String? status,
  }) =>
      Input$RatingCreateInput._({
        r'rating': rating,
        if (details != null) r'details': details,
        if (status != null) r'status': status,
      });

  Input$RatingCreateInput._(this._$data);

  factory Input$RatingCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$rating = data['rating'];
    result$data['rating'] = (l$rating as String);
    if (data.containsKey('details')) {
      final l$details = data['details'];
      result$data['details'] = (l$details as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$RatingCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get rating => (_$data['rating'] as String);

  String? get details => (_$data['details'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$rating = rating;
    result$data['rating'] = l$rating;
    if (_$data.containsKey('details')) {
      final l$details = details;
      result$data['details'] = l$details;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$RatingCreateInput<Input$RatingCreateInput> get copyWith =>
      CopyWith$Input$RatingCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RatingCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$details = details;
    final lOther$details = other.details;
    if (_$data.containsKey('details') != other._$data.containsKey('details')) {
      return false;
    }
    if (l$details != lOther$details) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$rating = rating;
    final l$details = details;
    final l$status = status;
    return Object.hashAll([
      l$rating,
      _$data.containsKey('details') ? l$details : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$RatingCreateInput<TRes> {
  factory CopyWith$Input$RatingCreateInput(
    Input$RatingCreateInput instance,
    TRes Function(Input$RatingCreateInput) then,
  ) = _CopyWithImpl$Input$RatingCreateInput;

  factory CopyWith$Input$RatingCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RatingCreateInput;

  TRes call({
    String? rating,
    String? details,
    String? status,
  });
}

class _CopyWithImpl$Input$RatingCreateInput<TRes>
    implements CopyWith$Input$RatingCreateInput<TRes> {
  _CopyWithImpl$Input$RatingCreateInput(
    this._instance,
    this._then,
  );

  final Input$RatingCreateInput _instance;

  final TRes Function(Input$RatingCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? rating = _undefined,
    Object? details = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$RatingCreateInput._({
        ..._instance._$data,
        if (rating != _undefined && rating != null)
          'rating': (rating as String),
        if (details != _undefined) 'details': (details as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$RatingCreateInput<TRes>
    implements CopyWith$Input$RatingCreateInput<TRes> {
  _CopyWithStubImpl$Input$RatingCreateInput(this._res);

  TRes _res;

  call({
    String? rating,
    String? details,
    String? status,
  }) =>
      _res;
}

class Input$UpdateRatingStatusInput {
  factory Input$UpdateRatingStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateRatingStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateRatingStatusInput._(this._$data);

  factory Input$UpdateRatingStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateRatingStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateRatingStatusInput<Input$UpdateRatingStatusInput>
      get copyWith => CopyWith$Input$UpdateRatingStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRatingStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRatingStatusInput<TRes> {
  factory CopyWith$Input$UpdateRatingStatusInput(
    Input$UpdateRatingStatusInput instance,
    TRes Function(Input$UpdateRatingStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateRatingStatusInput;

  factory CopyWith$Input$UpdateRatingStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRatingStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateRatingStatusInput<TRes>
    implements CopyWith$Input$UpdateRatingStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateRatingStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRatingStatusInput _instance;

  final TRes Function(Input$UpdateRatingStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateRatingStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateRatingStatusInput<TRes>
    implements CopyWith$Input$UpdateRatingStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRatingStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$RatingUpdateInput {
  factory Input$RatingUpdateInput({
    required String uuid,
    String? rating,
    String? status,
    String? details,
  }) =>
      Input$RatingUpdateInput._({
        r'uuid': uuid,
        if (rating != null) r'rating': rating,
        if (status != null) r'status': status,
        if (details != null) r'details': details,
      });

  Input$RatingUpdateInput._(this._$data);

  factory Input$RatingUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('details')) {
      final l$details = data['details'];
      result$data['details'] = (l$details as String?);
    }
    return Input$RatingUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get rating => (_$data['rating'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get details => (_$data['details'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('details')) {
      final l$details = details;
      result$data['details'] = l$details;
    }
    return result$data;
  }

  CopyWith$Input$RatingUpdateInput<Input$RatingUpdateInput> get copyWith =>
      CopyWith$Input$RatingUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RatingUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$details = details;
    final lOther$details = other.details;
    if (_$data.containsKey('details') != other._$data.containsKey('details')) {
      return false;
    }
    if (l$details != lOther$details) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$rating = rating;
    final l$status = status;
    final l$details = details;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('details') ? l$details : const {},
    ]);
  }
}

abstract class CopyWith$Input$RatingUpdateInput<TRes> {
  factory CopyWith$Input$RatingUpdateInput(
    Input$RatingUpdateInput instance,
    TRes Function(Input$RatingUpdateInput) then,
  ) = _CopyWithImpl$Input$RatingUpdateInput;

  factory CopyWith$Input$RatingUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RatingUpdateInput;

  TRes call({
    String? uuid,
    String? rating,
    String? status,
    String? details,
  });
}

class _CopyWithImpl$Input$RatingUpdateInput<TRes>
    implements CopyWith$Input$RatingUpdateInput<TRes> {
  _CopyWithImpl$Input$RatingUpdateInput(
    this._instance,
    this._then,
  );

  final Input$RatingUpdateInput _instance;

  final TRes Function(Input$RatingUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? rating = _undefined,
    Object? status = _undefined,
    Object? details = _undefined,
  }) =>
      _then(Input$RatingUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (rating != _undefined) 'rating': (rating as String?),
        if (status != _undefined) 'status': (status as String?),
        if (details != _undefined) 'details': (details as String?),
      }));
}

class _CopyWithStubImpl$Input$RatingUpdateInput<TRes>
    implements CopyWith$Input$RatingUpdateInput<TRes> {
  _CopyWithStubImpl$Input$RatingUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? rating,
    String? status,
    String? details,
  }) =>
      _res;
}

class Input$deleteRatingAdminInput {
  factory Input$deleteRatingAdminInput({required String uuid}) =>
      Input$deleteRatingAdminInput._({
        r'uuid': uuid,
      });

  Input$deleteRatingAdminInput._(this._$data);

  factory Input$deleteRatingAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteRatingAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteRatingAdminInput<Input$deleteRatingAdminInput>
      get copyWith => CopyWith$Input$deleteRatingAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteRatingAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteRatingAdminInput<TRes> {
  factory CopyWith$Input$deleteRatingAdminInput(
    Input$deleteRatingAdminInput instance,
    TRes Function(Input$deleteRatingAdminInput) then,
  ) = _CopyWithImpl$Input$deleteRatingAdminInput;

  factory CopyWith$Input$deleteRatingAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteRatingAdminInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteRatingAdminInput<TRes>
    implements CopyWith$Input$deleteRatingAdminInput<TRes> {
  _CopyWithImpl$Input$deleteRatingAdminInput(
    this._instance,
    this._then,
  );

  final Input$deleteRatingAdminInput _instance;

  final TRes Function(Input$deleteRatingAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$deleteRatingAdminInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteRatingAdminInput<TRes>
    implements CopyWith$Input$deleteRatingAdminInput<TRes> {
  _CopyWithStubImpl$Input$deleteRatingAdminInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$RecommenDataPaginationInput {
  factory Input$RecommenDataPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$RecommenDataPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$RecommenDataPaginationInput._(this._$data);

  factory Input$RecommenDataPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$RecommenDataPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$RecommenDataPaginationInput<Input$RecommenDataPaginationInput>
      get copyWith => CopyWith$Input$RecommenDataPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RecommenDataPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecommenDataPaginationInput<TRes> {
  factory CopyWith$Input$RecommenDataPaginationInput(
    Input$RecommenDataPaginationInput instance,
    TRes Function(Input$RecommenDataPaginationInput) then,
  ) = _CopyWithImpl$Input$RecommenDataPaginationInput;

  factory CopyWith$Input$RecommenDataPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecommenDataPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$RecommenDataPaginationInput<TRes>
    implements CopyWith$Input$RecommenDataPaginationInput<TRes> {
  _CopyWithImpl$Input$RecommenDataPaginationInput(
    this._instance,
    this._then,
  );

  final Input$RecommenDataPaginationInput _instance;

  final TRes Function(Input$RecommenDataPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$RecommenDataPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$RecommenDataPaginationInput<TRes>
    implements CopyWith$Input$RecommenDataPaginationInput<TRes> {
  _CopyWithStubImpl$Input$RecommenDataPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewRecommenInput {
  factory Input$viewRecommenInput({String? uuid}) => Input$viewRecommenInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewRecommenInput._(this._$data);

  factory Input$viewRecommenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewRecommenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewRecommenInput<Input$viewRecommenInput> get copyWith =>
      CopyWith$Input$viewRecommenInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewRecommenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewRecommenInput<TRes> {
  factory CopyWith$Input$viewRecommenInput(
    Input$viewRecommenInput instance,
    TRes Function(Input$viewRecommenInput) then,
  ) = _CopyWithImpl$Input$viewRecommenInput;

  factory CopyWith$Input$viewRecommenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewRecommenInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewRecommenInput<TRes>
    implements CopyWith$Input$viewRecommenInput<TRes> {
  _CopyWithImpl$Input$viewRecommenInput(
    this._instance,
    this._then,
  );

  final Input$viewRecommenInput _instance;

  final TRes Function(Input$viewRecommenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewRecommenInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewRecommenInput<TRes>
    implements CopyWith$Input$viewRecommenInput<TRes> {
  _CopyWithStubImpl$Input$viewRecommenInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$RecommenCreateInput {
  factory Input$RecommenCreateInput({
    int? min,
    int? max,
    String? label,
    String? status,
    String? description,
  }) =>
      Input$RecommenCreateInput._({
        if (min != null) r'min': min,
        if (max != null) r'max': max,
        if (label != null) r'label': label,
        if (status != null) r'status': status,
        if (description != null) r'description': description,
      });

  Input$RecommenCreateInput._(this._$data);

  factory Input$RecommenCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = (l$min as int?);
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = (l$max as int?);
    }
    if (data.containsKey('label')) {
      final l$label = data['label'];
      result$data['label'] = (l$label as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$RecommenCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get min => (_$data['min'] as int?);

  int? get max => (_$data['max'] as int?);

  String? get label => (_$data['label'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min;
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max;
    }
    if (_$data.containsKey('label')) {
      final l$label = label;
      result$data['label'] = l$label;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$RecommenCreateInput<Input$RecommenCreateInput> get copyWith =>
      CopyWith$Input$RecommenCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RecommenCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$label = label;
    final lOther$label = other.label;
    if (_$data.containsKey('label') != other._$data.containsKey('label')) {
      return false;
    }
    if (l$label != lOther$label) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$min = min;
    final l$max = max;
    final l$label = label;
    final l$status = status;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('label') ? l$label : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecommenCreateInput<TRes> {
  factory CopyWith$Input$RecommenCreateInput(
    Input$RecommenCreateInput instance,
    TRes Function(Input$RecommenCreateInput) then,
  ) = _CopyWithImpl$Input$RecommenCreateInput;

  factory CopyWith$Input$RecommenCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecommenCreateInput;

  TRes call({
    int? min,
    int? max,
    String? label,
    String? status,
    String? description,
  });
}

class _CopyWithImpl$Input$RecommenCreateInput<TRes>
    implements CopyWith$Input$RecommenCreateInput<TRes> {
  _CopyWithImpl$Input$RecommenCreateInput(
    this._instance,
    this._then,
  );

  final Input$RecommenCreateInput _instance;

  final TRes Function(Input$RecommenCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? min = _undefined,
    Object? max = _undefined,
    Object? label = _undefined,
    Object? status = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$RecommenCreateInput._({
        ..._instance._$data,
        if (min != _undefined) 'min': (min as int?),
        if (max != _undefined) 'max': (max as int?),
        if (label != _undefined) 'label': (label as String?),
        if (status != _undefined) 'status': (status as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$RecommenCreateInput<TRes>
    implements CopyWith$Input$RecommenCreateInput<TRes> {
  _CopyWithStubImpl$Input$RecommenCreateInput(this._res);

  TRes _res;

  call({
    int? min,
    int? max,
    String? label,
    String? status,
    String? description,
  }) =>
      _res;
}

class Input$RecommendationUpdateInput {
  factory Input$RecommendationUpdateInput({
    required String uuid,
    int? min,
    int? max,
    String? label,
    String? description,
    String? status,
  }) =>
      Input$RecommendationUpdateInput._({
        r'uuid': uuid,
        if (min != null) r'min': min,
        if (max != null) r'max': max,
        if (label != null) r'label': label,
        if (description != null) r'description': description,
        if (status != null) r'status': status,
      });

  Input$RecommendationUpdateInput._(this._$data);

  factory Input$RecommendationUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = (l$min as int?);
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = (l$max as int?);
    }
    if (data.containsKey('label')) {
      final l$label = data['label'];
      result$data['label'] = (l$label as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$RecommendationUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  int? get min => (_$data['min'] as int?);

  int? get max => (_$data['max'] as int?);

  String? get label => (_$data['label'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min;
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max;
    }
    if (_$data.containsKey('label')) {
      final l$label = label;
      result$data['label'] = l$label;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$RecommendationUpdateInput<Input$RecommendationUpdateInput>
      get copyWith => CopyWith$Input$RecommendationUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RecommendationUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$label = label;
    final lOther$label = other.label;
    if (_$data.containsKey('label') != other._$data.containsKey('label')) {
      return false;
    }
    if (l$label != lOther$label) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$min = min;
    final l$max = max;
    final l$label = label;
    final l$description = description;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('label') ? l$label : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$RecommendationUpdateInput<TRes> {
  factory CopyWith$Input$RecommendationUpdateInput(
    Input$RecommendationUpdateInput instance,
    TRes Function(Input$RecommendationUpdateInput) then,
  ) = _CopyWithImpl$Input$RecommendationUpdateInput;

  factory CopyWith$Input$RecommendationUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecommendationUpdateInput;

  TRes call({
    String? uuid,
    int? min,
    int? max,
    String? label,
    String? description,
    String? status,
  });
}

class _CopyWithImpl$Input$RecommendationUpdateInput<TRes>
    implements CopyWith$Input$RecommendationUpdateInput<TRes> {
  _CopyWithImpl$Input$RecommendationUpdateInput(
    this._instance,
    this._then,
  );

  final Input$RecommendationUpdateInput _instance;

  final TRes Function(Input$RecommendationUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? min = _undefined,
    Object? max = _undefined,
    Object? label = _undefined,
    Object? description = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$RecommendationUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (min != _undefined) 'min': (min as int?),
        if (max != _undefined) 'max': (max as int?),
        if (label != _undefined) 'label': (label as String?),
        if (description != _undefined) 'description': (description as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$RecommendationUpdateInput<TRes>
    implements CopyWith$Input$RecommendationUpdateInput<TRes> {
  _CopyWithStubImpl$Input$RecommendationUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? min,
    int? max,
    String? label,
    String? description,
    String? status,
  }) =>
      _res;
}

class Input$UpdateRecommenStatusInput {
  factory Input$UpdateRecommenStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateRecommenStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateRecommenStatusInput._(this._$data);

  factory Input$UpdateRecommenStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateRecommenStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateRecommenStatusInput<Input$UpdateRecommenStatusInput>
      get copyWith => CopyWith$Input$UpdateRecommenStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRecommenStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRecommenStatusInput<TRes> {
  factory CopyWith$Input$UpdateRecommenStatusInput(
    Input$UpdateRecommenStatusInput instance,
    TRes Function(Input$UpdateRecommenStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateRecommenStatusInput;

  factory CopyWith$Input$UpdateRecommenStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRecommenStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateRecommenStatusInput<TRes>
    implements CopyWith$Input$UpdateRecommenStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateRecommenStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRecommenStatusInput _instance;

  final TRes Function(Input$UpdateRecommenStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateRecommenStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateRecommenStatusInput<TRes>
    implements CopyWith$Input$UpdateRecommenStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRecommenStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$deleteRecommandInput {
  factory Input$deleteRecommandInput({required String uuid}) =>
      Input$deleteRecommandInput._({
        r'uuid': uuid,
      });

  Input$deleteRecommandInput._(this._$data);

  factory Input$deleteRecommandInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteRecommandInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteRecommandInput<Input$deleteRecommandInput>
      get copyWith => CopyWith$Input$deleteRecommandInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteRecommandInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteRecommandInput<TRes> {
  factory CopyWith$Input$deleteRecommandInput(
    Input$deleteRecommandInput instance,
    TRes Function(Input$deleteRecommandInput) then,
  ) = _CopyWithImpl$Input$deleteRecommandInput;

  factory CopyWith$Input$deleteRecommandInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteRecommandInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteRecommandInput<TRes>
    implements CopyWith$Input$deleteRecommandInput<TRes> {
  _CopyWithImpl$Input$deleteRecommandInput(
    this._instance,
    this._then,
  );

  final Input$deleteRecommandInput _instance;

  final TRes Function(Input$deleteRecommandInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteRecommandInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteRecommandInput<TRes>
    implements CopyWith$Input$deleteRecommandInput<TRes> {
  _CopyWithStubImpl$Input$deleteRecommandInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$PicklerPaginationInput {
  factory Input$PicklerPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$PicklerPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$PicklerPaginationInput._(this._$data);

  factory Input$PicklerPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$PicklerPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$PicklerPaginationInput<Input$PicklerPaginationInput>
      get copyWith => CopyWith$Input$PicklerPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PicklerPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$PicklerPaginationInput<TRes> {
  factory CopyWith$Input$PicklerPaginationInput(
    Input$PicklerPaginationInput instance,
    TRes Function(Input$PicklerPaginationInput) then,
  ) = _CopyWithImpl$Input$PicklerPaginationInput;

  factory CopyWith$Input$PicklerPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PicklerPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$PicklerPaginationInput<TRes>
    implements CopyWith$Input$PicklerPaginationInput<TRes> {
  _CopyWithImpl$Input$PicklerPaginationInput(
    this._instance,
    this._then,
  );

  final Input$PicklerPaginationInput _instance;

  final TRes Function(Input$PicklerPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$PicklerPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$PicklerPaginationInput<TRes>
    implements CopyWith$Input$PicklerPaginationInput<TRes> {
  _CopyWithStubImpl$Input$PicklerPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewPickerInput {
  factory Input$viewPickerInput({String? uuid}) => Input$viewPickerInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewPickerInput._(this._$data);

  factory Input$viewPickerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewPickerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewPickerInput<Input$viewPickerInput> get copyWith =>
      CopyWith$Input$viewPickerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewPickerInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewPickerInput<TRes> {
  factory CopyWith$Input$viewPickerInput(
    Input$viewPickerInput instance,
    TRes Function(Input$viewPickerInput) then,
  ) = _CopyWithImpl$Input$viewPickerInput;

  factory CopyWith$Input$viewPickerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewPickerInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewPickerInput<TRes>
    implements CopyWith$Input$viewPickerInput<TRes> {
  _CopyWithImpl$Input$viewPickerInput(
    this._instance,
    this._then,
  );

  final Input$viewPickerInput _instance;

  final TRes Function(Input$viewPickerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewPickerInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewPickerInput<TRes>
    implements CopyWith$Input$viewPickerInput<TRes> {
  _CopyWithStubImpl$Input$viewPickerInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$PicklerCreateInput {
  factory Input$PicklerCreateInput({
    required String name,
    String? status,
  }) =>
      Input$PicklerCreateInput._({
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$PicklerCreateInput._(this._$data);

  factory Input$PicklerCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$PicklerCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$PicklerCreateInput<Input$PicklerCreateInput> get copyWith =>
      CopyWith$Input$PicklerCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PicklerCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$PicklerCreateInput<TRes> {
  factory CopyWith$Input$PicklerCreateInput(
    Input$PicklerCreateInput instance,
    TRes Function(Input$PicklerCreateInput) then,
  ) = _CopyWithImpl$Input$PicklerCreateInput;

  factory CopyWith$Input$PicklerCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PicklerCreateInput;

  TRes call({
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$PicklerCreateInput<TRes>
    implements CopyWith$Input$PicklerCreateInput<TRes> {
  _CopyWithImpl$Input$PicklerCreateInput(
    this._instance,
    this._then,
  );

  final Input$PicklerCreateInput _instance;

  final TRes Function(Input$PicklerCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$PicklerCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$PicklerCreateInput<TRes>
    implements CopyWith$Input$PicklerCreateInput<TRes> {
  _CopyWithStubImpl$Input$PicklerCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$UpdatePicklerStatusInput {
  factory Input$UpdatePicklerStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdatePicklerStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdatePicklerStatusInput._(this._$data);

  factory Input$UpdatePicklerStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdatePicklerStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdatePicklerStatusInput<Input$UpdatePicklerStatusInput>
      get copyWith => CopyWith$Input$UpdatePicklerStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePicklerStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePicklerStatusInput<TRes> {
  factory CopyWith$Input$UpdatePicklerStatusInput(
    Input$UpdatePicklerStatusInput instance,
    TRes Function(Input$UpdatePicklerStatusInput) then,
  ) = _CopyWithImpl$Input$UpdatePicklerStatusInput;

  factory CopyWith$Input$UpdatePicklerStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePicklerStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdatePicklerStatusInput<TRes>
    implements CopyWith$Input$UpdatePicklerStatusInput<TRes> {
  _CopyWithImpl$Input$UpdatePicklerStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePicklerStatusInput _instance;

  final TRes Function(Input$UpdatePicklerStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdatePicklerStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePicklerStatusInput<TRes>
    implements CopyWith$Input$UpdatePicklerStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePicklerStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$PicklerUpdateInput {
  factory Input$PicklerUpdateInput({
    required String uuid,
    required String name,
    String? status,
  }) =>
      Input$PicklerUpdateInput._({
        r'uuid': uuid,
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$PicklerUpdateInput._(this._$data);

  factory Input$PicklerUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$PicklerUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$PicklerUpdateInput<Input$PicklerUpdateInput> get copyWith =>
      CopyWith$Input$PicklerUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PicklerUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$PicklerUpdateInput<TRes> {
  factory CopyWith$Input$PicklerUpdateInput(
    Input$PicklerUpdateInput instance,
    TRes Function(Input$PicklerUpdateInput) then,
  ) = _CopyWithImpl$Input$PicklerUpdateInput;

  factory CopyWith$Input$PicklerUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PicklerUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$PicklerUpdateInput<TRes>
    implements CopyWith$Input$PicklerUpdateInput<TRes> {
  _CopyWithImpl$Input$PicklerUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PicklerUpdateInput _instance;

  final TRes Function(Input$PicklerUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$PicklerUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$PicklerUpdateInput<TRes>
    implements CopyWith$Input$PicklerUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PicklerUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$DeletePicklerInput {
  factory Input$DeletePicklerInput({required String uuid}) =>
      Input$DeletePicklerInput._({
        r'uuid': uuid,
      });

  Input$DeletePicklerInput._(this._$data);

  factory Input$DeletePicklerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeletePicklerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeletePicklerInput<Input$DeletePicklerInput> get copyWith =>
      CopyWith$Input$DeletePicklerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePicklerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeletePicklerInput<TRes> {
  factory CopyWith$Input$DeletePicklerInput(
    Input$DeletePicklerInput instance,
    TRes Function(Input$DeletePicklerInput) then,
  ) = _CopyWithImpl$Input$DeletePicklerInput;

  factory CopyWith$Input$DeletePicklerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePicklerInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeletePicklerInput<TRes>
    implements CopyWith$Input$DeletePicklerInput<TRes> {
  _CopyWithImpl$Input$DeletePicklerInput(
    this._instance,
    this._then,
  );

  final Input$DeletePicklerInput _instance;

  final TRes Function(Input$DeletePicklerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeletePicklerInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePicklerInput<TRes>
    implements CopyWith$Input$DeletePicklerInput<TRes> {
  _CopyWithStubImpl$Input$DeletePicklerInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$GroupTypesPaginationInput {
  factory Input$GroupTypesPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$GroupTypesPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$GroupTypesPaginationInput._(this._$data);

  factory Input$GroupTypesPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$GroupTypesPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$GroupTypesPaginationInput<Input$GroupTypesPaginationInput>
      get copyWith => CopyWith$Input$GroupTypesPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupTypesPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$GroupTypesPaginationInput<TRes> {
  factory CopyWith$Input$GroupTypesPaginationInput(
    Input$GroupTypesPaginationInput instance,
    TRes Function(Input$GroupTypesPaginationInput) then,
  ) = _CopyWithImpl$Input$GroupTypesPaginationInput;

  factory CopyWith$Input$GroupTypesPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupTypesPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$GroupTypesPaginationInput<TRes>
    implements CopyWith$Input$GroupTypesPaginationInput<TRes> {
  _CopyWithImpl$Input$GroupTypesPaginationInput(
    this._instance,
    this._then,
  );

  final Input$GroupTypesPaginationInput _instance;

  final TRes Function(Input$GroupTypesPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$GroupTypesPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$GroupTypesPaginationInput<TRes>
    implements CopyWith$Input$GroupTypesPaginationInput<TRes> {
  _CopyWithStubImpl$Input$GroupTypesPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewGroupTypeInput {
  factory Input$viewGroupTypeInput({String? uuid}) =>
      Input$viewGroupTypeInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewGroupTypeInput._(this._$data);

  factory Input$viewGroupTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewGroupTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewGroupTypeInput<Input$viewGroupTypeInput> get copyWith =>
      CopyWith$Input$viewGroupTypeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewGroupTypeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewGroupTypeInput<TRes> {
  factory CopyWith$Input$viewGroupTypeInput(
    Input$viewGroupTypeInput instance,
    TRes Function(Input$viewGroupTypeInput) then,
  ) = _CopyWithImpl$Input$viewGroupTypeInput;

  factory CopyWith$Input$viewGroupTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewGroupTypeInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewGroupTypeInput<TRes>
    implements CopyWith$Input$viewGroupTypeInput<TRes> {
  _CopyWithImpl$Input$viewGroupTypeInput(
    this._instance,
    this._then,
  );

  final Input$viewGroupTypeInput _instance;

  final TRes Function(Input$viewGroupTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewGroupTypeInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewGroupTypeInput<TRes>
    implements CopyWith$Input$viewGroupTypeInput<TRes> {
  _CopyWithStubImpl$Input$viewGroupTypeInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$groupTypeCreateInput {
  factory Input$groupTypeCreateInput({
    required String name,
    String? status,
  }) =>
      Input$groupTypeCreateInput._({
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$groupTypeCreateInput._(this._$data);

  factory Input$groupTypeCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$groupTypeCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$groupTypeCreateInput<Input$groupTypeCreateInput>
      get copyWith => CopyWith$Input$groupTypeCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$groupTypeCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$groupTypeCreateInput<TRes> {
  factory CopyWith$Input$groupTypeCreateInput(
    Input$groupTypeCreateInput instance,
    TRes Function(Input$groupTypeCreateInput) then,
  ) = _CopyWithImpl$Input$groupTypeCreateInput;

  factory CopyWith$Input$groupTypeCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$groupTypeCreateInput;

  TRes call({
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$groupTypeCreateInput<TRes>
    implements CopyWith$Input$groupTypeCreateInput<TRes> {
  _CopyWithImpl$Input$groupTypeCreateInput(
    this._instance,
    this._then,
  );

  final Input$groupTypeCreateInput _instance;

  final TRes Function(Input$groupTypeCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$groupTypeCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$groupTypeCreateInput<TRes>
    implements CopyWith$Input$groupTypeCreateInput<TRes> {
  _CopyWithStubImpl$Input$groupTypeCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$UpdateGTypeStatusInput {
  factory Input$UpdateGTypeStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateGTypeStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateGTypeStatusInput._(this._$data);

  factory Input$UpdateGTypeStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateGTypeStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateGTypeStatusInput<Input$UpdateGTypeStatusInput>
      get copyWith => CopyWith$Input$UpdateGTypeStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateGTypeStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateGTypeStatusInput<TRes> {
  factory CopyWith$Input$UpdateGTypeStatusInput(
    Input$UpdateGTypeStatusInput instance,
    TRes Function(Input$UpdateGTypeStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateGTypeStatusInput;

  factory CopyWith$Input$UpdateGTypeStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateGTypeStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateGTypeStatusInput<TRes>
    implements CopyWith$Input$UpdateGTypeStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateGTypeStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateGTypeStatusInput _instance;

  final TRes Function(Input$UpdateGTypeStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateGTypeStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateGTypeStatusInput<TRes>
    implements CopyWith$Input$UpdateGTypeStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateGTypeStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$GTypeUpdateInput {
  factory Input$GTypeUpdateInput({
    required String uuid,
    required String name,
    String? status,
  }) =>
      Input$GTypeUpdateInput._({
        r'uuid': uuid,
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$GTypeUpdateInput._(this._$data);

  factory Input$GTypeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$GTypeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$GTypeUpdateInput<Input$GTypeUpdateInput> get copyWith =>
      CopyWith$Input$GTypeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GTypeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$GTypeUpdateInput<TRes> {
  factory CopyWith$Input$GTypeUpdateInput(
    Input$GTypeUpdateInput instance,
    TRes Function(Input$GTypeUpdateInput) then,
  ) = _CopyWithImpl$Input$GTypeUpdateInput;

  factory CopyWith$Input$GTypeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GTypeUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$GTypeUpdateInput<TRes>
    implements CopyWith$Input$GTypeUpdateInput<TRes> {
  _CopyWithImpl$Input$GTypeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GTypeUpdateInput _instance;

  final TRes Function(Input$GTypeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$GTypeUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$GTypeUpdateInput<TRes>
    implements CopyWith$Input$GTypeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GTypeUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$DeleteGroupTypeInput {
  factory Input$DeleteGroupTypeInput({required String uuid}) =>
      Input$DeleteGroupTypeInput._({
        r'uuid': uuid,
      });

  Input$DeleteGroupTypeInput._(this._$data);

  factory Input$DeleteGroupTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteGroupTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteGroupTypeInput<Input$DeleteGroupTypeInput>
      get copyWith => CopyWith$Input$DeleteGroupTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteGroupTypeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteGroupTypeInput<TRes> {
  factory CopyWith$Input$DeleteGroupTypeInput(
    Input$DeleteGroupTypeInput instance,
    TRes Function(Input$DeleteGroupTypeInput) then,
  ) = _CopyWithImpl$Input$DeleteGroupTypeInput;

  factory CopyWith$Input$DeleteGroupTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteGroupTypeInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteGroupTypeInput<TRes>
    implements CopyWith$Input$DeleteGroupTypeInput<TRes> {
  _CopyWithImpl$Input$DeleteGroupTypeInput(
    this._instance,
    this._then,
  );

  final Input$DeleteGroupTypeInput _instance;

  final TRes Function(Input$DeleteGroupTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteGroupTypeInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteGroupTypeInput<TRes>
    implements CopyWith$Input$DeleteGroupTypeInput<TRes> {
  _CopyWithStubImpl$Input$DeleteGroupTypeInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$BadgesPaginationInput {
  factory Input$BadgesPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$BadgesPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$BadgesPaginationInput._(this._$data);

  factory Input$BadgesPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$BadgesPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$BadgesPaginationInput<Input$BadgesPaginationInput>
      get copyWith => CopyWith$Input$BadgesPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BadgesPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$BadgesPaginationInput<TRes> {
  factory CopyWith$Input$BadgesPaginationInput(
    Input$BadgesPaginationInput instance,
    TRes Function(Input$BadgesPaginationInput) then,
  ) = _CopyWithImpl$Input$BadgesPaginationInput;

  factory CopyWith$Input$BadgesPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BadgesPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$BadgesPaginationInput<TRes>
    implements CopyWith$Input$BadgesPaginationInput<TRes> {
  _CopyWithImpl$Input$BadgesPaginationInput(
    this._instance,
    this._then,
  );

  final Input$BadgesPaginationInput _instance;

  final TRes Function(Input$BadgesPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$BadgesPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$BadgesPaginationInput<TRes>
    implements CopyWith$Input$BadgesPaginationInput<TRes> {
  _CopyWithStubImpl$Input$BadgesPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewBadgesInput {
  factory Input$viewBadgesInput({String? uuid}) => Input$viewBadgesInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewBadgesInput._(this._$data);

  factory Input$viewBadgesInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewBadgesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewBadgesInput<Input$viewBadgesInput> get copyWith =>
      CopyWith$Input$viewBadgesInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewBadgesInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewBadgesInput<TRes> {
  factory CopyWith$Input$viewBadgesInput(
    Input$viewBadgesInput instance,
    TRes Function(Input$viewBadgesInput) then,
  ) = _CopyWithImpl$Input$viewBadgesInput;

  factory CopyWith$Input$viewBadgesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewBadgesInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewBadgesInput<TRes>
    implements CopyWith$Input$viewBadgesInput<TRes> {
  _CopyWithImpl$Input$viewBadgesInput(
    this._instance,
    this._then,
  );

  final Input$viewBadgesInput _instance;

  final TRes Function(Input$viewBadgesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewBadgesInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewBadgesInput<TRes>
    implements CopyWith$Input$viewBadgesInput<TRes> {
  _CopyWithStubImpl$Input$viewBadgesInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$badgeCreateInput {
  factory Input$badgeCreateInput({
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  }) =>
      Input$badgeCreateInput._({
        if (name != null) r'name': name,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (status != null) r'status': status,
        if (description != null) r'description': description,
        if (image_disable != null) r'image_disable': image_disable,
        if (file_path_disable != null) r'file_path_disable': file_path_disable,
      });

  Input$badgeCreateInput._(this._$data);

  factory Input$badgeCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('image_disable')) {
      final l$image_disable = data['image_disable'];
      result$data['image_disable'] = (l$image_disable as String?);
    }
    if (data.containsKey('file_path_disable')) {
      final l$file_path_disable = data['file_path_disable'];
      result$data['file_path_disable'] = (l$file_path_disable as String?);
    }
    return Input$badgeCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get image_disable => (_$data['image_disable'] as String?);

  String? get file_path_disable => (_$data['file_path_disable'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('image_disable')) {
      final l$image_disable = image_disable;
      result$data['image_disable'] = l$image_disable;
    }
    if (_$data.containsKey('file_path_disable')) {
      final l$file_path_disable = file_path_disable;
      result$data['file_path_disable'] = l$file_path_disable;
    }
    return result$data;
  }

  CopyWith$Input$badgeCreateInput<Input$badgeCreateInput> get copyWith =>
      CopyWith$Input$badgeCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$badgeCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$image_disable = image_disable;
    final lOther$image_disable = other.image_disable;
    if (_$data.containsKey('image_disable') !=
        other._$data.containsKey('image_disable')) {
      return false;
    }
    if (l$image_disable != lOther$image_disable) {
      return false;
    }
    final l$file_path_disable = file_path_disable;
    final lOther$file_path_disable = other.file_path_disable;
    if (_$data.containsKey('file_path_disable') !=
        other._$data.containsKey('file_path_disable')) {
      return false;
    }
    if (l$file_path_disable != lOther$file_path_disable) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$image = image;
    final l$file_path = file_path;
    final l$status = status;
    final l$description = description;
    final l$image_disable = image_disable;
    final l$file_path_disable = file_path_disable;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('image_disable') ? l$image_disable : const {},
      _$data.containsKey('file_path_disable') ? l$file_path_disable : const {},
    ]);
  }
}

abstract class CopyWith$Input$badgeCreateInput<TRes> {
  factory CopyWith$Input$badgeCreateInput(
    Input$badgeCreateInput instance,
    TRes Function(Input$badgeCreateInput) then,
  ) = _CopyWithImpl$Input$badgeCreateInput;

  factory CopyWith$Input$badgeCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$badgeCreateInput;

  TRes call({
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  });
}

class _CopyWithImpl$Input$badgeCreateInput<TRes>
    implements CopyWith$Input$badgeCreateInput<TRes> {
  _CopyWithImpl$Input$badgeCreateInput(
    this._instance,
    this._then,
  );

  final Input$badgeCreateInput _instance;

  final TRes Function(Input$badgeCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? status = _undefined,
    Object? description = _undefined,
    Object? image_disable = _undefined,
    Object? file_path_disable = _undefined,
  }) =>
      _then(Input$badgeCreateInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (status != _undefined) 'status': (status as String?),
        if (description != _undefined) 'description': (description as String?),
        if (image_disable != _undefined)
          'image_disable': (image_disable as String?),
        if (file_path_disable != _undefined)
          'file_path_disable': (file_path_disable as String?),
      }));
}

class _CopyWithStubImpl$Input$badgeCreateInput<TRes>
    implements CopyWith$Input$badgeCreateInput<TRes> {
  _CopyWithStubImpl$Input$badgeCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  }) =>
      _res;
}

class Input$UpdateBadgeStatusInput {
  factory Input$UpdateBadgeStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateBadgeStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateBadgeStatusInput._(this._$data);

  factory Input$UpdateBadgeStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateBadgeStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateBadgeStatusInput<Input$UpdateBadgeStatusInput>
      get copyWith => CopyWith$Input$UpdateBadgeStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBadgeStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateBadgeStatusInput<TRes> {
  factory CopyWith$Input$UpdateBadgeStatusInput(
    Input$UpdateBadgeStatusInput instance,
    TRes Function(Input$UpdateBadgeStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateBadgeStatusInput;

  factory CopyWith$Input$UpdateBadgeStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBadgeStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateBadgeStatusInput<TRes>
    implements CopyWith$Input$UpdateBadgeStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateBadgeStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBadgeStatusInput _instance;

  final TRes Function(Input$UpdateBadgeStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateBadgeStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateBadgeStatusInput<TRes>
    implements CopyWith$Input$UpdateBadgeStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBadgeStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$BadgeUpdateInput {
  factory Input$BadgeUpdateInput({
    String? uuid,
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  }) =>
      Input$BadgeUpdateInput._({
        if (uuid != null) r'uuid': uuid,
        if (name != null) r'name': name,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (status != null) r'status': status,
        if (description != null) r'description': description,
        if (image_disable != null) r'image_disable': image_disable,
        if (file_path_disable != null) r'file_path_disable': file_path_disable,
      });

  Input$BadgeUpdateInput._(this._$data);

  factory Input$BadgeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('image_disable')) {
      final l$image_disable = data['image_disable'];
      result$data['image_disable'] = (l$image_disable as String?);
    }
    if (data.containsKey('file_path_disable')) {
      final l$file_path_disable = data['file_path_disable'];
      result$data['file_path_disable'] = (l$file_path_disable as String?);
    }
    return Input$BadgeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get image_disable => (_$data['image_disable'] as String?);

  String? get file_path_disable => (_$data['file_path_disable'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('image_disable')) {
      final l$image_disable = image_disable;
      result$data['image_disable'] = l$image_disable;
    }
    if (_$data.containsKey('file_path_disable')) {
      final l$file_path_disable = file_path_disable;
      result$data['file_path_disable'] = l$file_path_disable;
    }
    return result$data;
  }

  CopyWith$Input$BadgeUpdateInput<Input$BadgeUpdateInput> get copyWith =>
      CopyWith$Input$BadgeUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BadgeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$image_disable = image_disable;
    final lOther$image_disable = other.image_disable;
    if (_$data.containsKey('image_disable') !=
        other._$data.containsKey('image_disable')) {
      return false;
    }
    if (l$image_disable != lOther$image_disable) {
      return false;
    }
    final l$file_path_disable = file_path_disable;
    final lOther$file_path_disable = other.file_path_disable;
    if (_$data.containsKey('file_path_disable') !=
        other._$data.containsKey('file_path_disable')) {
      return false;
    }
    if (l$file_path_disable != lOther$file_path_disable) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$image = image;
    final l$file_path = file_path;
    final l$status = status;
    final l$description = description;
    final l$image_disable = image_disable;
    final l$file_path_disable = file_path_disable;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('image_disable') ? l$image_disable : const {},
      _$data.containsKey('file_path_disable') ? l$file_path_disable : const {},
    ]);
  }
}

abstract class CopyWith$Input$BadgeUpdateInput<TRes> {
  factory CopyWith$Input$BadgeUpdateInput(
    Input$BadgeUpdateInput instance,
    TRes Function(Input$BadgeUpdateInput) then,
  ) = _CopyWithImpl$Input$BadgeUpdateInput;

  factory CopyWith$Input$BadgeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BadgeUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  });
}

class _CopyWithImpl$Input$BadgeUpdateInput<TRes>
    implements CopyWith$Input$BadgeUpdateInput<TRes> {
  _CopyWithImpl$Input$BadgeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$BadgeUpdateInput _instance;

  final TRes Function(Input$BadgeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? status = _undefined,
    Object? description = _undefined,
    Object? image_disable = _undefined,
    Object? file_path_disable = _undefined,
  }) =>
      _then(Input$BadgeUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (name != _undefined) 'name': (name as String?),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (status != _undefined) 'status': (status as String?),
        if (description != _undefined) 'description': (description as String?),
        if (image_disable != _undefined)
          'image_disable': (image_disable as String?),
        if (file_path_disable != _undefined)
          'file_path_disable': (file_path_disable as String?),
      }));
}

class _CopyWithStubImpl$Input$BadgeUpdateInput<TRes>
    implements CopyWith$Input$BadgeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$BadgeUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? image,
    String? file_path,
    String? status,
    String? description,
    String? image_disable,
    String? file_path_disable,
  }) =>
      _res;
}

class Input$deleteBadgesAdminInput {
  factory Input$deleteBadgesAdminInput({required String uuid}) =>
      Input$deleteBadgesAdminInput._({
        r'uuid': uuid,
      });

  Input$deleteBadgesAdminInput._(this._$data);

  factory Input$deleteBadgesAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteBadgesAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteBadgesAdminInput<Input$deleteBadgesAdminInput>
      get copyWith => CopyWith$Input$deleteBadgesAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteBadgesAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteBadgesAdminInput<TRes> {
  factory CopyWith$Input$deleteBadgesAdminInput(
    Input$deleteBadgesAdminInput instance,
    TRes Function(Input$deleteBadgesAdminInput) then,
  ) = _CopyWithImpl$Input$deleteBadgesAdminInput;

  factory CopyWith$Input$deleteBadgesAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteBadgesAdminInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteBadgesAdminInput<TRes>
    implements CopyWith$Input$deleteBadgesAdminInput<TRes> {
  _CopyWithImpl$Input$deleteBadgesAdminInput(
    this._instance,
    this._then,
  );

  final Input$deleteBadgesAdminInput _instance;

  final TRes Function(Input$deleteBadgesAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$deleteBadgesAdminInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteBadgesAdminInput<TRes>
    implements CopyWith$Input$deleteBadgesAdminInput<TRes> {
  _CopyWithStubImpl$Input$deleteBadgesAdminInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CetegoryPaginationInput {
  factory Input$CetegoryPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$CetegoryPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$CetegoryPaginationInput._(this._$data);

  factory Input$CetegoryPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$CetegoryPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$CetegoryPaginationInput<Input$CetegoryPaginationInput>
      get copyWith => CopyWith$Input$CetegoryPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CetegoryPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$CetegoryPaginationInput<TRes> {
  factory CopyWith$Input$CetegoryPaginationInput(
    Input$CetegoryPaginationInput instance,
    TRes Function(Input$CetegoryPaginationInput) then,
  ) = _CopyWithImpl$Input$CetegoryPaginationInput;

  factory CopyWith$Input$CetegoryPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CetegoryPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$CetegoryPaginationInput<TRes>
    implements CopyWith$Input$CetegoryPaginationInput<TRes> {
  _CopyWithImpl$Input$CetegoryPaginationInput(
    this._instance,
    this._then,
  );

  final Input$CetegoryPaginationInput _instance;

  final TRes Function(Input$CetegoryPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$CetegoryPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$CetegoryPaginationInput<TRes>
    implements CopyWith$Input$CetegoryPaginationInput<TRes> {
  _CopyWithStubImpl$Input$CetegoryPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewCategoryInput {
  factory Input$viewCategoryInput({String? uuid}) => Input$viewCategoryInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewCategoryInput._(this._$data);

  factory Input$viewCategoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewCategoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewCategoryInput<Input$viewCategoryInput> get copyWith =>
      CopyWith$Input$viewCategoryInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewCategoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewCategoryInput<TRes> {
  factory CopyWith$Input$viewCategoryInput(
    Input$viewCategoryInput instance,
    TRes Function(Input$viewCategoryInput) then,
  ) = _CopyWithImpl$Input$viewCategoryInput;

  factory CopyWith$Input$viewCategoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewCategoryInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewCategoryInput<TRes>
    implements CopyWith$Input$viewCategoryInput<TRes> {
  _CopyWithImpl$Input$viewCategoryInput(
    this._instance,
    this._then,
  );

  final Input$viewCategoryInput _instance;

  final TRes Function(Input$viewCategoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewCategoryInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewCategoryInput<TRes>
    implements CopyWith$Input$viewCategoryInput<TRes> {
  _CopyWithStubImpl$Input$viewCategoryInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CategoryCreateInput {
  factory Input$CategoryCreateInput({
    required String name,
    String? status,
  }) =>
      Input$CategoryCreateInput._({
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$CategoryCreateInput._(this._$data);

  factory Input$CategoryCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$CategoryCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$CategoryCreateInput<Input$CategoryCreateInput> get copyWith =>
      CopyWith$Input$CategoryCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CategoryCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryCreateInput<TRes> {
  factory CopyWith$Input$CategoryCreateInput(
    Input$CategoryCreateInput instance,
    TRes Function(Input$CategoryCreateInput) then,
  ) = _CopyWithImpl$Input$CategoryCreateInput;

  factory CopyWith$Input$CategoryCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryCreateInput;

  TRes call({
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$CategoryCreateInput<TRes>
    implements CopyWith$Input$CategoryCreateInput<TRes> {
  _CopyWithImpl$Input$CategoryCreateInput(
    this._instance,
    this._then,
  );

  final Input$CategoryCreateInput _instance;

  final TRes Function(Input$CategoryCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CategoryCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$CategoryCreateInput<TRes>
    implements CopyWith$Input$CategoryCreateInput<TRes> {
  _CopyWithStubImpl$Input$CategoryCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$UpdateCategoryStatusInput {
  factory Input$UpdateCategoryStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateCategoryStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateCategoryStatusInput._(this._$data);

  factory Input$UpdateCategoryStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateCategoryStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateCategoryStatusInput<Input$UpdateCategoryStatusInput>
      get copyWith => CopyWith$Input$UpdateCategoryStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCategoryStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateCategoryStatusInput<TRes> {
  factory CopyWith$Input$UpdateCategoryStatusInput(
    Input$UpdateCategoryStatusInput instance,
    TRes Function(Input$UpdateCategoryStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateCategoryStatusInput;

  factory CopyWith$Input$UpdateCategoryStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCategoryStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateCategoryStatusInput<TRes>
    implements CopyWith$Input$UpdateCategoryStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateCategoryStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCategoryStatusInput _instance;

  final TRes Function(Input$UpdateCategoryStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateCategoryStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateCategoryStatusInput<TRes>
    implements CopyWith$Input$UpdateCategoryStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCategoryStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$CategoryUpdateInput {
  factory Input$CategoryUpdateInput({
    String? uuid,
    String? name,
    String? status,
  }) =>
      Input$CategoryUpdateInput._({
        if (uuid != null) r'uuid': uuid,
        if (name != null) r'name': name,
        if (status != null) r'status': status,
      });

  Input$CategoryUpdateInput._(this._$data);

  factory Input$CategoryUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$CategoryUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$CategoryUpdateInput<Input$CategoryUpdateInput> get copyWith =>
      CopyWith$Input$CategoryUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CategoryUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$CategoryUpdateInput<TRes> {
  factory CopyWith$Input$CategoryUpdateInput(
    Input$CategoryUpdateInput instance,
    TRes Function(Input$CategoryUpdateInput) then,
  ) = _CopyWithImpl$Input$CategoryUpdateInput;

  factory CopyWith$Input$CategoryUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CategoryUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$CategoryUpdateInput<TRes>
    implements CopyWith$Input$CategoryUpdateInput<TRes> {
  _CopyWithImpl$Input$CategoryUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CategoryUpdateInput _instance;

  final TRes Function(Input$CategoryUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CategoryUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (name != _undefined) 'name': (name as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$CategoryUpdateInput<TRes>
    implements CopyWith$Input$CategoryUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CategoryUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$DeleteCategoryInput {
  factory Input$DeleteCategoryInput({required String uuid}) =>
      Input$DeleteCategoryInput._({
        r'uuid': uuid,
      });

  Input$DeleteCategoryInput._(this._$data);

  factory Input$DeleteCategoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteCategoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteCategoryInput<Input$DeleteCategoryInput> get copyWith =>
      CopyWith$Input$DeleteCategoryInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteCategoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteCategoryInput<TRes> {
  factory CopyWith$Input$DeleteCategoryInput(
    Input$DeleteCategoryInput instance,
    TRes Function(Input$DeleteCategoryInput) then,
  ) = _CopyWithImpl$Input$DeleteCategoryInput;

  factory CopyWith$Input$DeleteCategoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteCategoryInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteCategoryInput<TRes>
    implements CopyWith$Input$DeleteCategoryInput<TRes> {
  _CopyWithImpl$Input$DeleteCategoryInput(
    this._instance,
    this._then,
  );

  final Input$DeleteCategoryInput _instance;

  final TRes Function(Input$DeleteCategoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteCategoryInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteCategoryInput<TRes>
    implements CopyWith$Input$DeleteCategoryInput<TRes> {
  _CopyWithStubImpl$Input$DeleteCategoryInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ReasonPaginationInput {
  factory Input$ReasonPaginationInput({
    required int offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$ReasonPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$ReasonPaginationInput._(this._$data);

  factory Input$ReasonPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$ReasonPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$ReasonPaginationInput<Input$ReasonPaginationInput>
      get copyWith => CopyWith$Input$ReasonPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReasonPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReasonPaginationInput<TRes> {
  factory CopyWith$Input$ReasonPaginationInput(
    Input$ReasonPaginationInput instance,
    TRes Function(Input$ReasonPaginationInput) then,
  ) = _CopyWithImpl$Input$ReasonPaginationInput;

  factory CopyWith$Input$ReasonPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReasonPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$ReasonPaginationInput<TRes>
    implements CopyWith$Input$ReasonPaginationInput<TRes> {
  _CopyWithImpl$Input$ReasonPaginationInput(
    this._instance,
    this._then,
  );

  final Input$ReasonPaginationInput _instance;

  final TRes Function(Input$ReasonPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$ReasonPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$ReasonPaginationInput<TRes>
    implements CopyWith$Input$ReasonPaginationInput<TRes> {
  _CopyWithStubImpl$Input$ReasonPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewReasonInput {
  factory Input$viewReasonInput({String? uuid}) => Input$viewReasonInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$viewReasonInput._(this._$data);

  factory Input$viewReasonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$viewReasonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$viewReasonInput<Input$viewReasonInput> get copyWith =>
      CopyWith$Input$viewReasonInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewReasonInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$viewReasonInput<TRes> {
  factory CopyWith$Input$viewReasonInput(
    Input$viewReasonInput instance,
    TRes Function(Input$viewReasonInput) then,
  ) = _CopyWithImpl$Input$viewReasonInput;

  factory CopyWith$Input$viewReasonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewReasonInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewReasonInput<TRes>
    implements CopyWith$Input$viewReasonInput<TRes> {
  _CopyWithImpl$Input$viewReasonInput(
    this._instance,
    this._then,
  );

  final Input$viewReasonInput _instance;

  final TRes Function(Input$viewReasonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewReasonInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$viewReasonInput<TRes>
    implements CopyWith$Input$viewReasonInput<TRes> {
  _CopyWithStubImpl$Input$viewReasonInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ReasonCreateInput {
  factory Input$ReasonCreateInput({
    required String name,
    String? status,
  }) =>
      Input$ReasonCreateInput._({
        r'name': name,
        if (status != null) r'status': status,
      });

  Input$ReasonCreateInput._(this._$data);

  factory Input$ReasonCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$ReasonCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$ReasonCreateInput<Input$ReasonCreateInput> get copyWith =>
      CopyWith$Input$ReasonCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReasonCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$name,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReasonCreateInput<TRes> {
  factory CopyWith$Input$ReasonCreateInput(
    Input$ReasonCreateInput instance,
    TRes Function(Input$ReasonCreateInput) then,
  ) = _CopyWithImpl$Input$ReasonCreateInput;

  factory CopyWith$Input$ReasonCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReasonCreateInput;

  TRes call({
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$ReasonCreateInput<TRes>
    implements CopyWith$Input$ReasonCreateInput<TRes> {
  _CopyWithImpl$Input$ReasonCreateInput(
    this._instance,
    this._then,
  );

  final Input$ReasonCreateInput _instance;

  final TRes Function(Input$ReasonCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$ReasonCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$ReasonCreateInput<TRes>
    implements CopyWith$Input$ReasonCreateInput<TRes> {
  _CopyWithStubImpl$Input$ReasonCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$UpdateReasonStatusInput {
  factory Input$UpdateReasonStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateReasonStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateReasonStatusInput._(this._$data);

  factory Input$UpdateReasonStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateReasonStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateReasonStatusInput<Input$UpdateReasonStatusInput>
      get copyWith => CopyWith$Input$UpdateReasonStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateReasonStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateReasonStatusInput<TRes> {
  factory CopyWith$Input$UpdateReasonStatusInput(
    Input$UpdateReasonStatusInput instance,
    TRes Function(Input$UpdateReasonStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateReasonStatusInput;

  factory CopyWith$Input$UpdateReasonStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateReasonStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateReasonStatusInput<TRes>
    implements CopyWith$Input$UpdateReasonStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateReasonStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateReasonStatusInput _instance;

  final TRes Function(Input$UpdateReasonStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateReasonStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateReasonStatusInput<TRes>
    implements CopyWith$Input$UpdateReasonStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateReasonStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$ReportReasonUpdateInput {
  factory Input$ReportReasonUpdateInput({
    required String uuid,
    String? name,
    String? status,
  }) =>
      Input$ReportReasonUpdateInput._({
        r'uuid': uuid,
        if (name != null) r'name': name,
        if (status != null) r'status': status,
      });

  Input$ReportReasonUpdateInput._(this._$data);

  factory Input$ReportReasonUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    return Input$ReportReasonUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get name => (_$data['name'] as String?);

  String? get status => (_$data['status'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$ReportReasonUpdateInput<Input$ReportReasonUpdateInput>
      get copyWith => CopyWith$Input$ReportReasonUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReportReasonUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportReasonUpdateInput<TRes> {
  factory CopyWith$Input$ReportReasonUpdateInput(
    Input$ReportReasonUpdateInput instance,
    TRes Function(Input$ReportReasonUpdateInput) then,
  ) = _CopyWithImpl$Input$ReportReasonUpdateInput;

  factory CopyWith$Input$ReportReasonUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportReasonUpdateInput;

  TRes call({
    String? uuid,
    String? name,
    String? status,
  });
}

class _CopyWithImpl$Input$ReportReasonUpdateInput<TRes>
    implements CopyWith$Input$ReportReasonUpdateInput<TRes> {
  _CopyWithImpl$Input$ReportReasonUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ReportReasonUpdateInput _instance;

  final TRes Function(Input$ReportReasonUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$ReportReasonUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (name != _undefined) 'name': (name as String?),
        if (status != _undefined) 'status': (status as String?),
      }));
}

class _CopyWithStubImpl$Input$ReportReasonUpdateInput<TRes>
    implements CopyWith$Input$ReportReasonUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ReportReasonUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? status,
  }) =>
      _res;
}

class Input$DeleteReportReasonInput {
  factory Input$DeleteReportReasonInput({required String uuid}) =>
      Input$DeleteReportReasonInput._({
        r'uuid': uuid,
      });

  Input$DeleteReportReasonInput._(this._$data);

  factory Input$DeleteReportReasonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteReportReasonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteReportReasonInput<Input$DeleteReportReasonInput>
      get copyWith => CopyWith$Input$DeleteReportReasonInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteReportReasonInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteReportReasonInput<TRes> {
  factory CopyWith$Input$DeleteReportReasonInput(
    Input$DeleteReportReasonInput instance,
    TRes Function(Input$DeleteReportReasonInput) then,
  ) = _CopyWithImpl$Input$DeleteReportReasonInput;

  factory CopyWith$Input$DeleteReportReasonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteReportReasonInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteReportReasonInput<TRes>
    implements CopyWith$Input$DeleteReportReasonInput<TRes> {
  _CopyWithImpl$Input$DeleteReportReasonInput(
    this._instance,
    this._then,
  );

  final Input$DeleteReportReasonInput _instance;

  final TRes Function(Input$DeleteReportReasonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$DeleteReportReasonInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteReportReasonInput<TRes>
    implements CopyWith$Input$DeleteReportReasonInput<TRes> {
  _CopyWithStubImpl$Input$DeleteReportReasonInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CreateMatchInput {
  factory Input$CreateMatchInput({
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    Input$CustomRecurring? custom_recurring,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    String? matchlevel,
    int? total_court,
    String? note,
    int? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  }) =>
      Input$CreateMatchInput._({
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (match_court_type != null) r'match_court_type': match_court_type,
        if (match_title != null) r'match_title': match_title,
        if (match_title_uuid != null) r'match_title_uuid': match_title_uuid,
        if (locations != null) r'locations': locations,
        if (address != null) r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (clubs != null) r'clubs': clubs,
        if (date != null) r'date': date,
        if (time != null) r'time': time,
        if (is_recurring != null) r'is_recurring': is_recurring,
        if (recurring_type != null) r'recurring_type': recurring_type,
        if (recurring_end_date != null)
          r'recurring_end_date': recurring_end_date,
        if (custom_recurring != null) r'custom_recurring': custom_recurring,
        if (match_user_type != null) r'match_user_type': match_user_type,
        if (no_slot != null) r'no_slot': no_slot,
        if (hours != null) r'hours': hours,
        if (minutes != null) r'minutes': minutes,
        if (points_to_play != null) r'points_to_play': points_to_play,
        if (is_rating != null) r'is_rating': is_rating,
        if (ratings != null) r'ratings': ratings,
        if (is_booked_court != null) r'is_booked_court': is_booked_court,
        if (court_details != null) r'court_details': court_details,
        if (matchlevel != null) r'matchlevel': matchlevel,
        if (total_court != null) r'total_court': total_court,
        if (note != null) r'note': note,
        if (status != null) r'status': status,
        if (time_zone != null) r'time_zone': time_zone,
        if (is_private != null) r'is_private': is_private,
        if (is_event != null) r'is_event': is_event,
        if (total_players != null) r'total_players': total_players,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (match_organiser != null) r'match_organiser': match_organiser,
        if (event_end_date != null) r'event_end_date': event_end_date,
        if (event_end_time != null) r'event_end_time': event_end_time,
        if (community_image != null) r'community_image': community_image,
        if (community_label_approved != null)
          r'community_label_approved': community_label_approved,
        if (gender != null) r'gender': gender,
        if (tier_details != null) r'tier_details': tier_details,
        if (tournament_bracket_type != null)
          r'tournament_bracket_type': tournament_bracket_type,
      });

  Input$CreateMatchInput._(this._$data);

  factory Input$CreateMatchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('match_court_type')) {
      final l$match_court_type = data['match_court_type'];
      result$data['match_court_type'] = (l$match_court_type as int?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_title_uuid')) {
      final l$match_title_uuid = data['match_title_uuid'];
      result$data['match_title_uuid'] = (l$match_title_uuid as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('time')) {
      final l$time = data['time'];
      result$data['time'] = (l$time as String?);
    }
    if (data.containsKey('is_recurring')) {
      final l$is_recurring = data['is_recurring'];
      result$data['is_recurring'] = (l$is_recurring as int?);
    }
    if (data.containsKey('recurring_type')) {
      final l$recurring_type = data['recurring_type'];
      result$data['recurring_type'] = (l$recurring_type as int?);
    }
    if (data.containsKey('recurring_end_date')) {
      final l$recurring_end_date = data['recurring_end_date'];
      result$data['recurring_end_date'] = (l$recurring_end_date as String?);
    }
    if (data.containsKey('custom_recurring')) {
      final l$custom_recurring = data['custom_recurring'];
      result$data['custom_recurring'] = l$custom_recurring == null
          ? null
          : Input$CustomRecurring.fromJson(
              (l$custom_recurring as Map<String, dynamic>));
    }
    if (data.containsKey('match_user_type')) {
      final l$match_user_type = data['match_user_type'];
      result$data['match_user_type'] = (l$match_user_type as int?);
    }
    if (data.containsKey('no_slot')) {
      final l$no_slot = data['no_slot'];
      result$data['no_slot'] = (l$no_slot as int?);
    }
    if (data.containsKey('hours')) {
      final l$hours = data['hours'];
      result$data['hours'] = (l$hours as String?);
    }
    if (data.containsKey('minutes')) {
      final l$minutes = data['minutes'];
      result$data['minutes'] = (l$minutes as String?);
    }
    if (data.containsKey('points_to_play')) {
      final l$points_to_play = data['points_to_play'];
      result$data['points_to_play'] = (l$points_to_play as int?);
    }
    if (data.containsKey('is_rating')) {
      final l$is_rating = data['is_rating'];
      result$data['is_rating'] = (l$is_rating as int?);
    }
    if (data.containsKey('ratings')) {
      final l$ratings = data['ratings'];
      result$data['ratings'] = (l$ratings as String?);
    }
    if (data.containsKey('is_booked_court')) {
      final l$is_booked_court = data['is_booked_court'];
      result$data['is_booked_court'] = (l$is_booked_court as int?);
    }
    if (data.containsKey('court_details')) {
      final l$court_details = data['court_details'];
      result$data['court_details'] = (l$court_details as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$CourtData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('matchlevel')) {
      final l$matchlevel = data['matchlevel'];
      result$data['matchlevel'] = (l$matchlevel as String?);
    }
    if (data.containsKey('total_court')) {
      final l$total_court = data['total_court'];
      result$data['total_court'] = (l$total_court as int?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as int?);
    }
    if (data.containsKey('time_zone')) {
      final l$time_zone = data['time_zone'];
      result$data['time_zone'] = (l$time_zone as String?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('total_players')) {
      final l$total_players = data['total_players'];
      result$data['total_players'] = (l$total_players as int?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('match_organiser')) {
      final l$match_organiser = data['match_organiser'];
      result$data['match_organiser'] = (l$match_organiser as int?);
    }
    if (data.containsKey('event_end_date')) {
      final l$event_end_date = data['event_end_date'];
      result$data['event_end_date'] = (l$event_end_date as String?);
    }
    if (data.containsKey('event_end_time')) {
      final l$event_end_time = data['event_end_time'];
      result$data['event_end_time'] = (l$event_end_time as String?);
    }
    if (data.containsKey('community_image')) {
      final l$community_image = data['community_image'];
      result$data['community_image'] = (l$community_image as String?);
    }
    if (data.containsKey('community_label_approved')) {
      final l$community_label_approved = data['community_label_approved'];
      result$data['community_label_approved'] =
          (l$community_label_approved as int?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    if (data.containsKey('tier_details')) {
      final l$tier_details = data['tier_details'];
      result$data['tier_details'] = (l$tier_details as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$TireData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('tournament_bracket_type')) {
      final l$tournament_bracket_type = data['tournament_bracket_type'];
      result$data['tournament_bracket_type'] =
          (l$tournament_bracket_type as int?);
    }
    return Input$CreateMatchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  int? get match_court_type => (_$data['match_court_type'] as int?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_title_uuid => (_$data['match_title_uuid'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get date => (_$data['date'] as String?);

  String? get time => (_$data['time'] as String?);

  int? get is_recurring => (_$data['is_recurring'] as int?);

  int? get recurring_type => (_$data['recurring_type'] as int?);

  String? get recurring_end_date => (_$data['recurring_end_date'] as String?);

  Input$CustomRecurring? get custom_recurring =>
      (_$data['custom_recurring'] as Input$CustomRecurring?);

  int? get match_user_type => (_$data['match_user_type'] as int?);

  int? get no_slot => (_$data['no_slot'] as int?);

  String? get hours => (_$data['hours'] as String?);

  String? get minutes => (_$data['minutes'] as String?);

  int? get points_to_play => (_$data['points_to_play'] as int?);

  int? get is_rating => (_$data['is_rating'] as int?);

  String? get ratings => (_$data['ratings'] as String?);

  int? get is_booked_court => (_$data['is_booked_court'] as int?);

  List<Input$CourtData?>? get court_details =>
      (_$data['court_details'] as List<Input$CourtData?>?);

  String? get matchlevel => (_$data['matchlevel'] as String?);

  int? get total_court => (_$data['total_court'] as int?);

  String? get note => (_$data['note'] as String?);

  int? get status => (_$data['status'] as int?);

  String? get time_zone => (_$data['time_zone'] as String?);

  int? get is_private => (_$data['is_private'] as int?);

  int? get is_event => (_$data['is_event'] as int?);

  int? get total_players => (_$data['total_players'] as int?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  int? get match_organiser => (_$data['match_organiser'] as int?);

  String? get event_end_date => (_$data['event_end_date'] as String?);

  String? get event_end_time => (_$data['event_end_time'] as String?);

  String? get community_image => (_$data['community_image'] as String?);

  int? get community_label_approved =>
      (_$data['community_label_approved'] as int?);

  int? get gender => (_$data['gender'] as int?);

  List<Input$TireData?>? get tier_details =>
      (_$data['tier_details'] as List<Input$TireData?>?);

  int? get tournament_bracket_type =>
      (_$data['tournament_bracket_type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('match_court_type')) {
      final l$match_court_type = match_court_type;
      result$data['match_court_type'] = l$match_court_type;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_title_uuid')) {
      final l$match_title_uuid = match_title_uuid;
      result$data['match_title_uuid'] = l$match_title_uuid;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('time')) {
      final l$time = time;
      result$data['time'] = l$time;
    }
    if (_$data.containsKey('is_recurring')) {
      final l$is_recurring = is_recurring;
      result$data['is_recurring'] = l$is_recurring;
    }
    if (_$data.containsKey('recurring_type')) {
      final l$recurring_type = recurring_type;
      result$data['recurring_type'] = l$recurring_type;
    }
    if (_$data.containsKey('recurring_end_date')) {
      final l$recurring_end_date = recurring_end_date;
      result$data['recurring_end_date'] = l$recurring_end_date;
    }
    if (_$data.containsKey('custom_recurring')) {
      final l$custom_recurring = custom_recurring;
      result$data['custom_recurring'] = l$custom_recurring?.toJson();
    }
    if (_$data.containsKey('match_user_type')) {
      final l$match_user_type = match_user_type;
      result$data['match_user_type'] = l$match_user_type;
    }
    if (_$data.containsKey('no_slot')) {
      final l$no_slot = no_slot;
      result$data['no_slot'] = l$no_slot;
    }
    if (_$data.containsKey('hours')) {
      final l$hours = hours;
      result$data['hours'] = l$hours;
    }
    if (_$data.containsKey('minutes')) {
      final l$minutes = minutes;
      result$data['minutes'] = l$minutes;
    }
    if (_$data.containsKey('points_to_play')) {
      final l$points_to_play = points_to_play;
      result$data['points_to_play'] = l$points_to_play;
    }
    if (_$data.containsKey('is_rating')) {
      final l$is_rating = is_rating;
      result$data['is_rating'] = l$is_rating;
    }
    if (_$data.containsKey('ratings')) {
      final l$ratings = ratings;
      result$data['ratings'] = l$ratings;
    }
    if (_$data.containsKey('is_booked_court')) {
      final l$is_booked_court = is_booked_court;
      result$data['is_booked_court'] = l$is_booked_court;
    }
    if (_$data.containsKey('court_details')) {
      final l$court_details = court_details;
      result$data['court_details'] =
          l$court_details?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('matchlevel')) {
      final l$matchlevel = matchlevel;
      result$data['matchlevel'] = l$matchlevel;
    }
    if (_$data.containsKey('total_court')) {
      final l$total_court = total_court;
      result$data['total_court'] = l$total_court;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('time_zone')) {
      final l$time_zone = time_zone;
      result$data['time_zone'] = l$time_zone;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('total_players')) {
      final l$total_players = total_players;
      result$data['total_players'] = l$total_players;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('match_organiser')) {
      final l$match_organiser = match_organiser;
      result$data['match_organiser'] = l$match_organiser;
    }
    if (_$data.containsKey('event_end_date')) {
      final l$event_end_date = event_end_date;
      result$data['event_end_date'] = l$event_end_date;
    }
    if (_$data.containsKey('event_end_time')) {
      final l$event_end_time = event_end_time;
      result$data['event_end_time'] = l$event_end_time;
    }
    if (_$data.containsKey('community_image')) {
      final l$community_image = community_image;
      result$data['community_image'] = l$community_image;
    }
    if (_$data.containsKey('community_label_approved')) {
      final l$community_label_approved = community_label_approved;
      result$data['community_label_approved'] = l$community_label_approved;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('tier_details')) {
      final l$tier_details = tier_details;
      result$data['tier_details'] =
          l$tier_details?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('tournament_bracket_type')) {
      final l$tournament_bracket_type = tournament_bracket_type;
      result$data['tournament_bracket_type'] = l$tournament_bracket_type;
    }
    return result$data;
  }

  CopyWith$Input$CreateMatchInput<Input$CreateMatchInput> get copyWith =>
      CopyWith$Input$CreateMatchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateMatchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$match_court_type = match_court_type;
    final lOther$match_court_type = other.match_court_type;
    if (_$data.containsKey('match_court_type') !=
        other._$data.containsKey('match_court_type')) {
      return false;
    }
    if (l$match_court_type != lOther$match_court_type) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_title_uuid = match_title_uuid;
    final lOther$match_title_uuid = other.match_title_uuid;
    if (_$data.containsKey('match_title_uuid') !=
        other._$data.containsKey('match_title_uuid')) {
      return false;
    }
    if (l$match_title_uuid != lOther$match_title_uuid) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$time = time;
    final lOther$time = other.time;
    if (_$data.containsKey('time') != other._$data.containsKey('time')) {
      return false;
    }
    if (l$time != lOther$time) {
      return false;
    }
    final l$is_recurring = is_recurring;
    final lOther$is_recurring = other.is_recurring;
    if (_$data.containsKey('is_recurring') !=
        other._$data.containsKey('is_recurring')) {
      return false;
    }
    if (l$is_recurring != lOther$is_recurring) {
      return false;
    }
    final l$recurring_type = recurring_type;
    final lOther$recurring_type = other.recurring_type;
    if (_$data.containsKey('recurring_type') !=
        other._$data.containsKey('recurring_type')) {
      return false;
    }
    if (l$recurring_type != lOther$recurring_type) {
      return false;
    }
    final l$recurring_end_date = recurring_end_date;
    final lOther$recurring_end_date = other.recurring_end_date;
    if (_$data.containsKey('recurring_end_date') !=
        other._$data.containsKey('recurring_end_date')) {
      return false;
    }
    if (l$recurring_end_date != lOther$recurring_end_date) {
      return false;
    }
    final l$custom_recurring = custom_recurring;
    final lOther$custom_recurring = other.custom_recurring;
    if (_$data.containsKey('custom_recurring') !=
        other._$data.containsKey('custom_recurring')) {
      return false;
    }
    if (l$custom_recurring != lOther$custom_recurring) {
      return false;
    }
    final l$match_user_type = match_user_type;
    final lOther$match_user_type = other.match_user_type;
    if (_$data.containsKey('match_user_type') !=
        other._$data.containsKey('match_user_type')) {
      return false;
    }
    if (l$match_user_type != lOther$match_user_type) {
      return false;
    }
    final l$no_slot = no_slot;
    final lOther$no_slot = other.no_slot;
    if (_$data.containsKey('no_slot') != other._$data.containsKey('no_slot')) {
      return false;
    }
    if (l$no_slot != lOther$no_slot) {
      return false;
    }
    final l$hours = hours;
    final lOther$hours = other.hours;
    if (_$data.containsKey('hours') != other._$data.containsKey('hours')) {
      return false;
    }
    if (l$hours != lOther$hours) {
      return false;
    }
    final l$minutes = minutes;
    final lOther$minutes = other.minutes;
    if (_$data.containsKey('minutes') != other._$data.containsKey('minutes')) {
      return false;
    }
    if (l$minutes != lOther$minutes) {
      return false;
    }
    final l$points_to_play = points_to_play;
    final lOther$points_to_play = other.points_to_play;
    if (_$data.containsKey('points_to_play') !=
        other._$data.containsKey('points_to_play')) {
      return false;
    }
    if (l$points_to_play != lOther$points_to_play) {
      return false;
    }
    final l$is_rating = is_rating;
    final lOther$is_rating = other.is_rating;
    if (_$data.containsKey('is_rating') !=
        other._$data.containsKey('is_rating')) {
      return false;
    }
    if (l$is_rating != lOther$is_rating) {
      return false;
    }
    final l$ratings = ratings;
    final lOther$ratings = other.ratings;
    if (_$data.containsKey('ratings') != other._$data.containsKey('ratings')) {
      return false;
    }
    if (l$ratings != lOther$ratings) {
      return false;
    }
    final l$is_booked_court = is_booked_court;
    final lOther$is_booked_court = other.is_booked_court;
    if (_$data.containsKey('is_booked_court') !=
        other._$data.containsKey('is_booked_court')) {
      return false;
    }
    if (l$is_booked_court != lOther$is_booked_court) {
      return false;
    }
    final l$court_details = court_details;
    final lOther$court_details = other.court_details;
    if (_$data.containsKey('court_details') !=
        other._$data.containsKey('court_details')) {
      return false;
    }
    if (l$court_details != null && lOther$court_details != null) {
      if (l$court_details.length != lOther$court_details.length) {
        return false;
      }
      for (int i = 0; i < l$court_details.length; i++) {
        final l$court_details$entry = l$court_details[i];
        final lOther$court_details$entry = lOther$court_details[i];
        if (l$court_details$entry != lOther$court_details$entry) {
          return false;
        }
      }
    } else if (l$court_details != lOther$court_details) {
      return false;
    }
    final l$matchlevel = matchlevel;
    final lOther$matchlevel = other.matchlevel;
    if (_$data.containsKey('matchlevel') !=
        other._$data.containsKey('matchlevel')) {
      return false;
    }
    if (l$matchlevel != lOther$matchlevel) {
      return false;
    }
    final l$total_court = total_court;
    final lOther$total_court = other.total_court;
    if (_$data.containsKey('total_court') !=
        other._$data.containsKey('total_court')) {
      return false;
    }
    if (l$total_court != lOther$total_court) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$time_zone = time_zone;
    final lOther$time_zone = other.time_zone;
    if (_$data.containsKey('time_zone') !=
        other._$data.containsKey('time_zone')) {
      return false;
    }
    if (l$time_zone != lOther$time_zone) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$total_players = total_players;
    final lOther$total_players = other.total_players;
    if (_$data.containsKey('total_players') !=
        other._$data.containsKey('total_players')) {
      return false;
    }
    if (l$total_players != lOther$total_players) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$match_organiser = match_organiser;
    final lOther$match_organiser = other.match_organiser;
    if (_$data.containsKey('match_organiser') !=
        other._$data.containsKey('match_organiser')) {
      return false;
    }
    if (l$match_organiser != lOther$match_organiser) {
      return false;
    }
    final l$event_end_date = event_end_date;
    final lOther$event_end_date = other.event_end_date;
    if (_$data.containsKey('event_end_date') !=
        other._$data.containsKey('event_end_date')) {
      return false;
    }
    if (l$event_end_date != lOther$event_end_date) {
      return false;
    }
    final l$event_end_time = event_end_time;
    final lOther$event_end_time = other.event_end_time;
    if (_$data.containsKey('event_end_time') !=
        other._$data.containsKey('event_end_time')) {
      return false;
    }
    if (l$event_end_time != lOther$event_end_time) {
      return false;
    }
    final l$community_image = community_image;
    final lOther$community_image = other.community_image;
    if (_$data.containsKey('community_image') !=
        other._$data.containsKey('community_image')) {
      return false;
    }
    if (l$community_image != lOther$community_image) {
      return false;
    }
    final l$community_label_approved = community_label_approved;
    final lOther$community_label_approved = other.community_label_approved;
    if (_$data.containsKey('community_label_approved') !=
        other._$data.containsKey('community_label_approved')) {
      return false;
    }
    if (l$community_label_approved != lOther$community_label_approved) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$tier_details = tier_details;
    final lOther$tier_details = other.tier_details;
    if (_$data.containsKey('tier_details') !=
        other._$data.containsKey('tier_details')) {
      return false;
    }
    if (l$tier_details != null && lOther$tier_details != null) {
      if (l$tier_details.length != lOther$tier_details.length) {
        return false;
      }
      for (int i = 0; i < l$tier_details.length; i++) {
        final l$tier_details$entry = l$tier_details[i];
        final lOther$tier_details$entry = lOther$tier_details[i];
        if (l$tier_details$entry != lOther$tier_details$entry) {
          return false;
        }
      }
    } else if (l$tier_details != lOther$tier_details) {
      return false;
    }
    final l$tournament_bracket_type = tournament_bracket_type;
    final lOther$tournament_bracket_type = other.tournament_bracket_type;
    if (_$data.containsKey('tournament_bracket_type') !=
        other._$data.containsKey('tournament_bracket_type')) {
      return false;
    }
    if (l$tournament_bracket_type != lOther$tournament_bracket_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$image = image;
    final l$file_path = file_path;
    final l$match_court_type = match_court_type;
    final l$match_title = match_title;
    final l$match_title_uuid = match_title_uuid;
    final l$locations = locations;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$clubs = clubs;
    final l$date = date;
    final l$time = time;
    final l$is_recurring = is_recurring;
    final l$recurring_type = recurring_type;
    final l$recurring_end_date = recurring_end_date;
    final l$custom_recurring = custom_recurring;
    final l$match_user_type = match_user_type;
    final l$no_slot = no_slot;
    final l$hours = hours;
    final l$minutes = minutes;
    final l$points_to_play = points_to_play;
    final l$is_rating = is_rating;
    final l$ratings = ratings;
    final l$is_booked_court = is_booked_court;
    final l$court_details = court_details;
    final l$matchlevel = matchlevel;
    final l$total_court = total_court;
    final l$note = note;
    final l$status = status;
    final l$time_zone = time_zone;
    final l$is_private = is_private;
    final l$is_event = is_event;
    final l$total_players = total_players;
    final l$cost_per_player = cost_per_player;
    final l$match_organiser = match_organiser;
    final l$event_end_date = event_end_date;
    final l$event_end_time = event_end_time;
    final l$community_image = community_image;
    final l$community_label_approved = community_label_approved;
    final l$gender = gender;
    final l$tier_details = tier_details;
    final l$tournament_bracket_type = tournament_bracket_type;
    return Object.hashAll([
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('match_court_type') ? l$match_court_type : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_title_uuid') ? l$match_title_uuid : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('time') ? l$time : const {},
      _$data.containsKey('is_recurring') ? l$is_recurring : const {},
      _$data.containsKey('recurring_type') ? l$recurring_type : const {},
      _$data.containsKey('recurring_end_date')
          ? l$recurring_end_date
          : const {},
      _$data.containsKey('custom_recurring') ? l$custom_recurring : const {},
      _$data.containsKey('match_user_type') ? l$match_user_type : const {},
      _$data.containsKey('no_slot') ? l$no_slot : const {},
      _$data.containsKey('hours') ? l$hours : const {},
      _$data.containsKey('minutes') ? l$minutes : const {},
      _$data.containsKey('points_to_play') ? l$points_to_play : const {},
      _$data.containsKey('is_rating') ? l$is_rating : const {},
      _$data.containsKey('ratings') ? l$ratings : const {},
      _$data.containsKey('is_booked_court') ? l$is_booked_court : const {},
      _$data.containsKey('court_details')
          ? l$court_details == null
              ? null
              : Object.hashAll(l$court_details.map((v) => v))
          : const {},
      _$data.containsKey('matchlevel') ? l$matchlevel : const {},
      _$data.containsKey('total_court') ? l$total_court : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('time_zone') ? l$time_zone : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('total_players') ? l$total_players : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('match_organiser') ? l$match_organiser : const {},
      _$data.containsKey('event_end_date') ? l$event_end_date : const {},
      _$data.containsKey('event_end_time') ? l$event_end_time : const {},
      _$data.containsKey('community_image') ? l$community_image : const {},
      _$data.containsKey('community_label_approved')
          ? l$community_label_approved
          : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('tier_details')
          ? l$tier_details == null
              ? null
              : Object.hashAll(l$tier_details.map((v) => v))
          : const {},
      _$data.containsKey('tournament_bracket_type')
          ? l$tournament_bracket_type
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateMatchInput<TRes> {
  factory CopyWith$Input$CreateMatchInput(
    Input$CreateMatchInput instance,
    TRes Function(Input$CreateMatchInput) then,
  ) = _CopyWithImpl$Input$CreateMatchInput;

  factory CopyWith$Input$CreateMatchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMatchInput;

  TRes call({
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    Input$CustomRecurring? custom_recurring,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    String? matchlevel,
    int? total_court,
    String? note,
    int? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  });
  CopyWith$Input$CustomRecurring<TRes> get custom_recurring;
  TRes court_details(
      Iterable<Input$CourtData?>? Function(
              Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
          _fn);
  TRes tier_details(
      Iterable<Input$TireData?>? Function(
              Iterable<CopyWith$Input$TireData<Input$TireData>?>?)
          _fn);
}

class _CopyWithImpl$Input$CreateMatchInput<TRes>
    implements CopyWith$Input$CreateMatchInput<TRes> {
  _CopyWithImpl$Input$CreateMatchInput(
    this._instance,
    this._then,
  );

  final Input$CreateMatchInput _instance;

  final TRes Function(Input$CreateMatchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? match_court_type = _undefined,
    Object? match_title = _undefined,
    Object? match_title_uuid = _undefined,
    Object? locations = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? clubs = _undefined,
    Object? date = _undefined,
    Object? time = _undefined,
    Object? is_recurring = _undefined,
    Object? recurring_type = _undefined,
    Object? recurring_end_date = _undefined,
    Object? custom_recurring = _undefined,
    Object? match_user_type = _undefined,
    Object? no_slot = _undefined,
    Object? hours = _undefined,
    Object? minutes = _undefined,
    Object? points_to_play = _undefined,
    Object? is_rating = _undefined,
    Object? ratings = _undefined,
    Object? is_booked_court = _undefined,
    Object? court_details = _undefined,
    Object? matchlevel = _undefined,
    Object? total_court = _undefined,
    Object? note = _undefined,
    Object? status = _undefined,
    Object? time_zone = _undefined,
    Object? is_private = _undefined,
    Object? is_event = _undefined,
    Object? total_players = _undefined,
    Object? cost_per_player = _undefined,
    Object? match_organiser = _undefined,
    Object? event_end_date = _undefined,
    Object? event_end_time = _undefined,
    Object? community_image = _undefined,
    Object? community_label_approved = _undefined,
    Object? gender = _undefined,
    Object? tier_details = _undefined,
    Object? tournament_bracket_type = _undefined,
  }) =>
      _then(Input$CreateMatchInput._({
        ..._instance._$data,
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (match_court_type != _undefined)
          'match_court_type': (match_court_type as int?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_title_uuid != _undefined)
          'match_title_uuid': (match_title_uuid as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (address != _undefined) 'address': (address as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (date != _undefined) 'date': (date as String?),
        if (time != _undefined) 'time': (time as String?),
        if (is_recurring != _undefined) 'is_recurring': (is_recurring as int?),
        if (recurring_type != _undefined)
          'recurring_type': (recurring_type as int?),
        if (recurring_end_date != _undefined)
          'recurring_end_date': (recurring_end_date as String?),
        if (custom_recurring != _undefined)
          'custom_recurring': (custom_recurring as Input$CustomRecurring?),
        if (match_user_type != _undefined)
          'match_user_type': (match_user_type as int?),
        if (no_slot != _undefined) 'no_slot': (no_slot as int?),
        if (hours != _undefined) 'hours': (hours as String?),
        if (minutes != _undefined) 'minutes': (minutes as String?),
        if (points_to_play != _undefined)
          'points_to_play': (points_to_play as int?),
        if (is_rating != _undefined) 'is_rating': (is_rating as int?),
        if (ratings != _undefined) 'ratings': (ratings as String?),
        if (is_booked_court != _undefined)
          'is_booked_court': (is_booked_court as int?),
        if (court_details != _undefined)
          'court_details': (court_details as List<Input$CourtData?>?),
        if (matchlevel != _undefined) 'matchlevel': (matchlevel as String?),
        if (total_court != _undefined) 'total_court': (total_court as int?),
        if (note != _undefined) 'note': (note as String?),
        if (status != _undefined) 'status': (status as int?),
        if (time_zone != _undefined) 'time_zone': (time_zone as String?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (total_players != _undefined)
          'total_players': (total_players as int?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (match_organiser != _undefined)
          'match_organiser': (match_organiser as int?),
        if (event_end_date != _undefined)
          'event_end_date': (event_end_date as String?),
        if (event_end_time != _undefined)
          'event_end_time': (event_end_time as String?),
        if (community_image != _undefined)
          'community_image': (community_image as String?),
        if (community_label_approved != _undefined)
          'community_label_approved': (community_label_approved as int?),
        if (gender != _undefined) 'gender': (gender as int?),
        if (tier_details != _undefined)
          'tier_details': (tier_details as List<Input$TireData?>?),
        if (tournament_bracket_type != _undefined)
          'tournament_bracket_type': (tournament_bracket_type as int?),
      }));

  CopyWith$Input$CustomRecurring<TRes> get custom_recurring {
    final local$custom_recurring = _instance.custom_recurring;
    return local$custom_recurring == null
        ? CopyWith$Input$CustomRecurring.stub(_then(_instance))
        : CopyWith$Input$CustomRecurring(
            local$custom_recurring, (e) => call(custom_recurring: e));
  }

  TRes court_details(
          Iterable<Input$CourtData?>? Function(
                  Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
              _fn) =>
      call(
          court_details: _fn(_instance.court_details?.map((e) => e == null
              ? null
              : CopyWith$Input$CourtData(
                  e,
                  (i) => i,
                )))?.toList());

  TRes tier_details(
          Iterable<Input$TireData?>? Function(
                  Iterable<CopyWith$Input$TireData<Input$TireData>?>?)
              _fn) =>
      call(
          tier_details: _fn(_instance.tier_details?.map((e) => e == null
              ? null
              : CopyWith$Input$TireData(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$CreateMatchInput<TRes>
    implements CopyWith$Input$CreateMatchInput<TRes> {
  _CopyWithStubImpl$Input$CreateMatchInput(this._res);

  TRes _res;

  call({
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    Input$CustomRecurring? custom_recurring,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    String? matchlevel,
    int? total_court,
    String? note,
    int? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  }) =>
      _res;

  CopyWith$Input$CustomRecurring<TRes> get custom_recurring =>
      CopyWith$Input$CustomRecurring.stub(_res);

  court_details(_fn) => _res;

  tier_details(_fn) => _res;
}

class Input$CourtData {
  factory Input$CourtData({
    int? court_no,
    String? court_type,
  }) =>
      Input$CourtData._({
        if (court_no != null) r'court_no': court_no,
        if (court_type != null) r'court_type': court_type,
      });

  Input$CourtData._(this._$data);

  factory Input$CourtData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('court_no')) {
      final l$court_no = data['court_no'];
      result$data['court_no'] = (l$court_no as int?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    return Input$CourtData._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get court_no => (_$data['court_no'] as int?);

  String? get court_type => (_$data['court_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('court_no')) {
      final l$court_no = court_no;
      result$data['court_no'] = l$court_no;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    return result$data;
  }

  CopyWith$Input$CourtData<Input$CourtData> get copyWith =>
      CopyWith$Input$CourtData(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CourtData) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$court_no = court_no;
    final lOther$court_no = other.court_no;
    if (_$data.containsKey('court_no') !=
        other._$data.containsKey('court_no')) {
      return false;
    }
    if (l$court_no != lOther$court_no) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$court_no = court_no;
    final l$court_type = court_type;
    return Object.hashAll([
      _$data.containsKey('court_no') ? l$court_no : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$CourtData<TRes> {
  factory CopyWith$Input$CourtData(
    Input$CourtData instance,
    TRes Function(Input$CourtData) then,
  ) = _CopyWithImpl$Input$CourtData;

  factory CopyWith$Input$CourtData.stub(TRes res) =
      _CopyWithStubImpl$Input$CourtData;

  TRes call({
    int? court_no,
    String? court_type,
  });
}

class _CopyWithImpl$Input$CourtData<TRes>
    implements CopyWith$Input$CourtData<TRes> {
  _CopyWithImpl$Input$CourtData(
    this._instance,
    this._then,
  );

  final Input$CourtData _instance;

  final TRes Function(Input$CourtData) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? court_no = _undefined,
    Object? court_type = _undefined,
  }) =>
      _then(Input$CourtData._({
        ..._instance._$data,
        if (court_no != _undefined) 'court_no': (court_no as int?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
      }));
}

class _CopyWithStubImpl$Input$CourtData<TRes>
    implements CopyWith$Input$CourtData<TRes> {
  _CopyWithStubImpl$Input$CourtData(this._res);

  TRes _res;

  call({
    int? court_no,
    String? court_type,
  }) =>
      _res;
}

class Input$MatchAdminPaginationInput {
  factory Input$MatchAdminPaginationInput({
    required int offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? match_creator,
  }) =>
      Input$MatchAdminPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (club_name != null) r'club_name': club_name,
        if (skill_level != null) r'skill_level': skill_level,
        if (status != null) r'status': status,
        if (locations != null) r'locations': locations,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_event != null) r'is_event': is_event,
        if (match_creator != null) r'match_creator': match_creator,
      });

  Input$MatchAdminPaginationInput._(this._$data);

  factory Input$MatchAdminPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('match_creator')) {
      final l$match_creator = data['match_creator'];
      result$data['match_creator'] = (l$match_creator as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$MatchAdminPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get radius => (_$data['radius'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  List<String?>? get match_creator =>
      (_$data['match_creator'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('match_creator')) {
      final l$match_creator = match_creator;
      result$data['match_creator'] = l$match_creator?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$MatchAdminPaginationInput<Input$MatchAdminPaginationInput>
      get copyWith => CopyWith$Input$MatchAdminPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchAdminPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$match_creator = match_creator;
    final lOther$match_creator = other.match_creator;
    if (_$data.containsKey('match_creator') !=
        other._$data.containsKey('match_creator')) {
      return false;
    }
    if (l$match_creator != null && lOther$match_creator != null) {
      if (l$match_creator.length != lOther$match_creator.length) {
        return false;
      }
      for (int i = 0; i < l$match_creator.length; i++) {
        final l$match_creator$entry = l$match_creator[i];
        final lOther$match_creator$entry = lOther$match_creator[i];
        if (l$match_creator$entry != lOther$match_creator$entry) {
          return false;
        }
      }
    } else if (l$match_creator != lOther$match_creator) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$club_name = club_name;
    final l$skill_level = skill_level;
    final l$status = status;
    final l$locations = locations;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_event = is_event;
    final l$match_creator = match_creator;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('match_creator')
          ? l$match_creator == null
              ? null
              : Object.hashAll(l$match_creator.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchAdminPaginationInput<TRes> {
  factory CopyWith$Input$MatchAdminPaginationInput(
    Input$MatchAdminPaginationInput instance,
    TRes Function(Input$MatchAdminPaginationInput) then,
  ) = _CopyWithImpl$Input$MatchAdminPaginationInput;

  factory CopyWith$Input$MatchAdminPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchAdminPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? match_creator,
  });
}

class _CopyWithImpl$Input$MatchAdminPaginationInput<TRes>
    implements CopyWith$Input$MatchAdminPaginationInput<TRes> {
  _CopyWithImpl$Input$MatchAdminPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MatchAdminPaginationInput _instance;

  final TRes Function(Input$MatchAdminPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? club_name = _undefined,
    Object? skill_level = _undefined,
    Object? status = _undefined,
    Object? locations = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_event = _undefined,
    Object? match_creator = _undefined,
  }) =>
      _then(Input$MatchAdminPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (status != _undefined) 'status': (status as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (radius != _undefined) 'radius': (radius as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (match_creator != _undefined)
          'match_creator': (match_creator as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$MatchAdminPaginationInput<TRes>
    implements CopyWith$Input$MatchAdminPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MatchAdminPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? match_creator,
  }) =>
      _res;
}

class Input$UpdateMatchStatusInput {
  factory Input$UpdateMatchStatusInput({
    required String uuid,
    required String status,
  }) =>
      Input$UpdateMatchStatusInput._({
        r'uuid': uuid,
        r'status': status,
      });

  Input$UpdateMatchStatusInput._(this._$data);

  factory Input$UpdateMatchStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$status = data['status'];
    result$data['status'] = (l$status as String);
    return Input$UpdateMatchStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get status => (_$data['status'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$status = status;
    result$data['status'] = l$status;
    return result$data;
  }

  CopyWith$Input$UpdateMatchStatusInput<Input$UpdateMatchStatusInput>
      get copyWith => CopyWith$Input$UpdateMatchStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateMatchStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      l$status,
    ]);
  }
}

abstract class CopyWith$Input$UpdateMatchStatusInput<TRes> {
  factory CopyWith$Input$UpdateMatchStatusInput(
    Input$UpdateMatchStatusInput instance,
    TRes Function(Input$UpdateMatchStatusInput) then,
  ) = _CopyWithImpl$Input$UpdateMatchStatusInput;

  factory CopyWith$Input$UpdateMatchStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateMatchStatusInput;

  TRes call({
    String? uuid,
    String? status,
  });
}

class _CopyWithImpl$Input$UpdateMatchStatusInput<TRes>
    implements CopyWith$Input$UpdateMatchStatusInput<TRes> {
  _CopyWithImpl$Input$UpdateMatchStatusInput(
    this._instance,
    this._then,
  );

  final Input$UpdateMatchStatusInput _instance;

  final TRes Function(Input$UpdateMatchStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateMatchStatusInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined && status != null)
          'status': (status as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateMatchStatusInput<TRes>
    implements CopyWith$Input$UpdateMatchStatusInput<TRes> {
  _CopyWithStubImpl$Input$UpdateMatchStatusInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? status,
  }) =>
      _res;
}

class Input$viewMatchAdminInput {
  factory Input$viewMatchAdminInput({required String uuid}) =>
      Input$viewMatchAdminInput._({
        r'uuid': uuid,
      });

  Input$viewMatchAdminInput._(this._$data);

  factory Input$viewMatchAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewMatchAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewMatchAdminInput<Input$viewMatchAdminInput> get copyWith =>
      CopyWith$Input$viewMatchAdminInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewMatchAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewMatchAdminInput<TRes> {
  factory CopyWith$Input$viewMatchAdminInput(
    Input$viewMatchAdminInput instance,
    TRes Function(Input$viewMatchAdminInput) then,
  ) = _CopyWithImpl$Input$viewMatchAdminInput;

  factory CopyWith$Input$viewMatchAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewMatchAdminInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewMatchAdminInput<TRes>
    implements CopyWith$Input$viewMatchAdminInput<TRes> {
  _CopyWithImpl$Input$viewMatchAdminInput(
    this._instance,
    this._then,
  );

  final Input$viewMatchAdminInput _instance;

  final TRes Function(Input$viewMatchAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewMatchAdminInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewMatchAdminInput<TRes>
    implements CopyWith$Input$viewMatchAdminInput<TRes> {
  _CopyWithStubImpl$Input$viewMatchAdminInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$deleteMatchInput {
  factory Input$deleteMatchInput({required String uuid}) =>
      Input$deleteMatchInput._({
        r'uuid': uuid,
      });

  Input$deleteMatchInput._(this._$data);

  factory Input$deleteMatchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteMatchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteMatchInput<Input$deleteMatchInput> get copyWith =>
      CopyWith$Input$deleteMatchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteMatchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteMatchInput<TRes> {
  factory CopyWith$Input$deleteMatchInput(
    Input$deleteMatchInput instance,
    TRes Function(Input$deleteMatchInput) then,
  ) = _CopyWithImpl$Input$deleteMatchInput;

  factory CopyWith$Input$deleteMatchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteMatchInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteMatchInput<TRes>
    implements CopyWith$Input$deleteMatchInput<TRes> {
  _CopyWithImpl$Input$deleteMatchInput(
    this._instance,
    this._then,
  );

  final Input$deleteMatchInput _instance;

  final TRes Function(Input$deleteMatchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteMatchInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteMatchInput<TRes>
    implements CopyWith$Input$deleteMatchInput<TRes> {
  _CopyWithStubImpl$Input$deleteMatchInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$MatchInput {
  factory Input$MatchInput({
    required String uuid,
    String? image,
    int? match_court_type,
    String? match_title,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? cost_per_player,
    String? match_level,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
  }) =>
      Input$MatchInput._({
        r'uuid': uuid,
        if (image != null) r'image': image,
        if (match_court_type != null) r'match_court_type': match_court_type,
        if (match_title != null) r'match_title': match_title,
        if (locations != null) r'locations': locations,
        if (address != null) r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (clubs != null) r'clubs': clubs,
        if (date != null) r'date': date,
        if (time != null) r'time': time,
        if (is_recurring != null) r'is_recurring': is_recurring,
        if (recurring_type != null) r'recurring_type': recurring_type,
        if (recurring_end_date != null)
          r'recurring_end_date': recurring_end_date,
        if (match_user_type != null) r'match_user_type': match_user_type,
        if (no_slot != null) r'no_slot': no_slot,
        if (hours != null) r'hours': hours,
        if (minutes != null) r'minutes': minutes,
        if (points_to_play != null) r'points_to_play': points_to_play,
        if (is_rating != null) r'is_rating': is_rating,
        if (ratings != null) r'ratings': ratings,
        if (is_booked_court != null) r'is_booked_court': is_booked_court,
        if (court_details != null) r'court_details': court_details,
        if (total_court != null) r'total_court': total_court,
        if (note != null) r'note': note,
        if (status != null) r'status': status,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (match_level != null) r'match_level': match_level,
        if (event_end_date != null) r'event_end_date': event_end_date,
        if (event_end_time != null) r'event_end_time': event_end_time,
        if (community_image != null) r'community_image': community_image,
        if (community_label_approved != null)
          r'community_label_approved': community_label_approved,
        if (gender != null) r'gender': gender,
      });

  Input$MatchInput._(this._$data);

  factory Input$MatchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('match_court_type')) {
      final l$match_court_type = data['match_court_type'];
      result$data['match_court_type'] = (l$match_court_type as int?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('time')) {
      final l$time = data['time'];
      result$data['time'] = (l$time as String?);
    }
    if (data.containsKey('is_recurring')) {
      final l$is_recurring = data['is_recurring'];
      result$data['is_recurring'] = (l$is_recurring as int?);
    }
    if (data.containsKey('recurring_type')) {
      final l$recurring_type = data['recurring_type'];
      result$data['recurring_type'] = (l$recurring_type as int?);
    }
    if (data.containsKey('recurring_end_date')) {
      final l$recurring_end_date = data['recurring_end_date'];
      result$data['recurring_end_date'] = (l$recurring_end_date as String?);
    }
    if (data.containsKey('match_user_type')) {
      final l$match_user_type = data['match_user_type'];
      result$data['match_user_type'] = (l$match_user_type as int?);
    }
    if (data.containsKey('no_slot')) {
      final l$no_slot = data['no_slot'];
      result$data['no_slot'] = (l$no_slot as int?);
    }
    if (data.containsKey('hours')) {
      final l$hours = data['hours'];
      result$data['hours'] = (l$hours as String?);
    }
    if (data.containsKey('minutes')) {
      final l$minutes = data['minutes'];
      result$data['minutes'] = (l$minutes as String?);
    }
    if (data.containsKey('points_to_play')) {
      final l$points_to_play = data['points_to_play'];
      result$data['points_to_play'] = (l$points_to_play as int?);
    }
    if (data.containsKey('is_rating')) {
      final l$is_rating = data['is_rating'];
      result$data['is_rating'] = (l$is_rating as int?);
    }
    if (data.containsKey('ratings')) {
      final l$ratings = data['ratings'];
      result$data['ratings'] = (l$ratings as String?);
    }
    if (data.containsKey('is_booked_court')) {
      final l$is_booked_court = data['is_booked_court'];
      result$data['is_booked_court'] = (l$is_booked_court as int?);
    }
    if (data.containsKey('court_details')) {
      final l$court_details = data['court_details'];
      result$data['court_details'] = (l$court_details as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$CourtData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('total_court')) {
      final l$total_court = data['total_court'];
      result$data['total_court'] = (l$total_court as int?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('match_level')) {
      final l$match_level = data['match_level'];
      result$data['match_level'] = (l$match_level as String?);
    }
    if (data.containsKey('event_end_date')) {
      final l$event_end_date = data['event_end_date'];
      result$data['event_end_date'] = (l$event_end_date as String?);
    }
    if (data.containsKey('event_end_time')) {
      final l$event_end_time = data['event_end_time'];
      result$data['event_end_time'] = (l$event_end_time as String?);
    }
    if (data.containsKey('community_image')) {
      final l$community_image = data['community_image'];
      result$data['community_image'] = (l$community_image as String?);
    }
    if (data.containsKey('community_label_approved')) {
      final l$community_label_approved = data['community_label_approved'];
      result$data['community_label_approved'] =
          (l$community_label_approved as int?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    return Input$MatchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get image => (_$data['image'] as String?);

  int? get match_court_type => (_$data['match_court_type'] as int?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get date => (_$data['date'] as String?);

  String? get time => (_$data['time'] as String?);

  int? get is_recurring => (_$data['is_recurring'] as int?);

  int? get recurring_type => (_$data['recurring_type'] as int?);

  String? get recurring_end_date => (_$data['recurring_end_date'] as String?);

  int? get match_user_type => (_$data['match_user_type'] as int?);

  int? get no_slot => (_$data['no_slot'] as int?);

  String? get hours => (_$data['hours'] as String?);

  String? get minutes => (_$data['minutes'] as String?);

  int? get points_to_play => (_$data['points_to_play'] as int?);

  int? get is_rating => (_$data['is_rating'] as int?);

  String? get ratings => (_$data['ratings'] as String?);

  int? get is_booked_court => (_$data['is_booked_court'] as int?);

  List<Input$CourtData?>? get court_details =>
      (_$data['court_details'] as List<Input$CourtData?>?);

  int? get total_court => (_$data['total_court'] as int?);

  String? get note => (_$data['note'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get match_level => (_$data['match_level'] as String?);

  String? get event_end_date => (_$data['event_end_date'] as String?);

  String? get event_end_time => (_$data['event_end_time'] as String?);

  String? get community_image => (_$data['community_image'] as String?);

  int? get community_label_approved =>
      (_$data['community_label_approved'] as int?);

  int? get gender => (_$data['gender'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('match_court_type')) {
      final l$match_court_type = match_court_type;
      result$data['match_court_type'] = l$match_court_type;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('time')) {
      final l$time = time;
      result$data['time'] = l$time;
    }
    if (_$data.containsKey('is_recurring')) {
      final l$is_recurring = is_recurring;
      result$data['is_recurring'] = l$is_recurring;
    }
    if (_$data.containsKey('recurring_type')) {
      final l$recurring_type = recurring_type;
      result$data['recurring_type'] = l$recurring_type;
    }
    if (_$data.containsKey('recurring_end_date')) {
      final l$recurring_end_date = recurring_end_date;
      result$data['recurring_end_date'] = l$recurring_end_date;
    }
    if (_$data.containsKey('match_user_type')) {
      final l$match_user_type = match_user_type;
      result$data['match_user_type'] = l$match_user_type;
    }
    if (_$data.containsKey('no_slot')) {
      final l$no_slot = no_slot;
      result$data['no_slot'] = l$no_slot;
    }
    if (_$data.containsKey('hours')) {
      final l$hours = hours;
      result$data['hours'] = l$hours;
    }
    if (_$data.containsKey('minutes')) {
      final l$minutes = minutes;
      result$data['minutes'] = l$minutes;
    }
    if (_$data.containsKey('points_to_play')) {
      final l$points_to_play = points_to_play;
      result$data['points_to_play'] = l$points_to_play;
    }
    if (_$data.containsKey('is_rating')) {
      final l$is_rating = is_rating;
      result$data['is_rating'] = l$is_rating;
    }
    if (_$data.containsKey('ratings')) {
      final l$ratings = ratings;
      result$data['ratings'] = l$ratings;
    }
    if (_$data.containsKey('is_booked_court')) {
      final l$is_booked_court = is_booked_court;
      result$data['is_booked_court'] = l$is_booked_court;
    }
    if (_$data.containsKey('court_details')) {
      final l$court_details = court_details;
      result$data['court_details'] =
          l$court_details?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('total_court')) {
      final l$total_court = total_court;
      result$data['total_court'] = l$total_court;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('match_level')) {
      final l$match_level = match_level;
      result$data['match_level'] = l$match_level;
    }
    if (_$data.containsKey('event_end_date')) {
      final l$event_end_date = event_end_date;
      result$data['event_end_date'] = l$event_end_date;
    }
    if (_$data.containsKey('event_end_time')) {
      final l$event_end_time = event_end_time;
      result$data['event_end_time'] = l$event_end_time;
    }
    if (_$data.containsKey('community_image')) {
      final l$community_image = community_image;
      result$data['community_image'] = l$community_image;
    }
    if (_$data.containsKey('community_label_approved')) {
      final l$community_label_approved = community_label_approved;
      result$data['community_label_approved'] = l$community_label_approved;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    return result$data;
  }

  CopyWith$Input$MatchInput<Input$MatchInput> get copyWith =>
      CopyWith$Input$MatchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$match_court_type = match_court_type;
    final lOther$match_court_type = other.match_court_type;
    if (_$data.containsKey('match_court_type') !=
        other._$data.containsKey('match_court_type')) {
      return false;
    }
    if (l$match_court_type != lOther$match_court_type) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$time = time;
    final lOther$time = other.time;
    if (_$data.containsKey('time') != other._$data.containsKey('time')) {
      return false;
    }
    if (l$time != lOther$time) {
      return false;
    }
    final l$is_recurring = is_recurring;
    final lOther$is_recurring = other.is_recurring;
    if (_$data.containsKey('is_recurring') !=
        other._$data.containsKey('is_recurring')) {
      return false;
    }
    if (l$is_recurring != lOther$is_recurring) {
      return false;
    }
    final l$recurring_type = recurring_type;
    final lOther$recurring_type = other.recurring_type;
    if (_$data.containsKey('recurring_type') !=
        other._$data.containsKey('recurring_type')) {
      return false;
    }
    if (l$recurring_type != lOther$recurring_type) {
      return false;
    }
    final l$recurring_end_date = recurring_end_date;
    final lOther$recurring_end_date = other.recurring_end_date;
    if (_$data.containsKey('recurring_end_date') !=
        other._$data.containsKey('recurring_end_date')) {
      return false;
    }
    if (l$recurring_end_date != lOther$recurring_end_date) {
      return false;
    }
    final l$match_user_type = match_user_type;
    final lOther$match_user_type = other.match_user_type;
    if (_$data.containsKey('match_user_type') !=
        other._$data.containsKey('match_user_type')) {
      return false;
    }
    if (l$match_user_type != lOther$match_user_type) {
      return false;
    }
    final l$no_slot = no_slot;
    final lOther$no_slot = other.no_slot;
    if (_$data.containsKey('no_slot') != other._$data.containsKey('no_slot')) {
      return false;
    }
    if (l$no_slot != lOther$no_slot) {
      return false;
    }
    final l$hours = hours;
    final lOther$hours = other.hours;
    if (_$data.containsKey('hours') != other._$data.containsKey('hours')) {
      return false;
    }
    if (l$hours != lOther$hours) {
      return false;
    }
    final l$minutes = minutes;
    final lOther$minutes = other.minutes;
    if (_$data.containsKey('minutes') != other._$data.containsKey('minutes')) {
      return false;
    }
    if (l$minutes != lOther$minutes) {
      return false;
    }
    final l$points_to_play = points_to_play;
    final lOther$points_to_play = other.points_to_play;
    if (_$data.containsKey('points_to_play') !=
        other._$data.containsKey('points_to_play')) {
      return false;
    }
    if (l$points_to_play != lOther$points_to_play) {
      return false;
    }
    final l$is_rating = is_rating;
    final lOther$is_rating = other.is_rating;
    if (_$data.containsKey('is_rating') !=
        other._$data.containsKey('is_rating')) {
      return false;
    }
    if (l$is_rating != lOther$is_rating) {
      return false;
    }
    final l$ratings = ratings;
    final lOther$ratings = other.ratings;
    if (_$data.containsKey('ratings') != other._$data.containsKey('ratings')) {
      return false;
    }
    if (l$ratings != lOther$ratings) {
      return false;
    }
    final l$is_booked_court = is_booked_court;
    final lOther$is_booked_court = other.is_booked_court;
    if (_$data.containsKey('is_booked_court') !=
        other._$data.containsKey('is_booked_court')) {
      return false;
    }
    if (l$is_booked_court != lOther$is_booked_court) {
      return false;
    }
    final l$court_details = court_details;
    final lOther$court_details = other.court_details;
    if (_$data.containsKey('court_details') !=
        other._$data.containsKey('court_details')) {
      return false;
    }
    if (l$court_details != null && lOther$court_details != null) {
      if (l$court_details.length != lOther$court_details.length) {
        return false;
      }
      for (int i = 0; i < l$court_details.length; i++) {
        final l$court_details$entry = l$court_details[i];
        final lOther$court_details$entry = lOther$court_details[i];
        if (l$court_details$entry != lOther$court_details$entry) {
          return false;
        }
      }
    } else if (l$court_details != lOther$court_details) {
      return false;
    }
    final l$total_court = total_court;
    final lOther$total_court = other.total_court;
    if (_$data.containsKey('total_court') !=
        other._$data.containsKey('total_court')) {
      return false;
    }
    if (l$total_court != lOther$total_court) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$match_level = match_level;
    final lOther$match_level = other.match_level;
    if (_$data.containsKey('match_level') !=
        other._$data.containsKey('match_level')) {
      return false;
    }
    if (l$match_level != lOther$match_level) {
      return false;
    }
    final l$event_end_date = event_end_date;
    final lOther$event_end_date = other.event_end_date;
    if (_$data.containsKey('event_end_date') !=
        other._$data.containsKey('event_end_date')) {
      return false;
    }
    if (l$event_end_date != lOther$event_end_date) {
      return false;
    }
    final l$event_end_time = event_end_time;
    final lOther$event_end_time = other.event_end_time;
    if (_$data.containsKey('event_end_time') !=
        other._$data.containsKey('event_end_time')) {
      return false;
    }
    if (l$event_end_time != lOther$event_end_time) {
      return false;
    }
    final l$community_image = community_image;
    final lOther$community_image = other.community_image;
    if (_$data.containsKey('community_image') !=
        other._$data.containsKey('community_image')) {
      return false;
    }
    if (l$community_image != lOther$community_image) {
      return false;
    }
    final l$community_label_approved = community_label_approved;
    final lOther$community_label_approved = other.community_label_approved;
    if (_$data.containsKey('community_label_approved') !=
        other._$data.containsKey('community_label_approved')) {
      return false;
    }
    if (l$community_label_approved != lOther$community_label_approved) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$image = image;
    final l$match_court_type = match_court_type;
    final l$match_title = match_title;
    final l$locations = locations;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$clubs = clubs;
    final l$date = date;
    final l$time = time;
    final l$is_recurring = is_recurring;
    final l$recurring_type = recurring_type;
    final l$recurring_end_date = recurring_end_date;
    final l$match_user_type = match_user_type;
    final l$no_slot = no_slot;
    final l$hours = hours;
    final l$minutes = minutes;
    final l$points_to_play = points_to_play;
    final l$is_rating = is_rating;
    final l$ratings = ratings;
    final l$is_booked_court = is_booked_court;
    final l$court_details = court_details;
    final l$total_court = total_court;
    final l$note = note;
    final l$status = status;
    final l$cost_per_player = cost_per_player;
    final l$match_level = match_level;
    final l$event_end_date = event_end_date;
    final l$event_end_time = event_end_time;
    final l$community_image = community_image;
    final l$community_label_approved = community_label_approved;
    final l$gender = gender;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('match_court_type') ? l$match_court_type : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('time') ? l$time : const {},
      _$data.containsKey('is_recurring') ? l$is_recurring : const {},
      _$data.containsKey('recurring_type') ? l$recurring_type : const {},
      _$data.containsKey('recurring_end_date')
          ? l$recurring_end_date
          : const {},
      _$data.containsKey('match_user_type') ? l$match_user_type : const {},
      _$data.containsKey('no_slot') ? l$no_slot : const {},
      _$data.containsKey('hours') ? l$hours : const {},
      _$data.containsKey('minutes') ? l$minutes : const {},
      _$data.containsKey('points_to_play') ? l$points_to_play : const {},
      _$data.containsKey('is_rating') ? l$is_rating : const {},
      _$data.containsKey('ratings') ? l$ratings : const {},
      _$data.containsKey('is_booked_court') ? l$is_booked_court : const {},
      _$data.containsKey('court_details')
          ? l$court_details == null
              ? null
              : Object.hashAll(l$court_details.map((v) => v))
          : const {},
      _$data.containsKey('total_court') ? l$total_court : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('match_level') ? l$match_level : const {},
      _$data.containsKey('event_end_date') ? l$event_end_date : const {},
      _$data.containsKey('event_end_time') ? l$event_end_time : const {},
      _$data.containsKey('community_image') ? l$community_image : const {},
      _$data.containsKey('community_label_approved')
          ? l$community_label_approved
          : const {},
      _$data.containsKey('gender') ? l$gender : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchInput<TRes> {
  factory CopyWith$Input$MatchInput(
    Input$MatchInput instance,
    TRes Function(Input$MatchInput) then,
  ) = _CopyWithImpl$Input$MatchInput;

  factory CopyWith$Input$MatchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchInput;

  TRes call({
    String? uuid,
    String? image,
    int? match_court_type,
    String? match_title,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? cost_per_player,
    String? match_level,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
  });
  TRes court_details(
      Iterable<Input$CourtData?>? Function(
              Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
          _fn);
}

class _CopyWithImpl$Input$MatchInput<TRes>
    implements CopyWith$Input$MatchInput<TRes> {
  _CopyWithImpl$Input$MatchInput(
    this._instance,
    this._then,
  );

  final Input$MatchInput _instance;

  final TRes Function(Input$MatchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? image = _undefined,
    Object? match_court_type = _undefined,
    Object? match_title = _undefined,
    Object? locations = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? clubs = _undefined,
    Object? date = _undefined,
    Object? time = _undefined,
    Object? is_recurring = _undefined,
    Object? recurring_type = _undefined,
    Object? recurring_end_date = _undefined,
    Object? match_user_type = _undefined,
    Object? no_slot = _undefined,
    Object? hours = _undefined,
    Object? minutes = _undefined,
    Object? points_to_play = _undefined,
    Object? is_rating = _undefined,
    Object? ratings = _undefined,
    Object? is_booked_court = _undefined,
    Object? court_details = _undefined,
    Object? total_court = _undefined,
    Object? note = _undefined,
    Object? status = _undefined,
    Object? cost_per_player = _undefined,
    Object? match_level = _undefined,
    Object? event_end_date = _undefined,
    Object? event_end_time = _undefined,
    Object? community_image = _undefined,
    Object? community_label_approved = _undefined,
    Object? gender = _undefined,
  }) =>
      _then(Input$MatchInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (image != _undefined) 'image': (image as String?),
        if (match_court_type != _undefined)
          'match_court_type': (match_court_type as int?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (address != _undefined) 'address': (address as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (date != _undefined) 'date': (date as String?),
        if (time != _undefined) 'time': (time as String?),
        if (is_recurring != _undefined) 'is_recurring': (is_recurring as int?),
        if (recurring_type != _undefined)
          'recurring_type': (recurring_type as int?),
        if (recurring_end_date != _undefined)
          'recurring_end_date': (recurring_end_date as String?),
        if (match_user_type != _undefined)
          'match_user_type': (match_user_type as int?),
        if (no_slot != _undefined) 'no_slot': (no_slot as int?),
        if (hours != _undefined) 'hours': (hours as String?),
        if (minutes != _undefined) 'minutes': (minutes as String?),
        if (points_to_play != _undefined)
          'points_to_play': (points_to_play as int?),
        if (is_rating != _undefined) 'is_rating': (is_rating as int?),
        if (ratings != _undefined) 'ratings': (ratings as String?),
        if (is_booked_court != _undefined)
          'is_booked_court': (is_booked_court as int?),
        if (court_details != _undefined)
          'court_details': (court_details as List<Input$CourtData?>?),
        if (total_court != _undefined) 'total_court': (total_court as int?),
        if (note != _undefined) 'note': (note as String?),
        if (status != _undefined) 'status': (status as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (match_level != _undefined) 'match_level': (match_level as String?),
        if (event_end_date != _undefined)
          'event_end_date': (event_end_date as String?),
        if (event_end_time != _undefined)
          'event_end_time': (event_end_time as String?),
        if (community_image != _undefined)
          'community_image': (community_image as String?),
        if (community_label_approved != _undefined)
          'community_label_approved': (community_label_approved as int?),
        if (gender != _undefined) 'gender': (gender as int?),
      }));

  TRes court_details(
          Iterable<Input$CourtData?>? Function(
                  Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
              _fn) =>
      call(
          court_details: _fn(_instance.court_details?.map((e) => e == null
              ? null
              : CopyWith$Input$CourtData(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$MatchInput<TRes>
    implements CopyWith$Input$MatchInput<TRes> {
  _CopyWithStubImpl$Input$MatchInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? image,
    int? match_court_type,
    String? match_title,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? is_recurring,
    int? recurring_type,
    String? recurring_end_date,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? cost_per_player,
    String? match_level,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_label_approved,
    int? gender,
  }) =>
      _res;

  court_details(_fn) => _res;
}

class Input$CustomRecurring {
  factory Input$CustomRecurring({
    int? type,
    int? repeat,
    List<String?>? repeat_week,
    Input$repeat_month? repeat_month,
    int? is_end,
    String? end_date,
  }) =>
      Input$CustomRecurring._({
        if (type != null) r'type': type,
        if (repeat != null) r'repeat': repeat,
        if (repeat_week != null) r'repeat_week': repeat_week,
        if (repeat_month != null) r'repeat_month': repeat_month,
        if (is_end != null) r'is_end': is_end,
        if (end_date != null) r'end_date': end_date,
      });

  Input$CustomRecurring._(this._$data);

  factory Input$CustomRecurring.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    if (data.containsKey('repeat')) {
      final l$repeat = data['repeat'];
      result$data['repeat'] = (l$repeat as int?);
    }
    if (data.containsKey('repeat_week')) {
      final l$repeat_week = data['repeat_week'];
      result$data['repeat_week'] = (l$repeat_week as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('repeat_month')) {
      final l$repeat_month = data['repeat_month'];
      result$data['repeat_month'] = l$repeat_month == null
          ? null
          : Input$repeat_month.fromJson(
              (l$repeat_month as Map<String, dynamic>));
    }
    if (data.containsKey('is_end')) {
      final l$is_end = data['is_end'];
      result$data['is_end'] = (l$is_end as int?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    return Input$CustomRecurring._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get type => (_$data['type'] as int?);

  int? get repeat => (_$data['repeat'] as int?);

  List<String?>? get repeat_week => (_$data['repeat_week'] as List<String?>?);

  Input$repeat_month? get repeat_month =>
      (_$data['repeat_month'] as Input$repeat_month?);

  int? get is_end => (_$data['is_end'] as int?);

  String? get end_date => (_$data['end_date'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('repeat')) {
      final l$repeat = repeat;
      result$data['repeat'] = l$repeat;
    }
    if (_$data.containsKey('repeat_week')) {
      final l$repeat_week = repeat_week;
      result$data['repeat_week'] = l$repeat_week?.map((e) => e).toList();
    }
    if (_$data.containsKey('repeat_month')) {
      final l$repeat_month = repeat_month;
      result$data['repeat_month'] = l$repeat_month?.toJson();
    }
    if (_$data.containsKey('is_end')) {
      final l$is_end = is_end;
      result$data['is_end'] = l$is_end;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    return result$data;
  }

  CopyWith$Input$CustomRecurring<Input$CustomRecurring> get copyWith =>
      CopyWith$Input$CustomRecurring(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomRecurring) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$repeat = repeat;
    final lOther$repeat = other.repeat;
    if (_$data.containsKey('repeat') != other._$data.containsKey('repeat')) {
      return false;
    }
    if (l$repeat != lOther$repeat) {
      return false;
    }
    final l$repeat_week = repeat_week;
    final lOther$repeat_week = other.repeat_week;
    if (_$data.containsKey('repeat_week') !=
        other._$data.containsKey('repeat_week')) {
      return false;
    }
    if (l$repeat_week != null && lOther$repeat_week != null) {
      if (l$repeat_week.length != lOther$repeat_week.length) {
        return false;
      }
      for (int i = 0; i < l$repeat_week.length; i++) {
        final l$repeat_week$entry = l$repeat_week[i];
        final lOther$repeat_week$entry = lOther$repeat_week[i];
        if (l$repeat_week$entry != lOther$repeat_week$entry) {
          return false;
        }
      }
    } else if (l$repeat_week != lOther$repeat_week) {
      return false;
    }
    final l$repeat_month = repeat_month;
    final lOther$repeat_month = other.repeat_month;
    if (_$data.containsKey('repeat_month') !=
        other._$data.containsKey('repeat_month')) {
      return false;
    }
    if (l$repeat_month != lOther$repeat_month) {
      return false;
    }
    final l$is_end = is_end;
    final lOther$is_end = other.is_end;
    if (_$data.containsKey('is_end') != other._$data.containsKey('is_end')) {
      return false;
    }
    if (l$is_end != lOther$is_end) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$repeat = repeat;
    final l$repeat_week = repeat_week;
    final l$repeat_month = repeat_month;
    final l$is_end = is_end;
    final l$end_date = end_date;
    return Object.hashAll([
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('repeat') ? l$repeat : const {},
      _$data.containsKey('repeat_week')
          ? l$repeat_week == null
              ? null
              : Object.hashAll(l$repeat_week.map((v) => v))
          : const {},
      _$data.containsKey('repeat_month') ? l$repeat_month : const {},
      _$data.containsKey('is_end') ? l$is_end : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomRecurring<TRes> {
  factory CopyWith$Input$CustomRecurring(
    Input$CustomRecurring instance,
    TRes Function(Input$CustomRecurring) then,
  ) = _CopyWithImpl$Input$CustomRecurring;

  factory CopyWith$Input$CustomRecurring.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomRecurring;

  TRes call({
    int? type,
    int? repeat,
    List<String?>? repeat_week,
    Input$repeat_month? repeat_month,
    int? is_end,
    String? end_date,
  });
  CopyWith$Input$repeat_month<TRes> get repeat_month;
}

class _CopyWithImpl$Input$CustomRecurring<TRes>
    implements CopyWith$Input$CustomRecurring<TRes> {
  _CopyWithImpl$Input$CustomRecurring(
    this._instance,
    this._then,
  );

  final Input$CustomRecurring _instance;

  final TRes Function(Input$CustomRecurring) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? repeat = _undefined,
    Object? repeat_week = _undefined,
    Object? repeat_month = _undefined,
    Object? is_end = _undefined,
    Object? end_date = _undefined,
  }) =>
      _then(Input$CustomRecurring._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as int?),
        if (repeat != _undefined) 'repeat': (repeat as int?),
        if (repeat_week != _undefined)
          'repeat_week': (repeat_week as List<String?>?),
        if (repeat_month != _undefined)
          'repeat_month': (repeat_month as Input$repeat_month?),
        if (is_end != _undefined) 'is_end': (is_end as int?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
      }));

  CopyWith$Input$repeat_month<TRes> get repeat_month {
    final local$repeat_month = _instance.repeat_month;
    return local$repeat_month == null
        ? CopyWith$Input$repeat_month.stub(_then(_instance))
        : CopyWith$Input$repeat_month(
            local$repeat_month, (e) => call(repeat_month: e));
  }
}

class _CopyWithStubImpl$Input$CustomRecurring<TRes>
    implements CopyWith$Input$CustomRecurring<TRes> {
  _CopyWithStubImpl$Input$CustomRecurring(this._res);

  TRes _res;

  call({
    int? type,
    int? repeat,
    List<String?>? repeat_week,
    Input$repeat_month? repeat_month,
    int? is_end,
    String? end_date,
  }) =>
      _res;

  CopyWith$Input$repeat_month<TRes> get repeat_month =>
      CopyWith$Input$repeat_month.stub(_res);
}

class Input$repeat_month {
  factory Input$repeat_month({
    int? is_date,
    String? date,
    String? day,
    int? occurance,
  }) =>
      Input$repeat_month._({
        if (is_date != null) r'is_date': is_date,
        if (date != null) r'date': date,
        if (day != null) r'day': day,
        if (occurance != null) r'occurance': occurance,
      });

  Input$repeat_month._(this._$data);

  factory Input$repeat_month.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is_date')) {
      final l$is_date = data['is_date'];
      result$data['is_date'] = (l$is_date as int?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('day')) {
      final l$day = data['day'];
      result$data['day'] = (l$day as String?);
    }
    if (data.containsKey('occurance')) {
      final l$occurance = data['occurance'];
      result$data['occurance'] = (l$occurance as int?);
    }
    return Input$repeat_month._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get is_date => (_$data['is_date'] as int?);

  String? get date => (_$data['date'] as String?);

  String? get day => (_$data['day'] as String?);

  int? get occurance => (_$data['occurance'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is_date')) {
      final l$is_date = is_date;
      result$data['is_date'] = l$is_date;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('day')) {
      final l$day = day;
      result$data['day'] = l$day;
    }
    if (_$data.containsKey('occurance')) {
      final l$occurance = occurance;
      result$data['occurance'] = l$occurance;
    }
    return result$data;
  }

  CopyWith$Input$repeat_month<Input$repeat_month> get copyWith =>
      CopyWith$Input$repeat_month(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$repeat_month) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$is_date = is_date;
    final lOther$is_date = other.is_date;
    if (_$data.containsKey('is_date') != other._$data.containsKey('is_date')) {
      return false;
    }
    if (l$is_date != lOther$is_date) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$day = day;
    final lOther$day = other.day;
    if (_$data.containsKey('day') != other._$data.containsKey('day')) {
      return false;
    }
    if (l$day != lOther$day) {
      return false;
    }
    final l$occurance = occurance;
    final lOther$occurance = other.occurance;
    if (_$data.containsKey('occurance') !=
        other._$data.containsKey('occurance')) {
      return false;
    }
    if (l$occurance != lOther$occurance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$is_date = is_date;
    final l$date = date;
    final l$day = day;
    final l$occurance = occurance;
    return Object.hashAll([
      _$data.containsKey('is_date') ? l$is_date : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('day') ? l$day : const {},
      _$data.containsKey('occurance') ? l$occurance : const {},
    ]);
  }
}

abstract class CopyWith$Input$repeat_month<TRes> {
  factory CopyWith$Input$repeat_month(
    Input$repeat_month instance,
    TRes Function(Input$repeat_month) then,
  ) = _CopyWithImpl$Input$repeat_month;

  factory CopyWith$Input$repeat_month.stub(TRes res) =
      _CopyWithStubImpl$Input$repeat_month;

  TRes call({
    int? is_date,
    String? date,
    String? day,
    int? occurance,
  });
}

class _CopyWithImpl$Input$repeat_month<TRes>
    implements CopyWith$Input$repeat_month<TRes> {
  _CopyWithImpl$Input$repeat_month(
    this._instance,
    this._then,
  );

  final Input$repeat_month _instance;

  final TRes Function(Input$repeat_month) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? is_date = _undefined,
    Object? date = _undefined,
    Object? day = _undefined,
    Object? occurance = _undefined,
  }) =>
      _then(Input$repeat_month._({
        ..._instance._$data,
        if (is_date != _undefined) 'is_date': (is_date as int?),
        if (date != _undefined) 'date': (date as String?),
        if (day != _undefined) 'day': (day as String?),
        if (occurance != _undefined) 'occurance': (occurance as int?),
      }));
}

class _CopyWithStubImpl$Input$repeat_month<TRes>
    implements CopyWith$Input$repeat_month<TRes> {
  _CopyWithStubImpl$Input$repeat_month(this._res);

  TRes _res;

  call({
    int? is_date,
    String? date,
    String? day,
    int? occurance,
  }) =>
      _res;
}

class Input$TireData {
  factory Input$TireData({
    int? tier_price,
    String? tier_description,
  }) =>
      Input$TireData._({
        if (tier_price != null) r'tier_price': tier_price,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$TireData._(this._$data);

  factory Input$TireData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('tier_price')) {
      final l$tier_price = data['tier_price'];
      result$data['tier_price'] = (l$tier_price as int?);
    }
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$TireData._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get tier_price => (_$data['tier_price'] as int?);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('tier_price')) {
      final l$tier_price = tier_price;
      result$data['tier_price'] = l$tier_price;
    }
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$TireData<Input$TireData> get copyWith =>
      CopyWith$Input$TireData(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TireData) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$tier_price = tier_price;
    final lOther$tier_price = other.tier_price;
    if (_$data.containsKey('tier_price') !=
        other._$data.containsKey('tier_price')) {
      return false;
    }
    if (l$tier_price != lOther$tier_price) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$tier_price = tier_price;
    final l$tier_description = tier_description;
    return Object.hashAll([
      _$data.containsKey('tier_price') ? l$tier_price : const {},
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TireData<TRes> {
  factory CopyWith$Input$TireData(
    Input$TireData instance,
    TRes Function(Input$TireData) then,
  ) = _CopyWithImpl$Input$TireData;

  factory CopyWith$Input$TireData.stub(TRes res) =
      _CopyWithStubImpl$Input$TireData;

  TRes call({
    int? tier_price,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$TireData<TRes>
    implements CopyWith$Input$TireData<TRes> {
  _CopyWithImpl$Input$TireData(
    this._instance,
    this._then,
  );

  final Input$TireData _instance;

  final TRes Function(Input$TireData) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? tier_price = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$TireData._({
        ..._instance._$data,
        if (tier_price != _undefined) 'tier_price': (tier_price as int?),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$TireData<TRes>
    implements CopyWith$Input$TireData<TRes> {
  _CopyWithStubImpl$Input$TireData(this._res);

  TRes _res;

  call({
    int? tier_price,
    String? tier_description,
  }) =>
      _res;
}

class Input$viewMatchInput {
  factory Input$viewMatchInput({
    required String uuid,
    bool? is_common_detail,
  }) =>
      Input$viewMatchInput._({
        r'uuid': uuid,
        if (is_common_detail != null) r'is_common_detail': is_common_detail,
      });

  Input$viewMatchInput._(this._$data);

  factory Input$viewMatchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('is_common_detail')) {
      final l$is_common_detail = data['is_common_detail'];
      result$data['is_common_detail'] = (l$is_common_detail as bool?);
    }
    return Input$viewMatchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  bool? get is_common_detail => (_$data['is_common_detail'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('is_common_detail')) {
      final l$is_common_detail = is_common_detail;
      result$data['is_common_detail'] = l$is_common_detail;
    }
    return result$data;
  }

  CopyWith$Input$viewMatchInput<Input$viewMatchInput> get copyWith =>
      CopyWith$Input$viewMatchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewMatchInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$is_common_detail = is_common_detail;
    final lOther$is_common_detail = other.is_common_detail;
    if (_$data.containsKey('is_common_detail') !=
        other._$data.containsKey('is_common_detail')) {
      return false;
    }
    if (l$is_common_detail != lOther$is_common_detail) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$is_common_detail = is_common_detail;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('is_common_detail') ? l$is_common_detail : const {},
    ]);
  }
}

abstract class CopyWith$Input$viewMatchInput<TRes> {
  factory CopyWith$Input$viewMatchInput(
    Input$viewMatchInput instance,
    TRes Function(Input$viewMatchInput) then,
  ) = _CopyWithImpl$Input$viewMatchInput;

  factory CopyWith$Input$viewMatchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewMatchInput;

  TRes call({
    String? uuid,
    bool? is_common_detail,
  });
}

class _CopyWithImpl$Input$viewMatchInput<TRes>
    implements CopyWith$Input$viewMatchInput<TRes> {
  _CopyWithImpl$Input$viewMatchInput(
    this._instance,
    this._then,
  );

  final Input$viewMatchInput _instance;

  final TRes Function(Input$viewMatchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? is_common_detail = _undefined,
  }) =>
      _then(Input$viewMatchInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (is_common_detail != _undefined)
          'is_common_detail': (is_common_detail as bool?),
      }));
}

class _CopyWithStubImpl$Input$viewMatchInput<TRes>
    implements CopyWith$Input$viewMatchInput<TRes> {
  _CopyWithStubImpl$Input$viewMatchInput(this._res);

  TRes _res;

  call({
    String? uuid,
    bool? is_common_detail,
  }) =>
      _res;
}

class Input$MatchPaginationInput {
  factory Input$MatchPaginationInput({
    required int offset,
    int? limit,
    String? title,
    String? status,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$MatchPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (status != null) r'status': status,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$MatchPaginationInput._(this._$data);

  factory Input$MatchPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$MatchPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$MatchPaginationInput<Input$MatchPaginationInput>
      get copyWith => CopyWith$Input$MatchPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$status = status;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchPaginationInput<TRes> {
  factory CopyWith$Input$MatchPaginationInput(
    Input$MatchPaginationInput instance,
    TRes Function(Input$MatchPaginationInput) then,
  ) = _CopyWithImpl$Input$MatchPaginationInput;

  factory CopyWith$Input$MatchPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? status,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$MatchPaginationInput<TRes>
    implements CopyWith$Input$MatchPaginationInput<TRes> {
  _CopyWithImpl$Input$MatchPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MatchPaginationInput _instance;

  final TRes Function(Input$MatchPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? status = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$MatchPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (status != _undefined) 'status': (status as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$MatchPaginationInput<TRes>
    implements CopyWith$Input$MatchPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MatchPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? status,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$addPaymentInput {
  factory Input$addPaymentInput({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    String? tier_description,
  }) =>
      Input$addPaymentInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (transaction_fee != null) r'transaction_fee': transaction_fee,
        if (admin_fee != null) r'admin_fee': admin_fee,
        if (total != null) r'total': total,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$addPaymentInput._(this._$data);

  factory Input$addPaymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('transaction_fee')) {
      final l$transaction_fee = data['transaction_fee'];
      result$data['transaction_fee'] = (l$transaction_fee as String?);
    }
    if (data.containsKey('admin_fee')) {
      final l$admin_fee = data['admin_fee'];
      result$data['admin_fee'] = (l$admin_fee as String?);
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] = (l$total as String?);
    }
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$addPaymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get transaction_fee => (_$data['transaction_fee'] as String?);

  String? get admin_fee => (_$data['admin_fee'] as String?);

  String? get total => (_$data['total'] as String?);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('transaction_fee')) {
      final l$transaction_fee = transaction_fee;
      result$data['transaction_fee'] = l$transaction_fee;
    }
    if (_$data.containsKey('admin_fee')) {
      final l$admin_fee = admin_fee;
      result$data['admin_fee'] = l$admin_fee;
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] = l$total;
    }
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$addPaymentInput<Input$addPaymentInput> get copyWith =>
      CopyWith$Input$addPaymentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addPaymentInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$transaction_fee = transaction_fee;
    final lOther$transaction_fee = other.transaction_fee;
    if (_$data.containsKey('transaction_fee') !=
        other._$data.containsKey('transaction_fee')) {
      return false;
    }
    if (l$transaction_fee != lOther$transaction_fee) {
      return false;
    }
    final l$admin_fee = admin_fee;
    final lOther$admin_fee = other.admin_fee;
    if (_$data.containsKey('admin_fee') !=
        other._$data.containsKey('admin_fee')) {
      return false;
    }
    if (l$admin_fee != lOther$admin_fee) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$cost_per_player = cost_per_player;
    final l$transaction_fee = transaction_fee;
    final l$admin_fee = admin_fee;
    final l$total = total;
    final l$tier_description = tier_description;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('transaction_fee') ? l$transaction_fee : const {},
      _$data.containsKey('admin_fee') ? l$admin_fee : const {},
      _$data.containsKey('total') ? l$total : const {},
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$addPaymentInput<TRes> {
  factory CopyWith$Input$addPaymentInput(
    Input$addPaymentInput instance,
    TRes Function(Input$addPaymentInput) then,
  ) = _CopyWithImpl$Input$addPaymentInput;

  factory CopyWith$Input$addPaymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$addPaymentInput;

  TRes call({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$addPaymentInput<TRes>
    implements CopyWith$Input$addPaymentInput<TRes> {
  _CopyWithImpl$Input$addPaymentInput(
    this._instance,
    this._then,
  );

  final Input$addPaymentInput _instance;

  final TRes Function(Input$addPaymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? cost_per_player = _undefined,
    Object? transaction_fee = _undefined,
    Object? admin_fee = _undefined,
    Object? total = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$addPaymentInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (transaction_fee != _undefined)
          'transaction_fee': (transaction_fee as String?),
        if (admin_fee != _undefined) 'admin_fee': (admin_fee as String?),
        if (total != _undefined) 'total': (total as String?),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$addPaymentInput<TRes>
    implements CopyWith$Input$addPaymentInput<TRes> {
  _CopyWithStubImpl$Input$addPaymentInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    String? tier_description,
  }) =>
      _res;
}

class Input$UpdateMtchCostInput {
  factory Input$UpdateMtchCostInput({
    String? match_uuid,
    String? cost_per_player,
  }) =>
      Input$UpdateMtchCostInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
      });

  Input$UpdateMtchCostInput._(this._$data);

  factory Input$UpdateMtchCostInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    return Input$UpdateMtchCostInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    return result$data;
  }

  CopyWith$Input$UpdateMtchCostInput<Input$UpdateMtchCostInput> get copyWith =>
      CopyWith$Input$UpdateMtchCostInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateMtchCostInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$cost_per_player = cost_per_player;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateMtchCostInput<TRes> {
  factory CopyWith$Input$UpdateMtchCostInput(
    Input$UpdateMtchCostInput instance,
    TRes Function(Input$UpdateMtchCostInput) then,
  ) = _CopyWithImpl$Input$UpdateMtchCostInput;

  factory CopyWith$Input$UpdateMtchCostInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateMtchCostInput;

  TRes call({
    String? match_uuid,
    String? cost_per_player,
  });
}

class _CopyWithImpl$Input$UpdateMtchCostInput<TRes>
    implements CopyWith$Input$UpdateMtchCostInput<TRes> {
  _CopyWithImpl$Input$UpdateMtchCostInput(
    this._instance,
    this._then,
  );

  final Input$UpdateMtchCostInput _instance;

  final TRes Function(Input$UpdateMtchCostInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? cost_per_player = _undefined,
  }) =>
      _then(Input$UpdateMtchCostInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateMtchCostInput<TRes>
    implements CopyWith$Input$UpdateMtchCostInput<TRes> {
  _CopyWithStubImpl$Input$UpdateMtchCostInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? cost_per_player,
  }) =>
      _res;
}

class Input$MatchFrontInput {
  factory Input$MatchFrontInput({
    required String uuid,
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    String? match_level,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_image_changed,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  }) =>
      Input$MatchFrontInput._({
        r'uuid': uuid,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (match_court_type != null) r'match_court_type': match_court_type,
        if (match_title != null) r'match_title': match_title,
        if (match_title_uuid != null) r'match_title_uuid': match_title_uuid,
        if (locations != null) r'locations': locations,
        if (address != null) r'address': address,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (clubs != null) r'clubs': clubs,
        if (date != null) r'date': date,
        if (time != null) r'time': time,
        if (match_user_type != null) r'match_user_type': match_user_type,
        if (no_slot != null) r'no_slot': no_slot,
        if (hours != null) r'hours': hours,
        if (minutes != null) r'minutes': minutes,
        if (points_to_play != null) r'points_to_play': points_to_play,
        if (is_rating != null) r'is_rating': is_rating,
        if (ratings != null) r'ratings': ratings,
        if (is_booked_court != null) r'is_booked_court': is_booked_court,
        if (court_details != null) r'court_details': court_details,
        if (total_court != null) r'total_court': total_court,
        if (note != null) r'note': note,
        if (status != null) r'status': status,
        if (time_zone != null) r'time_zone': time_zone,
        if (is_private != null) r'is_private': is_private,
        if (is_event != null) r'is_event': is_event,
        if (total_players != null) r'total_players': total_players,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (match_level != null) r'match_level': match_level,
        if (match_organiser != null) r'match_organiser': match_organiser,
        if (event_end_date != null) r'event_end_date': event_end_date,
        if (event_end_time != null) r'event_end_time': event_end_time,
        if (community_image != null) r'community_image': community_image,
        if (community_image_changed != null)
          r'community_image_changed': community_image_changed,
        if (gender != null) r'gender': gender,
        if (tier_details != null) r'tier_details': tier_details,
        if (tournament_bracket_type != null)
          r'tournament_bracket_type': tournament_bracket_type,
      });

  Input$MatchFrontInput._(this._$data);

  factory Input$MatchFrontInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('match_court_type')) {
      final l$match_court_type = data['match_court_type'];
      result$data['match_court_type'] = (l$match_court_type as int?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_title_uuid')) {
      final l$match_title_uuid = data['match_title_uuid'];
      result$data['match_title_uuid'] = (l$match_title_uuid as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = (l$address as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('time')) {
      final l$time = data['time'];
      result$data['time'] = (l$time as String?);
    }
    if (data.containsKey('match_user_type')) {
      final l$match_user_type = data['match_user_type'];
      result$data['match_user_type'] = (l$match_user_type as int?);
    }
    if (data.containsKey('no_slot')) {
      final l$no_slot = data['no_slot'];
      result$data['no_slot'] = (l$no_slot as int?);
    }
    if (data.containsKey('hours')) {
      final l$hours = data['hours'];
      result$data['hours'] = (l$hours as String?);
    }
    if (data.containsKey('minutes')) {
      final l$minutes = data['minutes'];
      result$data['minutes'] = (l$minutes as String?);
    }
    if (data.containsKey('points_to_play')) {
      final l$points_to_play = data['points_to_play'];
      result$data['points_to_play'] = (l$points_to_play as int?);
    }
    if (data.containsKey('is_rating')) {
      final l$is_rating = data['is_rating'];
      result$data['is_rating'] = (l$is_rating as int?);
    }
    if (data.containsKey('ratings')) {
      final l$ratings = data['ratings'];
      result$data['ratings'] = (l$ratings as String?);
    }
    if (data.containsKey('is_booked_court')) {
      final l$is_booked_court = data['is_booked_court'];
      result$data['is_booked_court'] = (l$is_booked_court as int?);
    }
    if (data.containsKey('court_details')) {
      final l$court_details = data['court_details'];
      result$data['court_details'] = (l$court_details as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$CourtData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('total_court')) {
      final l$total_court = data['total_court'];
      result$data['total_court'] = (l$total_court as int?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('time_zone')) {
      final l$time_zone = data['time_zone'];
      result$data['time_zone'] = (l$time_zone as String?);
    }
    if (data.containsKey('is_private')) {
      final l$is_private = data['is_private'];
      result$data['is_private'] = (l$is_private as int?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('total_players')) {
      final l$total_players = data['total_players'];
      result$data['total_players'] = (l$total_players as int?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('match_level')) {
      final l$match_level = data['match_level'];
      result$data['match_level'] = (l$match_level as String?);
    }
    if (data.containsKey('match_organiser')) {
      final l$match_organiser = data['match_organiser'];
      result$data['match_organiser'] = (l$match_organiser as int?);
    }
    if (data.containsKey('event_end_date')) {
      final l$event_end_date = data['event_end_date'];
      result$data['event_end_date'] = (l$event_end_date as String?);
    }
    if (data.containsKey('event_end_time')) {
      final l$event_end_time = data['event_end_time'];
      result$data['event_end_time'] = (l$event_end_time as String?);
    }
    if (data.containsKey('community_image')) {
      final l$community_image = data['community_image'];
      result$data['community_image'] = (l$community_image as String?);
    }
    if (data.containsKey('community_image_changed')) {
      final l$community_image_changed = data['community_image_changed'];
      result$data['community_image_changed'] =
          (l$community_image_changed as int?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    if (data.containsKey('tier_details')) {
      final l$tier_details = data['tier_details'];
      result$data['tier_details'] = (l$tier_details as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$TireData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('tournament_bracket_type')) {
      final l$tournament_bracket_type = data['tournament_bracket_type'];
      result$data['tournament_bracket_type'] =
          (l$tournament_bracket_type as int?);
    }
    return Input$MatchFrontInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  int? get match_court_type => (_$data['match_court_type'] as int?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_title_uuid => (_$data['match_title_uuid'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get address => (_$data['address'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get date => (_$data['date'] as String?);

  String? get time => (_$data['time'] as String?);

  int? get match_user_type => (_$data['match_user_type'] as int?);

  int? get no_slot => (_$data['no_slot'] as int?);

  String? get hours => (_$data['hours'] as String?);

  String? get minutes => (_$data['minutes'] as String?);

  int? get points_to_play => (_$data['points_to_play'] as int?);

  int? get is_rating => (_$data['is_rating'] as int?);

  String? get ratings => (_$data['ratings'] as String?);

  int? get is_booked_court => (_$data['is_booked_court'] as int?);

  List<Input$CourtData?>? get court_details =>
      (_$data['court_details'] as List<Input$CourtData?>?);

  int? get total_court => (_$data['total_court'] as int?);

  String? get note => (_$data['note'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get time_zone => (_$data['time_zone'] as String?);

  int? get is_private => (_$data['is_private'] as int?);

  int? get is_event => (_$data['is_event'] as int?);

  int? get total_players => (_$data['total_players'] as int?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get match_level => (_$data['match_level'] as String?);

  int? get match_organiser => (_$data['match_organiser'] as int?);

  String? get event_end_date => (_$data['event_end_date'] as String?);

  String? get event_end_time => (_$data['event_end_time'] as String?);

  String? get community_image => (_$data['community_image'] as String?);

  int? get community_image_changed =>
      (_$data['community_image_changed'] as int?);

  int? get gender => (_$data['gender'] as int?);

  List<Input$TireData?>? get tier_details =>
      (_$data['tier_details'] as List<Input$TireData?>?);

  int? get tournament_bracket_type =>
      (_$data['tournament_bracket_type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('match_court_type')) {
      final l$match_court_type = match_court_type;
      result$data['match_court_type'] = l$match_court_type;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_title_uuid')) {
      final l$match_title_uuid = match_title_uuid;
      result$data['match_title_uuid'] = l$match_title_uuid;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('time')) {
      final l$time = time;
      result$data['time'] = l$time;
    }
    if (_$data.containsKey('match_user_type')) {
      final l$match_user_type = match_user_type;
      result$data['match_user_type'] = l$match_user_type;
    }
    if (_$data.containsKey('no_slot')) {
      final l$no_slot = no_slot;
      result$data['no_slot'] = l$no_slot;
    }
    if (_$data.containsKey('hours')) {
      final l$hours = hours;
      result$data['hours'] = l$hours;
    }
    if (_$data.containsKey('minutes')) {
      final l$minutes = minutes;
      result$data['minutes'] = l$minutes;
    }
    if (_$data.containsKey('points_to_play')) {
      final l$points_to_play = points_to_play;
      result$data['points_to_play'] = l$points_to_play;
    }
    if (_$data.containsKey('is_rating')) {
      final l$is_rating = is_rating;
      result$data['is_rating'] = l$is_rating;
    }
    if (_$data.containsKey('ratings')) {
      final l$ratings = ratings;
      result$data['ratings'] = l$ratings;
    }
    if (_$data.containsKey('is_booked_court')) {
      final l$is_booked_court = is_booked_court;
      result$data['is_booked_court'] = l$is_booked_court;
    }
    if (_$data.containsKey('court_details')) {
      final l$court_details = court_details;
      result$data['court_details'] =
          l$court_details?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('total_court')) {
      final l$total_court = total_court;
      result$data['total_court'] = l$total_court;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('time_zone')) {
      final l$time_zone = time_zone;
      result$data['time_zone'] = l$time_zone;
    }
    if (_$data.containsKey('is_private')) {
      final l$is_private = is_private;
      result$data['is_private'] = l$is_private;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('total_players')) {
      final l$total_players = total_players;
      result$data['total_players'] = l$total_players;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('match_level')) {
      final l$match_level = match_level;
      result$data['match_level'] = l$match_level;
    }
    if (_$data.containsKey('match_organiser')) {
      final l$match_organiser = match_organiser;
      result$data['match_organiser'] = l$match_organiser;
    }
    if (_$data.containsKey('event_end_date')) {
      final l$event_end_date = event_end_date;
      result$data['event_end_date'] = l$event_end_date;
    }
    if (_$data.containsKey('event_end_time')) {
      final l$event_end_time = event_end_time;
      result$data['event_end_time'] = l$event_end_time;
    }
    if (_$data.containsKey('community_image')) {
      final l$community_image = community_image;
      result$data['community_image'] = l$community_image;
    }
    if (_$data.containsKey('community_image_changed')) {
      final l$community_image_changed = community_image_changed;
      result$data['community_image_changed'] = l$community_image_changed;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('tier_details')) {
      final l$tier_details = tier_details;
      result$data['tier_details'] =
          l$tier_details?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('tournament_bracket_type')) {
      final l$tournament_bracket_type = tournament_bracket_type;
      result$data['tournament_bracket_type'] = l$tournament_bracket_type;
    }
    return result$data;
  }

  CopyWith$Input$MatchFrontInput<Input$MatchFrontInput> get copyWith =>
      CopyWith$Input$MatchFrontInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchFrontInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$match_court_type = match_court_type;
    final lOther$match_court_type = other.match_court_type;
    if (_$data.containsKey('match_court_type') !=
        other._$data.containsKey('match_court_type')) {
      return false;
    }
    if (l$match_court_type != lOther$match_court_type) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_title_uuid = match_title_uuid;
    final lOther$match_title_uuid = other.match_title_uuid;
    if (_$data.containsKey('match_title_uuid') !=
        other._$data.containsKey('match_title_uuid')) {
      return false;
    }
    if (l$match_title_uuid != lOther$match_title_uuid) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$time = time;
    final lOther$time = other.time;
    if (_$data.containsKey('time') != other._$data.containsKey('time')) {
      return false;
    }
    if (l$time != lOther$time) {
      return false;
    }
    final l$match_user_type = match_user_type;
    final lOther$match_user_type = other.match_user_type;
    if (_$data.containsKey('match_user_type') !=
        other._$data.containsKey('match_user_type')) {
      return false;
    }
    if (l$match_user_type != lOther$match_user_type) {
      return false;
    }
    final l$no_slot = no_slot;
    final lOther$no_slot = other.no_slot;
    if (_$data.containsKey('no_slot') != other._$data.containsKey('no_slot')) {
      return false;
    }
    if (l$no_slot != lOther$no_slot) {
      return false;
    }
    final l$hours = hours;
    final lOther$hours = other.hours;
    if (_$data.containsKey('hours') != other._$data.containsKey('hours')) {
      return false;
    }
    if (l$hours != lOther$hours) {
      return false;
    }
    final l$minutes = minutes;
    final lOther$minutes = other.minutes;
    if (_$data.containsKey('minutes') != other._$data.containsKey('minutes')) {
      return false;
    }
    if (l$minutes != lOther$minutes) {
      return false;
    }
    final l$points_to_play = points_to_play;
    final lOther$points_to_play = other.points_to_play;
    if (_$data.containsKey('points_to_play') !=
        other._$data.containsKey('points_to_play')) {
      return false;
    }
    if (l$points_to_play != lOther$points_to_play) {
      return false;
    }
    final l$is_rating = is_rating;
    final lOther$is_rating = other.is_rating;
    if (_$data.containsKey('is_rating') !=
        other._$data.containsKey('is_rating')) {
      return false;
    }
    if (l$is_rating != lOther$is_rating) {
      return false;
    }
    final l$ratings = ratings;
    final lOther$ratings = other.ratings;
    if (_$data.containsKey('ratings') != other._$data.containsKey('ratings')) {
      return false;
    }
    if (l$ratings != lOther$ratings) {
      return false;
    }
    final l$is_booked_court = is_booked_court;
    final lOther$is_booked_court = other.is_booked_court;
    if (_$data.containsKey('is_booked_court') !=
        other._$data.containsKey('is_booked_court')) {
      return false;
    }
    if (l$is_booked_court != lOther$is_booked_court) {
      return false;
    }
    final l$court_details = court_details;
    final lOther$court_details = other.court_details;
    if (_$data.containsKey('court_details') !=
        other._$data.containsKey('court_details')) {
      return false;
    }
    if (l$court_details != null && lOther$court_details != null) {
      if (l$court_details.length != lOther$court_details.length) {
        return false;
      }
      for (int i = 0; i < l$court_details.length; i++) {
        final l$court_details$entry = l$court_details[i];
        final lOther$court_details$entry = lOther$court_details[i];
        if (l$court_details$entry != lOther$court_details$entry) {
          return false;
        }
      }
    } else if (l$court_details != lOther$court_details) {
      return false;
    }
    final l$total_court = total_court;
    final lOther$total_court = other.total_court;
    if (_$data.containsKey('total_court') !=
        other._$data.containsKey('total_court')) {
      return false;
    }
    if (l$total_court != lOther$total_court) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$time_zone = time_zone;
    final lOther$time_zone = other.time_zone;
    if (_$data.containsKey('time_zone') !=
        other._$data.containsKey('time_zone')) {
      return false;
    }
    if (l$time_zone != lOther$time_zone) {
      return false;
    }
    final l$is_private = is_private;
    final lOther$is_private = other.is_private;
    if (_$data.containsKey('is_private') !=
        other._$data.containsKey('is_private')) {
      return false;
    }
    if (l$is_private != lOther$is_private) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$total_players = total_players;
    final lOther$total_players = other.total_players;
    if (_$data.containsKey('total_players') !=
        other._$data.containsKey('total_players')) {
      return false;
    }
    if (l$total_players != lOther$total_players) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$match_level = match_level;
    final lOther$match_level = other.match_level;
    if (_$data.containsKey('match_level') !=
        other._$data.containsKey('match_level')) {
      return false;
    }
    if (l$match_level != lOther$match_level) {
      return false;
    }
    final l$match_organiser = match_organiser;
    final lOther$match_organiser = other.match_organiser;
    if (_$data.containsKey('match_organiser') !=
        other._$data.containsKey('match_organiser')) {
      return false;
    }
    if (l$match_organiser != lOther$match_organiser) {
      return false;
    }
    final l$event_end_date = event_end_date;
    final lOther$event_end_date = other.event_end_date;
    if (_$data.containsKey('event_end_date') !=
        other._$data.containsKey('event_end_date')) {
      return false;
    }
    if (l$event_end_date != lOther$event_end_date) {
      return false;
    }
    final l$event_end_time = event_end_time;
    final lOther$event_end_time = other.event_end_time;
    if (_$data.containsKey('event_end_time') !=
        other._$data.containsKey('event_end_time')) {
      return false;
    }
    if (l$event_end_time != lOther$event_end_time) {
      return false;
    }
    final l$community_image = community_image;
    final lOther$community_image = other.community_image;
    if (_$data.containsKey('community_image') !=
        other._$data.containsKey('community_image')) {
      return false;
    }
    if (l$community_image != lOther$community_image) {
      return false;
    }
    final l$community_image_changed = community_image_changed;
    final lOther$community_image_changed = other.community_image_changed;
    if (_$data.containsKey('community_image_changed') !=
        other._$data.containsKey('community_image_changed')) {
      return false;
    }
    if (l$community_image_changed != lOther$community_image_changed) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$tier_details = tier_details;
    final lOther$tier_details = other.tier_details;
    if (_$data.containsKey('tier_details') !=
        other._$data.containsKey('tier_details')) {
      return false;
    }
    if (l$tier_details != null && lOther$tier_details != null) {
      if (l$tier_details.length != lOther$tier_details.length) {
        return false;
      }
      for (int i = 0; i < l$tier_details.length; i++) {
        final l$tier_details$entry = l$tier_details[i];
        final lOther$tier_details$entry = lOther$tier_details[i];
        if (l$tier_details$entry != lOther$tier_details$entry) {
          return false;
        }
      }
    } else if (l$tier_details != lOther$tier_details) {
      return false;
    }
    final l$tournament_bracket_type = tournament_bracket_type;
    final lOther$tournament_bracket_type = other.tournament_bracket_type;
    if (_$data.containsKey('tournament_bracket_type') !=
        other._$data.containsKey('tournament_bracket_type')) {
      return false;
    }
    if (l$tournament_bracket_type != lOther$tournament_bracket_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$image = image;
    final l$file_path = file_path;
    final l$match_court_type = match_court_type;
    final l$match_title = match_title;
    final l$match_title_uuid = match_title_uuid;
    final l$locations = locations;
    final l$address = address;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$clubs = clubs;
    final l$date = date;
    final l$time = time;
    final l$match_user_type = match_user_type;
    final l$no_slot = no_slot;
    final l$hours = hours;
    final l$minutes = minutes;
    final l$points_to_play = points_to_play;
    final l$is_rating = is_rating;
    final l$ratings = ratings;
    final l$is_booked_court = is_booked_court;
    final l$court_details = court_details;
    final l$total_court = total_court;
    final l$note = note;
    final l$status = status;
    final l$time_zone = time_zone;
    final l$is_private = is_private;
    final l$is_event = is_event;
    final l$total_players = total_players;
    final l$cost_per_player = cost_per_player;
    final l$match_level = match_level;
    final l$match_organiser = match_organiser;
    final l$event_end_date = event_end_date;
    final l$event_end_time = event_end_time;
    final l$community_image = community_image;
    final l$community_image_changed = community_image_changed;
    final l$gender = gender;
    final l$tier_details = tier_details;
    final l$tournament_bracket_type = tournament_bracket_type;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('match_court_type') ? l$match_court_type : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_title_uuid') ? l$match_title_uuid : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('time') ? l$time : const {},
      _$data.containsKey('match_user_type') ? l$match_user_type : const {},
      _$data.containsKey('no_slot') ? l$no_slot : const {},
      _$data.containsKey('hours') ? l$hours : const {},
      _$data.containsKey('minutes') ? l$minutes : const {},
      _$data.containsKey('points_to_play') ? l$points_to_play : const {},
      _$data.containsKey('is_rating') ? l$is_rating : const {},
      _$data.containsKey('ratings') ? l$ratings : const {},
      _$data.containsKey('is_booked_court') ? l$is_booked_court : const {},
      _$data.containsKey('court_details')
          ? l$court_details == null
              ? null
              : Object.hashAll(l$court_details.map((v) => v))
          : const {},
      _$data.containsKey('total_court') ? l$total_court : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('time_zone') ? l$time_zone : const {},
      _$data.containsKey('is_private') ? l$is_private : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('total_players') ? l$total_players : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('match_level') ? l$match_level : const {},
      _$data.containsKey('match_organiser') ? l$match_organiser : const {},
      _$data.containsKey('event_end_date') ? l$event_end_date : const {},
      _$data.containsKey('event_end_time') ? l$event_end_time : const {},
      _$data.containsKey('community_image') ? l$community_image : const {},
      _$data.containsKey('community_image_changed')
          ? l$community_image_changed
          : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('tier_details')
          ? l$tier_details == null
              ? null
              : Object.hashAll(l$tier_details.map((v) => v))
          : const {},
      _$data.containsKey('tournament_bracket_type')
          ? l$tournament_bracket_type
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchFrontInput<TRes> {
  factory CopyWith$Input$MatchFrontInput(
    Input$MatchFrontInput instance,
    TRes Function(Input$MatchFrontInput) then,
  ) = _CopyWithImpl$Input$MatchFrontInput;

  factory CopyWith$Input$MatchFrontInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchFrontInput;

  TRes call({
    String? uuid,
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    String? match_level,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_image_changed,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  });
  TRes court_details(
      Iterable<Input$CourtData?>? Function(
              Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
          _fn);
  TRes tier_details(
      Iterable<Input$TireData?>? Function(
              Iterable<CopyWith$Input$TireData<Input$TireData>?>?)
          _fn);
}

class _CopyWithImpl$Input$MatchFrontInput<TRes>
    implements CopyWith$Input$MatchFrontInput<TRes> {
  _CopyWithImpl$Input$MatchFrontInput(
    this._instance,
    this._then,
  );

  final Input$MatchFrontInput _instance;

  final TRes Function(Input$MatchFrontInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? match_court_type = _undefined,
    Object? match_title = _undefined,
    Object? match_title_uuid = _undefined,
    Object? locations = _undefined,
    Object? address = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? clubs = _undefined,
    Object? date = _undefined,
    Object? time = _undefined,
    Object? match_user_type = _undefined,
    Object? no_slot = _undefined,
    Object? hours = _undefined,
    Object? minutes = _undefined,
    Object? points_to_play = _undefined,
    Object? is_rating = _undefined,
    Object? ratings = _undefined,
    Object? is_booked_court = _undefined,
    Object? court_details = _undefined,
    Object? total_court = _undefined,
    Object? note = _undefined,
    Object? status = _undefined,
    Object? time_zone = _undefined,
    Object? is_private = _undefined,
    Object? is_event = _undefined,
    Object? total_players = _undefined,
    Object? cost_per_player = _undefined,
    Object? match_level = _undefined,
    Object? match_organiser = _undefined,
    Object? event_end_date = _undefined,
    Object? event_end_time = _undefined,
    Object? community_image = _undefined,
    Object? community_image_changed = _undefined,
    Object? gender = _undefined,
    Object? tier_details = _undefined,
    Object? tournament_bracket_type = _undefined,
  }) =>
      _then(Input$MatchFrontInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (match_court_type != _undefined)
          'match_court_type': (match_court_type as int?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_title_uuid != _undefined)
          'match_title_uuid': (match_title_uuid as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (address != _undefined) 'address': (address as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (date != _undefined) 'date': (date as String?),
        if (time != _undefined) 'time': (time as String?),
        if (match_user_type != _undefined)
          'match_user_type': (match_user_type as int?),
        if (no_slot != _undefined) 'no_slot': (no_slot as int?),
        if (hours != _undefined) 'hours': (hours as String?),
        if (minutes != _undefined) 'minutes': (minutes as String?),
        if (points_to_play != _undefined)
          'points_to_play': (points_to_play as int?),
        if (is_rating != _undefined) 'is_rating': (is_rating as int?),
        if (ratings != _undefined) 'ratings': (ratings as String?),
        if (is_booked_court != _undefined)
          'is_booked_court': (is_booked_court as int?),
        if (court_details != _undefined)
          'court_details': (court_details as List<Input$CourtData?>?),
        if (total_court != _undefined) 'total_court': (total_court as int?),
        if (note != _undefined) 'note': (note as String?),
        if (status != _undefined) 'status': (status as String?),
        if (time_zone != _undefined) 'time_zone': (time_zone as String?),
        if (is_private != _undefined) 'is_private': (is_private as int?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (total_players != _undefined)
          'total_players': (total_players as int?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (match_level != _undefined) 'match_level': (match_level as String?),
        if (match_organiser != _undefined)
          'match_organiser': (match_organiser as int?),
        if (event_end_date != _undefined)
          'event_end_date': (event_end_date as String?),
        if (event_end_time != _undefined)
          'event_end_time': (event_end_time as String?),
        if (community_image != _undefined)
          'community_image': (community_image as String?),
        if (community_image_changed != _undefined)
          'community_image_changed': (community_image_changed as int?),
        if (gender != _undefined) 'gender': (gender as int?),
        if (tier_details != _undefined)
          'tier_details': (tier_details as List<Input$TireData?>?),
        if (tournament_bracket_type != _undefined)
          'tournament_bracket_type': (tournament_bracket_type as int?),
      }));

  TRes court_details(
          Iterable<Input$CourtData?>? Function(
                  Iterable<CopyWith$Input$CourtData<Input$CourtData>?>?)
              _fn) =>
      call(
          court_details: _fn(_instance.court_details?.map((e) => e == null
              ? null
              : CopyWith$Input$CourtData(
                  e,
                  (i) => i,
                )))?.toList());

  TRes tier_details(
          Iterable<Input$TireData?>? Function(
                  Iterable<CopyWith$Input$TireData<Input$TireData>?>?)
              _fn) =>
      call(
          tier_details: _fn(_instance.tier_details?.map((e) => e == null
              ? null
              : CopyWith$Input$TireData(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$MatchFrontInput<TRes>
    implements CopyWith$Input$MatchFrontInput<TRes> {
  _CopyWithStubImpl$Input$MatchFrontInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? image,
    String? file_path,
    int? match_court_type,
    String? match_title,
    String? match_title_uuid,
    String? locations,
    String? address,
    String? latitude,
    String? longitude,
    String? clubs,
    String? date,
    String? time,
    int? match_user_type,
    int? no_slot,
    String? hours,
    String? minutes,
    int? points_to_play,
    int? is_rating,
    String? ratings,
    int? is_booked_court,
    List<Input$CourtData?>? court_details,
    int? total_court,
    String? note,
    String? status,
    String? time_zone,
    int? is_private,
    int? is_event,
    int? total_players,
    String? cost_per_player,
    String? match_level,
    int? match_organiser,
    String? event_end_date,
    String? event_end_time,
    String? community_image,
    int? community_image_changed,
    int? gender,
    List<Input$TireData?>? tier_details,
    int? tournament_bracket_type,
  }) =>
      _res;

  court_details(_fn) => _res;

  tier_details(_fn) => _res;
}

class Input$findPlayerGroupInput {
  factory Input$findPlayerGroupInput({
    String? name,
    String? group_type,
    String? skill,
    String? club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? group_for,
    bool? is_my_group,
  }) =>
      Input$findPlayerGroupInput._({
        if (name != null) r'name': name,
        if (group_type != null) r'group_type': group_type,
        if (skill != null) r'skill': skill,
        if (club != null) r'club': club,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (group_for != null) r'group_for': group_for,
        if (is_my_group != null) r'is_my_group': is_my_group,
      });

  Input$findPlayerGroupInput._(this._$data);

  factory Input$findPlayerGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('group_type')) {
      final l$group_type = data['group_type'];
      result$data['group_type'] = (l$group_type as String?);
    }
    if (data.containsKey('skill')) {
      final l$skill = data['skill'];
      result$data['skill'] = (l$skill as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] = (l$club as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('group_for')) {
      final l$group_for = data['group_for'];
      result$data['group_for'] = (l$group_for as String?);
    }
    if (data.containsKey('is_my_group')) {
      final l$is_my_group = data['is_my_group'];
      result$data['is_my_group'] = (l$is_my_group as bool?);
    }
    return Input$findPlayerGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get group_type => (_$data['group_type'] as String?);

  String? get skill => (_$data['skill'] as String?);

  String? get club => (_$data['club'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get group_for => (_$data['group_for'] as String?);

  bool? get is_my_group => (_$data['is_my_group'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('group_type')) {
      final l$group_type = group_type;
      result$data['group_type'] = l$group_type;
    }
    if (_$data.containsKey('skill')) {
      final l$skill = skill;
      result$data['skill'] = l$skill;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('group_for')) {
      final l$group_for = group_for;
      result$data['group_for'] = l$group_for;
    }
    if (_$data.containsKey('is_my_group')) {
      final l$is_my_group = is_my_group;
      result$data['is_my_group'] = l$is_my_group;
    }
    return result$data;
  }

  CopyWith$Input$findPlayerGroupInput<Input$findPlayerGroupInput>
      get copyWith => CopyWith$Input$findPlayerGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$findPlayerGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$group_type = group_type;
    final lOther$group_type = other.group_type;
    if (_$data.containsKey('group_type') !=
        other._$data.containsKey('group_type')) {
      return false;
    }
    if (l$group_type != lOther$group_type) {
      return false;
    }
    final l$skill = skill;
    final lOther$skill = other.skill;
    if (_$data.containsKey('skill') != other._$data.containsKey('skill')) {
      return false;
    }
    if (l$skill != lOther$skill) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != lOther$club) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$group_for = group_for;
    final lOther$group_for = other.group_for;
    if (_$data.containsKey('group_for') !=
        other._$data.containsKey('group_for')) {
      return false;
    }
    if (l$group_for != lOther$group_for) {
      return false;
    }
    final l$is_my_group = is_my_group;
    final lOther$is_my_group = other.is_my_group;
    if (_$data.containsKey('is_my_group') !=
        other._$data.containsKey('is_my_group')) {
      return false;
    }
    if (l$is_my_group != lOther$is_my_group) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$group_type = group_type;
    final l$skill = skill;
    final l$club = club;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$group_for = group_for;
    final l$is_my_group = is_my_group;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('group_type') ? l$group_type : const {},
      _$data.containsKey('skill') ? l$skill : const {},
      _$data.containsKey('club') ? l$club : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('group_for') ? l$group_for : const {},
      _$data.containsKey('is_my_group') ? l$is_my_group : const {},
    ]);
  }
}

abstract class CopyWith$Input$findPlayerGroupInput<TRes> {
  factory CopyWith$Input$findPlayerGroupInput(
    Input$findPlayerGroupInput instance,
    TRes Function(Input$findPlayerGroupInput) then,
  ) = _CopyWithImpl$Input$findPlayerGroupInput;

  factory CopyWith$Input$findPlayerGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$findPlayerGroupInput;

  TRes call({
    String? name,
    String? group_type,
    String? skill,
    String? club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? group_for,
    bool? is_my_group,
  });
}

class _CopyWithImpl$Input$findPlayerGroupInput<TRes>
    implements CopyWith$Input$findPlayerGroupInput<TRes> {
  _CopyWithImpl$Input$findPlayerGroupInput(
    this._instance,
    this._then,
  );

  final Input$findPlayerGroupInput _instance;

  final TRes Function(Input$findPlayerGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? group_type = _undefined,
    Object? skill = _undefined,
    Object? club = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? group_for = _undefined,
    Object? is_my_group = _undefined,
  }) =>
      _then(Input$findPlayerGroupInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (group_type != _undefined) 'group_type': (group_type as String?),
        if (skill != _undefined) 'skill': (skill as String?),
        if (club != _undefined) 'club': (club as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (group_for != _undefined) 'group_for': (group_for as String?),
        if (is_my_group != _undefined) 'is_my_group': (is_my_group as bool?),
      }));
}

class _CopyWithStubImpl$Input$findPlayerGroupInput<TRes>
    implements CopyWith$Input$findPlayerGroupInput<TRes> {
  _CopyWithStubImpl$Input$findPlayerGroupInput(this._res);

  TRes _res;

  call({
    String? name,
    String? group_type,
    String? skill,
    String? club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? group_for,
    bool? is_my_group,
  }) =>
      _res;
}

class Input$BlockUserInput {
  factory Input$BlockUserInput({
    String? version,
    String? platform,
    String? user_uuid,
    String? blockUser_uuid,
    String? block,
  }) =>
      Input$BlockUserInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (blockUser_uuid != null) r'blockUser_uuid': blockUser_uuid,
        if (block != null) r'block': block,
      });

  Input$BlockUserInput._(this._$data);

  factory Input$BlockUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('blockUser_uuid')) {
      final l$blockUser_uuid = data['blockUser_uuid'];
      result$data['blockUser_uuid'] = (l$blockUser_uuid as String?);
    }
    if (data.containsKey('block')) {
      final l$block = data['block'];
      result$data['block'] = (l$block as String?);
    }
    return Input$BlockUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get blockUser_uuid => (_$data['blockUser_uuid'] as String?);

  String? get block => (_$data['block'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('blockUser_uuid')) {
      final l$blockUser_uuid = blockUser_uuid;
      result$data['blockUser_uuid'] = l$blockUser_uuid;
    }
    if (_$data.containsKey('block')) {
      final l$block = block;
      result$data['block'] = l$block;
    }
    return result$data;
  }

  CopyWith$Input$BlockUserInput<Input$BlockUserInput> get copyWith =>
      CopyWith$Input$BlockUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$blockUser_uuid = blockUser_uuid;
    final lOther$blockUser_uuid = other.blockUser_uuid;
    if (_$data.containsKey('blockUser_uuid') !=
        other._$data.containsKey('blockUser_uuid')) {
      return false;
    }
    if (l$blockUser_uuid != lOther$blockUser_uuid) {
      return false;
    }
    final l$block = block;
    final lOther$block = other.block;
    if (_$data.containsKey('block') != other._$data.containsKey('block')) {
      return false;
    }
    if (l$block != lOther$block) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$user_uuid = user_uuid;
    final l$blockUser_uuid = blockUser_uuid;
    final l$block = block;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('blockUser_uuid') ? l$blockUser_uuid : const {},
      _$data.containsKey('block') ? l$block : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockUserInput<TRes> {
  factory CopyWith$Input$BlockUserInput(
    Input$BlockUserInput instance,
    TRes Function(Input$BlockUserInput) then,
  ) = _CopyWithImpl$Input$BlockUserInput;

  factory CopyWith$Input$BlockUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockUserInput;

  TRes call({
    String? version,
    String? platform,
    String? user_uuid,
    String? blockUser_uuid,
    String? block,
  });
}

class _CopyWithImpl$Input$BlockUserInput<TRes>
    implements CopyWith$Input$BlockUserInput<TRes> {
  _CopyWithImpl$Input$BlockUserInput(
    this._instance,
    this._then,
  );

  final Input$BlockUserInput _instance;

  final TRes Function(Input$BlockUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? user_uuid = _undefined,
    Object? blockUser_uuid = _undefined,
    Object? block = _undefined,
  }) =>
      _then(Input$BlockUserInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (blockUser_uuid != _undefined)
          'blockUser_uuid': (blockUser_uuid as String?),
        if (block != _undefined) 'block': (block as String?),
      }));
}

class _CopyWithStubImpl$Input$BlockUserInput<TRes>
    implements CopyWith$Input$BlockUserInput<TRes> {
  _CopyWithStubImpl$Input$BlockUserInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? user_uuid,
    String? blockUser_uuid,
    String? block,
  }) =>
      _res;
}

class Input$AddAsFriendInput {
  factory Input$AddAsFriendInput({
    required String sender_id,
    required String receiver_id,
  }) =>
      Input$AddAsFriendInput._({
        r'sender_id': sender_id,
        r'receiver_id': receiver_id,
      });

  Input$AddAsFriendInput._(this._$data);

  factory Input$AddAsFriendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sender_id = data['sender_id'];
    result$data['sender_id'] = (l$sender_id as String);
    final l$receiver_id = data['receiver_id'];
    result$data['receiver_id'] = (l$receiver_id as String);
    return Input$AddAsFriendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get sender_id => (_$data['sender_id'] as String);

  String get receiver_id => (_$data['receiver_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sender_id = sender_id;
    result$data['sender_id'] = l$sender_id;
    final l$receiver_id = receiver_id;
    result$data['receiver_id'] = l$receiver_id;
    return result$data;
  }

  CopyWith$Input$AddAsFriendInput<Input$AddAsFriendInput> get copyWith =>
      CopyWith$Input$AddAsFriendInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAsFriendInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sender_id = sender_id;
    final lOther$sender_id = other.sender_id;
    if (l$sender_id != lOther$sender_id) {
      return false;
    }
    final l$receiver_id = receiver_id;
    final lOther$receiver_id = other.receiver_id;
    if (l$receiver_id != lOther$receiver_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sender_id = sender_id;
    final l$receiver_id = receiver_id;
    return Object.hashAll([
      l$sender_id,
      l$receiver_id,
    ]);
  }
}

abstract class CopyWith$Input$AddAsFriendInput<TRes> {
  factory CopyWith$Input$AddAsFriendInput(
    Input$AddAsFriendInput instance,
    TRes Function(Input$AddAsFriendInput) then,
  ) = _CopyWithImpl$Input$AddAsFriendInput;

  factory CopyWith$Input$AddAsFriendInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAsFriendInput;

  TRes call({
    String? sender_id,
    String? receiver_id,
  });
}

class _CopyWithImpl$Input$AddAsFriendInput<TRes>
    implements CopyWith$Input$AddAsFriendInput<TRes> {
  _CopyWithImpl$Input$AddAsFriendInput(
    this._instance,
    this._then,
  );

  final Input$AddAsFriendInput _instance;

  final TRes Function(Input$AddAsFriendInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sender_id = _undefined,
    Object? receiver_id = _undefined,
  }) =>
      _then(Input$AddAsFriendInput._({
        ..._instance._$data,
        if (sender_id != _undefined && sender_id != null)
          'sender_id': (sender_id as String),
        if (receiver_id != _undefined && receiver_id != null)
          'receiver_id': (receiver_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddAsFriendInput<TRes>
    implements CopyWith$Input$AddAsFriendInput<TRes> {
  _CopyWithStubImpl$Input$AddAsFriendInput(this._res);

  TRes _res;

  call({
    String? sender_id,
    String? receiver_id,
  }) =>
      _res;
}

class Input$AddAcceptFriendRequestInput {
  factory Input$AddAcceptFriendRequestInput({
    required String sender_id,
    required String receiver_id,
  }) =>
      Input$AddAcceptFriendRequestInput._({
        r'sender_id': sender_id,
        r'receiver_id': receiver_id,
      });

  Input$AddAcceptFriendRequestInput._(this._$data);

  factory Input$AddAcceptFriendRequestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sender_id = data['sender_id'];
    result$data['sender_id'] = (l$sender_id as String);
    final l$receiver_id = data['receiver_id'];
    result$data['receiver_id'] = (l$receiver_id as String);
    return Input$AddAcceptFriendRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get sender_id => (_$data['sender_id'] as String);

  String get receiver_id => (_$data['receiver_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sender_id = sender_id;
    result$data['sender_id'] = l$sender_id;
    final l$receiver_id = receiver_id;
    result$data['receiver_id'] = l$receiver_id;
    return result$data;
  }

  CopyWith$Input$AddAcceptFriendRequestInput<Input$AddAcceptFriendRequestInput>
      get copyWith => CopyWith$Input$AddAcceptFriendRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAcceptFriendRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sender_id = sender_id;
    final lOther$sender_id = other.sender_id;
    if (l$sender_id != lOther$sender_id) {
      return false;
    }
    final l$receiver_id = receiver_id;
    final lOther$receiver_id = other.receiver_id;
    if (l$receiver_id != lOther$receiver_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sender_id = sender_id;
    final l$receiver_id = receiver_id;
    return Object.hashAll([
      l$sender_id,
      l$receiver_id,
    ]);
  }
}

abstract class CopyWith$Input$AddAcceptFriendRequestInput<TRes> {
  factory CopyWith$Input$AddAcceptFriendRequestInput(
    Input$AddAcceptFriendRequestInput instance,
    TRes Function(Input$AddAcceptFriendRequestInput) then,
  ) = _CopyWithImpl$Input$AddAcceptFriendRequestInput;

  factory CopyWith$Input$AddAcceptFriendRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAcceptFriendRequestInput;

  TRes call({
    String? sender_id,
    String? receiver_id,
  });
}

class _CopyWithImpl$Input$AddAcceptFriendRequestInput<TRes>
    implements CopyWith$Input$AddAcceptFriendRequestInput<TRes> {
  _CopyWithImpl$Input$AddAcceptFriendRequestInput(
    this._instance,
    this._then,
  );

  final Input$AddAcceptFriendRequestInput _instance;

  final TRes Function(Input$AddAcceptFriendRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sender_id = _undefined,
    Object? receiver_id = _undefined,
  }) =>
      _then(Input$AddAcceptFriendRequestInput._({
        ..._instance._$data,
        if (sender_id != _undefined && sender_id != null)
          'sender_id': (sender_id as String),
        if (receiver_id != _undefined && receiver_id != null)
          'receiver_id': (receiver_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddAcceptFriendRequestInput<TRes>
    implements CopyWith$Input$AddAcceptFriendRequestInput<TRes> {
  _CopyWithStubImpl$Input$AddAcceptFriendRequestInput(this._res);

  TRes _res;

  call({
    String? sender_id,
    String? receiver_id,
  }) =>
      _res;
}

class Input$AddRejectFriendRequestInput {
  factory Input$AddRejectFriendRequestInput({
    required String sender_id,
    required String receiver_id,
  }) =>
      Input$AddRejectFriendRequestInput._({
        r'sender_id': sender_id,
        r'receiver_id': receiver_id,
      });

  Input$AddRejectFriendRequestInput._(this._$data);

  factory Input$AddRejectFriendRequestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sender_id = data['sender_id'];
    result$data['sender_id'] = (l$sender_id as String);
    final l$receiver_id = data['receiver_id'];
    result$data['receiver_id'] = (l$receiver_id as String);
    return Input$AddRejectFriendRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get sender_id => (_$data['sender_id'] as String);

  String get receiver_id => (_$data['receiver_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sender_id = sender_id;
    result$data['sender_id'] = l$sender_id;
    final l$receiver_id = receiver_id;
    result$data['receiver_id'] = l$receiver_id;
    return result$data;
  }

  CopyWith$Input$AddRejectFriendRequestInput<Input$AddRejectFriendRequestInput>
      get copyWith => CopyWith$Input$AddRejectFriendRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddRejectFriendRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sender_id = sender_id;
    final lOther$sender_id = other.sender_id;
    if (l$sender_id != lOther$sender_id) {
      return false;
    }
    final l$receiver_id = receiver_id;
    final lOther$receiver_id = other.receiver_id;
    if (l$receiver_id != lOther$receiver_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sender_id = sender_id;
    final l$receiver_id = receiver_id;
    return Object.hashAll([
      l$sender_id,
      l$receiver_id,
    ]);
  }
}

abstract class CopyWith$Input$AddRejectFriendRequestInput<TRes> {
  factory CopyWith$Input$AddRejectFriendRequestInput(
    Input$AddRejectFriendRequestInput instance,
    TRes Function(Input$AddRejectFriendRequestInput) then,
  ) = _CopyWithImpl$Input$AddRejectFriendRequestInput;

  factory CopyWith$Input$AddRejectFriendRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddRejectFriendRequestInput;

  TRes call({
    String? sender_id,
    String? receiver_id,
  });
}

class _CopyWithImpl$Input$AddRejectFriendRequestInput<TRes>
    implements CopyWith$Input$AddRejectFriendRequestInput<TRes> {
  _CopyWithImpl$Input$AddRejectFriendRequestInput(
    this._instance,
    this._then,
  );

  final Input$AddRejectFriendRequestInput _instance;

  final TRes Function(Input$AddRejectFriendRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sender_id = _undefined,
    Object? receiver_id = _undefined,
  }) =>
      _then(Input$AddRejectFriendRequestInput._({
        ..._instance._$data,
        if (sender_id != _undefined && sender_id != null)
          'sender_id': (sender_id as String),
        if (receiver_id != _undefined && receiver_id != null)
          'receiver_id': (receiver_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddRejectFriendRequestInput<TRes>
    implements CopyWith$Input$AddRejectFriendRequestInput<TRes> {
  _CopyWithStubImpl$Input$AddRejectFriendRequestInput(this._res);

  TRes _res;

  call({
    String? sender_id,
    String? receiver_id,
  }) =>
      _res;
}

class Input$RemoveAsFriendInput {
  factory Input$RemoveAsFriendInput({
    String? sender_id,
    List<String?>? receiver_id,
  }) =>
      Input$RemoveAsFriendInput._({
        if (sender_id != null) r'sender_id': sender_id,
        if (receiver_id != null) r'receiver_id': receiver_id,
      });

  Input$RemoveAsFriendInput._(this._$data);

  factory Input$RemoveAsFriendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sender_id')) {
      final l$sender_id = data['sender_id'];
      result$data['sender_id'] = (l$sender_id as String?);
    }
    if (data.containsKey('receiver_id')) {
      final l$receiver_id = data['receiver_id'];
      result$data['receiver_id'] = (l$receiver_id as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$RemoveAsFriendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sender_id => (_$data['sender_id'] as String?);

  List<String?>? get receiver_id => (_$data['receiver_id'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sender_id')) {
      final l$sender_id = sender_id;
      result$data['sender_id'] = l$sender_id;
    }
    if (_$data.containsKey('receiver_id')) {
      final l$receiver_id = receiver_id;
      result$data['receiver_id'] = l$receiver_id?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$RemoveAsFriendInput<Input$RemoveAsFriendInput> get copyWith =>
      CopyWith$Input$RemoveAsFriendInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveAsFriendInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sender_id = sender_id;
    final lOther$sender_id = other.sender_id;
    if (_$data.containsKey('sender_id') !=
        other._$data.containsKey('sender_id')) {
      return false;
    }
    if (l$sender_id != lOther$sender_id) {
      return false;
    }
    final l$receiver_id = receiver_id;
    final lOther$receiver_id = other.receiver_id;
    if (_$data.containsKey('receiver_id') !=
        other._$data.containsKey('receiver_id')) {
      return false;
    }
    if (l$receiver_id != null && lOther$receiver_id != null) {
      if (l$receiver_id.length != lOther$receiver_id.length) {
        return false;
      }
      for (int i = 0; i < l$receiver_id.length; i++) {
        final l$receiver_id$entry = l$receiver_id[i];
        final lOther$receiver_id$entry = lOther$receiver_id[i];
        if (l$receiver_id$entry != lOther$receiver_id$entry) {
          return false;
        }
      }
    } else if (l$receiver_id != lOther$receiver_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sender_id = sender_id;
    final l$receiver_id = receiver_id;
    return Object.hashAll([
      _$data.containsKey('sender_id') ? l$sender_id : const {},
      _$data.containsKey('receiver_id')
          ? l$receiver_id == null
              ? null
              : Object.hashAll(l$receiver_id.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveAsFriendInput<TRes> {
  factory CopyWith$Input$RemoveAsFriendInput(
    Input$RemoveAsFriendInput instance,
    TRes Function(Input$RemoveAsFriendInput) then,
  ) = _CopyWithImpl$Input$RemoveAsFriendInput;

  factory CopyWith$Input$RemoveAsFriendInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveAsFriendInput;

  TRes call({
    String? sender_id,
    List<String?>? receiver_id,
  });
}

class _CopyWithImpl$Input$RemoveAsFriendInput<TRes>
    implements CopyWith$Input$RemoveAsFriendInput<TRes> {
  _CopyWithImpl$Input$RemoveAsFriendInput(
    this._instance,
    this._then,
  );

  final Input$RemoveAsFriendInput _instance;

  final TRes Function(Input$RemoveAsFriendInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sender_id = _undefined,
    Object? receiver_id = _undefined,
  }) =>
      _then(Input$RemoveAsFriendInput._({
        ..._instance._$data,
        if (sender_id != _undefined) 'sender_id': (sender_id as String?),
        if (receiver_id != _undefined)
          'receiver_id': (receiver_id as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$RemoveAsFriendInput<TRes>
    implements CopyWith$Input$RemoveAsFriendInput<TRes> {
  _CopyWithStubImpl$Input$RemoveAsFriendInput(this._res);

  TRes _res;

  call({
    String? sender_id,
    List<String?>? receiver_id,
  }) =>
      _res;
}

class Input$findPlayerFriendInput {
  factory Input$findPlayerFriendInput({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    int? offset,
    int? limit,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? clubs,
    String? recommendation,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  }) =>
      Input$findPlayerFriendInput._({
        if (name != null) r'name': name,
        if (rating != null) r'rating': rating,
        if (match_id != null) r'match_id': match_id,
        if (gender != null) r'gender': gender,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (clubs != null) r'clubs': clubs,
        if (recommendation != null) r'recommendation': recommendation,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_coach != null) r'is_coach': is_coach,
      });

  Input$findPlayerFriendInput._(this._$data);

  factory Input$findPlayerFriendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as int?);
    }
    return Input$findPlayerFriendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get gender => (_$data['gender'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get recommendation => (_$data['recommendation'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get is_coach => (_$data['is_coach'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    return result$data;
  }

  CopyWith$Input$findPlayerFriendInput<Input$findPlayerFriendInput>
      get copyWith => CopyWith$Input$findPlayerFriendInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$findPlayerFriendInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$rating = rating;
    final l$match_id = match_id;
    final l$gender = gender;
    final l$offset = offset;
    final l$limit = limit;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$clubs = clubs;
    final l$recommendation = recommendation;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_coach = is_coach;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
    ]);
  }
}

abstract class CopyWith$Input$findPlayerFriendInput<TRes> {
  factory CopyWith$Input$findPlayerFriendInput(
    Input$findPlayerFriendInput instance,
    TRes Function(Input$findPlayerFriendInput) then,
  ) = _CopyWithImpl$Input$findPlayerFriendInput;

  factory CopyWith$Input$findPlayerFriendInput.stub(TRes res) =
      _CopyWithStubImpl$Input$findPlayerFriendInput;

  TRes call({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    int? offset,
    int? limit,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? clubs,
    String? recommendation,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  });
}

class _CopyWithImpl$Input$findPlayerFriendInput<TRes>
    implements CopyWith$Input$findPlayerFriendInput<TRes> {
  _CopyWithImpl$Input$findPlayerFriendInput(
    this._instance,
    this._then,
  );

  final Input$findPlayerFriendInput _instance;

  final TRes Function(Input$findPlayerFriendInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? rating = _undefined,
    Object? match_id = _undefined,
    Object? gender = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? clubs = _undefined,
    Object? recommendation = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_coach = _undefined,
  }) =>
      _then(Input$findPlayerFriendInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as int?),
      }));
}

class _CopyWithStubImpl$Input$findPlayerFriendInput<TRes>
    implements CopyWith$Input$findPlayerFriendInput<TRes> {
  _CopyWithStubImpl$Input$findPlayerFriendInput(this._res);

  TRes _res;

  call({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    int? offset,
    int? limit,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    String? clubs,
    String? recommendation,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  }) =>
      _res;
}

class Input$findPlayerNetworkInput {
  factory Input$findPlayerNetworkInput({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  }) =>
      Input$findPlayerNetworkInput._({
        if (name != null) r'name': name,
        if (rating != null) r'rating': rating,
        if (match_id != null) r'match_id': match_id,
        if (gender != null) r'gender': gender,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (clubs != null) r'clubs': clubs,
        if (recommendation != null) r'recommendation': recommendation,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_coach != null) r'is_coach': is_coach,
      });

  Input$findPlayerNetworkInput._(this._$data);

  factory Input$findPlayerNetworkInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = (l$max as int?);
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = (l$min as int?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as int?);
    }
    return Input$findPlayerNetworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get gender => (_$data['gender'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  int? get max => (_$data['max'] as int?);

  int? get min => (_$data['min'] as int?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get recommendation => (_$data['recommendation'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get is_coach => (_$data['is_coach'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max;
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    return result$data;
  }

  CopyWith$Input$findPlayerNetworkInput<Input$findPlayerNetworkInput>
      get copyWith => CopyWith$Input$findPlayerNetworkInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$findPlayerNetworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$rating = rating;
    final l$match_id = match_id;
    final l$gender = gender;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$max = max;
    final l$min = min;
    final l$clubs = clubs;
    final l$recommendation = recommendation;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_coach = is_coach;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
    ]);
  }
}

abstract class CopyWith$Input$findPlayerNetworkInput<TRes> {
  factory CopyWith$Input$findPlayerNetworkInput(
    Input$findPlayerNetworkInput instance,
    TRes Function(Input$findPlayerNetworkInput) then,
  ) = _CopyWithImpl$Input$findPlayerNetworkInput;

  factory CopyWith$Input$findPlayerNetworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$findPlayerNetworkInput;

  TRes call({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  });
}

class _CopyWithImpl$Input$findPlayerNetworkInput<TRes>
    implements CopyWith$Input$findPlayerNetworkInput<TRes> {
  _CopyWithImpl$Input$findPlayerNetworkInput(
    this._instance,
    this._then,
  );

  final Input$findPlayerNetworkInput _instance;

  final TRes Function(Input$findPlayerNetworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? rating = _undefined,
    Object? match_id = _undefined,
    Object? gender = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? clubs = _undefined,
    Object? recommendation = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_coach = _undefined,
  }) =>
      _then(Input$findPlayerNetworkInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (max != _undefined) 'max': (max as int?),
        if (min != _undefined) 'min': (min as int?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as int?),
      }));
}

class _CopyWithStubImpl$Input$findPlayerNetworkInput<TRes>
    implements CopyWith$Input$findPlayerNetworkInput<TRes> {
  _CopyWithStubImpl$Input$findPlayerNetworkInput(this._res);

  TRes _res;

  call({
    String? name,
    String? rating,
    String? match_id,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? is_coach,
  }) =>
      _res;
}

class Input$invitedPlayerFriendInput {
  factory Input$invitedPlayerFriendInput({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$invitedPlayerFriendInput._({
        if (name != null) r'name': name,
        if (uuid != null) r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$invitedPlayerFriendInput._(this._$data);

  factory Input$invitedPlayerFriendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$invitedPlayerFriendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$invitedPlayerFriendInput<Input$invitedPlayerFriendInput>
      get copyWith => CopyWith$Input$invitedPlayerFriendInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$invitedPlayerFriendInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$invitedPlayerFriendInput<TRes> {
  factory CopyWith$Input$invitedPlayerFriendInput(
    Input$invitedPlayerFriendInput instance,
    TRes Function(Input$invitedPlayerFriendInput) then,
  ) = _CopyWithImpl$Input$invitedPlayerFriendInput;

  factory CopyWith$Input$invitedPlayerFriendInput.stub(TRes res) =
      _CopyWithStubImpl$Input$invitedPlayerFriendInput;

  TRes call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$invitedPlayerFriendInput<TRes>
    implements CopyWith$Input$invitedPlayerFriendInput<TRes> {
  _CopyWithImpl$Input$invitedPlayerFriendInput(
    this._instance,
    this._then,
  );

  final Input$invitedPlayerFriendInput _instance;

  final TRes Function(Input$invitedPlayerFriendInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$invitedPlayerFriendInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$invitedPlayerFriendInput<TRes>
    implements CopyWith$Input$invitedPlayerFriendInput<TRes> {
  _CopyWithStubImpl$Input$invitedPlayerFriendInput(this._res);

  TRes _res;

  call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$invitedPlayerGroupInput {
  factory Input$invitedPlayerGroupInput({
    String? uuid,
    String? name,
    String? skill_level,
    String? group_types,
    String? preferred_club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$invitedPlayerGroupInput._({
        if (uuid != null) r'uuid': uuid,
        if (name != null) r'name': name,
        if (skill_level != null) r'skill_level': skill_level,
        if (group_types != null) r'group_types': group_types,
        if (preferred_club != null) r'preferred_club': preferred_club,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$invitedPlayerGroupInput._(this._$data);

  factory Input$invitedPlayerGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('group_types')) {
      final l$group_types = data['group_types'];
      result$data['group_types'] = (l$group_types as String?);
    }
    if (data.containsKey('preferred_club')) {
      final l$preferred_club = data['preferred_club'];
      result$data['preferred_club'] = (l$preferred_club as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$invitedPlayerGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get group_types => (_$data['group_types'] as String?);

  String? get preferred_club => (_$data['preferred_club'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('group_types')) {
      final l$group_types = group_types;
      result$data['group_types'] = l$group_types;
    }
    if (_$data.containsKey('preferred_club')) {
      final l$preferred_club = preferred_club;
      result$data['preferred_club'] = l$preferred_club;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$invitedPlayerGroupInput<Input$invitedPlayerGroupInput>
      get copyWith => CopyWith$Input$invitedPlayerGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$invitedPlayerGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$group_types = group_types;
    final lOther$group_types = other.group_types;
    if (_$data.containsKey('group_types') !=
        other._$data.containsKey('group_types')) {
      return false;
    }
    if (l$group_types != lOther$group_types) {
      return false;
    }
    final l$preferred_club = preferred_club;
    final lOther$preferred_club = other.preferred_club;
    if (_$data.containsKey('preferred_club') !=
        other._$data.containsKey('preferred_club')) {
      return false;
    }
    if (l$preferred_club != lOther$preferred_club) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$skill_level = skill_level;
    final l$group_types = group_types;
    final l$preferred_club = preferred_club;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('group_types') ? l$group_types : const {},
      _$data.containsKey('preferred_club') ? l$preferred_club : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$invitedPlayerGroupInput<TRes> {
  factory CopyWith$Input$invitedPlayerGroupInput(
    Input$invitedPlayerGroupInput instance,
    TRes Function(Input$invitedPlayerGroupInput) then,
  ) = _CopyWithImpl$Input$invitedPlayerGroupInput;

  factory CopyWith$Input$invitedPlayerGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$invitedPlayerGroupInput;

  TRes call({
    String? uuid,
    String? name,
    String? skill_level,
    String? group_types,
    String? preferred_club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$invitedPlayerGroupInput<TRes>
    implements CopyWith$Input$invitedPlayerGroupInput<TRes> {
  _CopyWithImpl$Input$invitedPlayerGroupInput(
    this._instance,
    this._then,
  );

  final Input$invitedPlayerGroupInput _instance;

  final TRes Function(Input$invitedPlayerGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? skill_level = _undefined,
    Object? group_types = _undefined,
    Object? preferred_club = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$invitedPlayerGroupInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (name != _undefined) 'name': (name as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (group_types != _undefined) 'group_types': (group_types as String?),
        if (preferred_club != _undefined)
          'preferred_club': (preferred_club as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$invitedPlayerGroupInput<TRes>
    implements CopyWith$Input$invitedPlayerGroupInput<TRes> {
  _CopyWithStubImpl$Input$invitedPlayerGroupInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    String? skill_level,
    String? group_types,
    String? preferred_club,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$invitedPlayerNetworkInput {
  factory Input$invitedPlayerNetworkInput({
    String? uuid,
    String? name,
    int? offset,
    int? limit,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? skill_level,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$invitedPlayerNetworkInput._({
        if (uuid != null) r'uuid': uuid,
        if (name != null) r'name': name,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (skill_level != null) r'skill_level': skill_level,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$invitedPlayerNetworkInput._(this._$data);

  factory Input$invitedPlayerNetworkInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$invitedPlayerNetworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get name => (_$data['name'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$invitedPlayerNetworkInput<Input$invitedPlayerNetworkInput>
      get copyWith => CopyWith$Input$invitedPlayerNetworkInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$invitedPlayerNetworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$name = name;
    final l$offset = offset;
    final l$limit = limit;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$skill_level = skill_level;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$invitedPlayerNetworkInput<TRes> {
  factory CopyWith$Input$invitedPlayerNetworkInput(
    Input$invitedPlayerNetworkInput instance,
    TRes Function(Input$invitedPlayerNetworkInput) then,
  ) = _CopyWithImpl$Input$invitedPlayerNetworkInput;

  factory CopyWith$Input$invitedPlayerNetworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$invitedPlayerNetworkInput;

  TRes call({
    String? uuid,
    String? name,
    int? offset,
    int? limit,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? skill_level,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$invitedPlayerNetworkInput<TRes>
    implements CopyWith$Input$invitedPlayerNetworkInput<TRes> {
  _CopyWithImpl$Input$invitedPlayerNetworkInput(
    this._instance,
    this._then,
  );

  final Input$invitedPlayerNetworkInput _instance;

  final TRes Function(Input$invitedPlayerNetworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? name = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? skill_level = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$invitedPlayerNetworkInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (name != _undefined) 'name': (name as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$invitedPlayerNetworkInput<TRes>
    implements CopyWith$Input$invitedPlayerNetworkInput<TRes> {
  _CopyWithStubImpl$Input$invitedPlayerNetworkInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? name,
    int? offset,
    int? limit,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? skill_level,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$getUserRviewInput {
  factory Input$getUserRviewInput({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
  }) =>
      Input$getUserRviewInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (is_event != null) r'is_event': is_event,
      });

  Input$getUserRviewInput._(this._$data);

  factory Input$getUserRviewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    return Input$getUserRviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    return result$data;
  }

  CopyWith$Input$getUserRviewInput<Input$getUserRviewInput> get copyWith =>
      CopyWith$Input$getUserRviewInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getUserRviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    final l$is_event = is_event;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
    ]);
  }
}

abstract class CopyWith$Input$getUserRviewInput<TRes> {
  factory CopyWith$Input$getUserRviewInput(
    Input$getUserRviewInput instance,
    TRes Function(Input$getUserRviewInput) then,
  ) = _CopyWithImpl$Input$getUserRviewInput;

  factory CopyWith$Input$getUserRviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getUserRviewInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
  });
}

class _CopyWithImpl$Input$getUserRviewInput<TRes>
    implements CopyWith$Input$getUserRviewInput<TRes> {
  _CopyWithImpl$Input$getUserRviewInput(
    this._instance,
    this._then,
  );

  final Input$getUserRviewInput _instance;

  final TRes Function(Input$getUserRviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$getUserRviewInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
      }));
}

class _CopyWithStubImpl$Input$getUserRviewInput<TRes>
    implements CopyWith$Input$getUserRviewInput<TRes> {
  _CopyWithStubImpl$Input$getUserRviewInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
  }) =>
      _res;
}

class Input$updateUserRatingInput {
  factory Input$updateUserRatingInput({
    String? match_uuid,
    String? user_uuid,
    String? rating,
  }) =>
      Input$updateUserRatingInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (rating != null) r'rating': rating,
      });

  Input$updateUserRatingInput._(this._$data);

  factory Input$updateUserRatingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    return Input$updateUserRatingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get rating => (_$data['rating'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    return result$data;
  }

  CopyWith$Input$updateUserRatingInput<Input$updateUserRatingInput>
      get copyWith => CopyWith$Input$updateUserRatingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$updateUserRatingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    final l$rating = rating;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('rating') ? l$rating : const {},
    ]);
  }
}

abstract class CopyWith$Input$updateUserRatingInput<TRes> {
  factory CopyWith$Input$updateUserRatingInput(
    Input$updateUserRatingInput instance,
    TRes Function(Input$updateUserRatingInput) then,
  ) = _CopyWithImpl$Input$updateUserRatingInput;

  factory CopyWith$Input$updateUserRatingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$updateUserRatingInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
    String? rating,
  });
}

class _CopyWithImpl$Input$updateUserRatingInput<TRes>
    implements CopyWith$Input$updateUserRatingInput<TRes> {
  _CopyWithImpl$Input$updateUserRatingInput(
    this._instance,
    this._then,
  );

  final Input$updateUserRatingInput _instance;

  final TRes Function(Input$updateUserRatingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
    Object? rating = _undefined,
  }) =>
      _then(Input$updateUserRatingInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (rating != _undefined) 'rating': (rating as String?),
      }));
}

class _CopyWithStubImpl$Input$updateUserRatingInput<TRes>
    implements CopyWith$Input$updateUserRatingInput<TRes> {
  _CopyWithStubImpl$Input$updateUserRatingInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
    String? rating,
  }) =>
      _res;
}

class Input$BlockUserListFrontPaginationInput {
  factory Input$BlockUserListFrontPaginationInput({
    required String uuid,
    String? full_name,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$BlockUserListFrontPaginationInput._({
        r'uuid': uuid,
        if (full_name != null) r'full_name': full_name,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$BlockUserListFrontPaginationInput._(this._$data);

  factory Input$BlockUserListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$BlockUserListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get full_name => (_$data['full_name'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$BlockUserListFrontPaginationInput<
          Input$BlockUserListFrontPaginationInput>
      get copyWith => CopyWith$Input$BlockUserListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockUserListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$full_name = full_name;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('full_name') ? l$full_name : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockUserListFrontPaginationInput<TRes> {
  factory CopyWith$Input$BlockUserListFrontPaginationInput(
    Input$BlockUserListFrontPaginationInput instance,
    TRes Function(Input$BlockUserListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$BlockUserListFrontPaginationInput;

  factory CopyWith$Input$BlockUserListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockUserListFrontPaginationInput;

  TRes call({
    String? uuid,
    String? full_name,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$BlockUserListFrontPaginationInput<TRes>
    implements CopyWith$Input$BlockUserListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$BlockUserListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$BlockUserListFrontPaginationInput _instance;

  final TRes Function(Input$BlockUserListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? full_name = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$BlockUserListFrontPaginationInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$BlockUserListFrontPaginationInput<TRes>
    implements CopyWith$Input$BlockUserListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$BlockUserListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? full_name,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$InvitedMemberInput {
  factory Input$InvitedMemberInput({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$InvitedMemberInput._({
        if (name != null) r'name': name,
        if (uuid != null) r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$InvitedMemberInput._(this._$data);

  factory Input$InvitedMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$InvitedMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$InvitedMemberInput<Input$InvitedMemberInput> get copyWith =>
      CopyWith$Input$InvitedMemberInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitedMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitedMemberInput<TRes> {
  factory CopyWith$Input$InvitedMemberInput(
    Input$InvitedMemberInput instance,
    TRes Function(Input$InvitedMemberInput) then,
  ) = _CopyWithImpl$Input$InvitedMemberInput;

  factory CopyWith$Input$InvitedMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitedMemberInput;

  TRes call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$InvitedMemberInput<TRes>
    implements CopyWith$Input$InvitedMemberInput<TRes> {
  _CopyWithImpl$Input$InvitedMemberInput(
    this._instance,
    this._then,
  );

  final Input$InvitedMemberInput _instance;

  final TRes Function(Input$InvitedMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$InvitedMemberInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$InvitedMemberInput<TRes>
    implements CopyWith$Input$InvitedMemberInput<TRes> {
  _CopyWithStubImpl$Input$InvitedMemberInput(this._res);

  TRes _res;

  call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddMatchCommentInput {
  factory Input$AddMatchCommentInput({
    String? match_id,
    String? comment,
    String? parent_id,
  }) =>
      Input$AddMatchCommentInput._({
        if (match_id != null) r'match_id': match_id,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$AddMatchCommentInput._(this._$data);

  factory Input$AddMatchCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$AddMatchCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$AddMatchCommentInput<Input$AddMatchCommentInput>
      get copyWith => CopyWith$Input$AddMatchCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddMatchCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddMatchCommentInput<TRes> {
  factory CopyWith$Input$AddMatchCommentInput(
    Input$AddMatchCommentInput instance,
    TRes Function(Input$AddMatchCommentInput) then,
  ) = _CopyWithImpl$Input$AddMatchCommentInput;

  factory CopyWith$Input$AddMatchCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddMatchCommentInput;

  TRes call({
    String? match_id,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$AddMatchCommentInput<TRes>
    implements CopyWith$Input$AddMatchCommentInput<TRes> {
  _CopyWithImpl$Input$AddMatchCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddMatchCommentInput _instance;

  final TRes Function(Input$AddMatchCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$AddMatchCommentInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AddMatchCommentInput<TRes>
    implements CopyWith$Input$AddMatchCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddMatchCommentInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$MatchCommentsInput {
  factory Input$MatchCommentsInput({String? match_uuid}) =>
      Input$MatchCommentsInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
      });

  Input$MatchCommentsInput._(this._$data);

  factory Input$MatchCommentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    return Input$MatchCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    return result$data;
  }

  CopyWith$Input$MatchCommentsInput<Input$MatchCommentsInput> get copyWith =>
      CopyWith$Input$MatchCommentsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    return Object.hashAll(
        [_$data.containsKey('match_uuid') ? l$match_uuid : const {}]);
  }
}

abstract class CopyWith$Input$MatchCommentsInput<TRes> {
  factory CopyWith$Input$MatchCommentsInput(
    Input$MatchCommentsInput instance,
    TRes Function(Input$MatchCommentsInput) then,
  ) = _CopyWithImpl$Input$MatchCommentsInput;

  factory CopyWith$Input$MatchCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchCommentsInput;

  TRes call({String? match_uuid});
}

class _CopyWithImpl$Input$MatchCommentsInput<TRes>
    implements CopyWith$Input$MatchCommentsInput<TRes> {
  _CopyWithImpl$Input$MatchCommentsInput(
    this._instance,
    this._then,
  );

  final Input$MatchCommentsInput _instance;

  final TRes Function(Input$MatchCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_uuid = _undefined}) =>
      _then(Input$MatchCommentsInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$MatchCommentsInput<TRes>
    implements CopyWith$Input$MatchCommentsInput<TRes> {
  _CopyWithStubImpl$Input$MatchCommentsInput(this._res);

  TRes _res;

  call({String? match_uuid}) => _res;
}

class Input$BlockUserPaginationInput {
  factory Input$BlockUserPaginationInput({
    required int offset,
    required int limit,
    required String full_name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$BlockUserPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        r'full_name': full_name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$BlockUserPaginationInput._(this._$data);

  factory Input$BlockUserPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    final l$full_name = data['full_name'];
    result$data['full_name'] = (l$full_name as String);
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$BlockUserPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String get full_name => (_$data['full_name'] as String);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    final l$full_name = full_name;
    result$data['full_name'] = l$full_name;
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$BlockUserPaginationInput<Input$BlockUserPaginationInput>
      get copyWith => CopyWith$Input$BlockUserPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockUserPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$full_name = full_name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      l$limit,
      l$full_name,
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockUserPaginationInput<TRes> {
  factory CopyWith$Input$BlockUserPaginationInput(
    Input$BlockUserPaginationInput instance,
    TRes Function(Input$BlockUserPaginationInput) then,
  ) = _CopyWithImpl$Input$BlockUserPaginationInput;

  factory CopyWith$Input$BlockUserPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockUserPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? full_name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$BlockUserPaginationInput<TRes>
    implements CopyWith$Input$BlockUserPaginationInput<TRes> {
  _CopyWithImpl$Input$BlockUserPaginationInput(
    this._instance,
    this._then,
  );

  final Input$BlockUserPaginationInput _instance;

  final TRes Function(Input$BlockUserPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? full_name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$BlockUserPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (full_name != _undefined && full_name != null)
          'full_name': (full_name as String),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$BlockUserPaginationInput<TRes>
    implements CopyWith$Input$BlockUserPaginationInput<TRes> {
  _CopyWithStubImpl$Input$BlockUserPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? full_name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$BlockUserListPaginationInput {
  factory Input$BlockUserListPaginationInput({
    required String uuid,
    required String full_name,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$BlockUserListPaginationInput._({
        r'uuid': uuid,
        r'full_name': full_name,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$BlockUserListPaginationInput._(this._$data);

  factory Input$BlockUserListPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    final l$full_name = data['full_name'];
    result$data['full_name'] = (l$full_name as String);
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$BlockUserListPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String get full_name => (_$data['full_name'] as String);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    final l$full_name = full_name;
    result$data['full_name'] = l$full_name;
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$BlockUserListPaginationInput<
          Input$BlockUserListPaginationInput>
      get copyWith => CopyWith$Input$BlockUserListPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BlockUserListPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$full_name = full_name;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$uuid,
      l$full_name,
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$BlockUserListPaginationInput<TRes> {
  factory CopyWith$Input$BlockUserListPaginationInput(
    Input$BlockUserListPaginationInput instance,
    TRes Function(Input$BlockUserListPaginationInput) then,
  ) = _CopyWithImpl$Input$BlockUserListPaginationInput;

  factory CopyWith$Input$BlockUserListPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BlockUserListPaginationInput;

  TRes call({
    String? uuid,
    String? full_name,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$BlockUserListPaginationInput<TRes>
    implements CopyWith$Input$BlockUserListPaginationInput<TRes> {
  _CopyWithImpl$Input$BlockUserListPaginationInput(
    this._instance,
    this._then,
  );

  final Input$BlockUserListPaginationInput _instance;

  final TRes Function(Input$BlockUserListPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? full_name = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$BlockUserListPaginationInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (full_name != _undefined && full_name != null)
          'full_name': (full_name as String),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$BlockUserListPaginationInput<TRes>
    implements CopyWith$Input$BlockUserListPaginationInput<TRes> {
  _CopyWithStubImpl$Input$BlockUserListPaginationInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? full_name,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$sendMatchInviteInput {
  factory Input$sendMatchInviteInput({
    String? match_id,
    List<Input$reachout_ord?>? reachout_ord,
    int? is_reachout,
    String? reachout_date,
    String? time_zone,
    bool? is_reinvite,
    bool? is_alert_notification,
    int? event_approved,
  }) =>
      Input$sendMatchInviteInput._({
        if (match_id != null) r'match_id': match_id,
        if (reachout_ord != null) r'reachout_ord': reachout_ord,
        if (is_reachout != null) r'is_reachout': is_reachout,
        if (reachout_date != null) r'reachout_date': reachout_date,
        if (time_zone != null) r'time_zone': time_zone,
        if (is_reinvite != null) r'is_reinvite': is_reinvite,
        if (is_alert_notification != null)
          r'is_alert_notification': is_alert_notification,
        if (event_approved != null) r'event_approved': event_approved,
      });

  Input$sendMatchInviteInput._(this._$data);

  factory Input$sendMatchInviteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('reachout_ord')) {
      final l$reachout_ord = data['reachout_ord'];
      result$data['reachout_ord'] = (l$reachout_ord as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$reachout_ord.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('is_reachout')) {
      final l$is_reachout = data['is_reachout'];
      result$data['is_reachout'] = (l$is_reachout as int?);
    }
    if (data.containsKey('reachout_date')) {
      final l$reachout_date = data['reachout_date'];
      result$data['reachout_date'] = (l$reachout_date as String?);
    }
    if (data.containsKey('time_zone')) {
      final l$time_zone = data['time_zone'];
      result$data['time_zone'] = (l$time_zone as String?);
    }
    if (data.containsKey('is_reinvite')) {
      final l$is_reinvite = data['is_reinvite'];
      result$data['is_reinvite'] = (l$is_reinvite as bool?);
    }
    if (data.containsKey('is_alert_notification')) {
      final l$is_alert_notification = data['is_alert_notification'];
      result$data['is_alert_notification'] = (l$is_alert_notification as bool?);
    }
    if (data.containsKey('event_approved')) {
      final l$event_approved = data['event_approved'];
      result$data['event_approved'] = (l$event_approved as int?);
    }
    return Input$sendMatchInviteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  List<Input$reachout_ord?>? get reachout_ord =>
      (_$data['reachout_ord'] as List<Input$reachout_ord?>?);

  int? get is_reachout => (_$data['is_reachout'] as int?);

  String? get reachout_date => (_$data['reachout_date'] as String?);

  String? get time_zone => (_$data['time_zone'] as String?);

  bool? get is_reinvite => (_$data['is_reinvite'] as bool?);

  bool? get is_alert_notification => (_$data['is_alert_notification'] as bool?);

  int? get event_approved => (_$data['event_approved'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('reachout_ord')) {
      final l$reachout_ord = reachout_ord;
      result$data['reachout_ord'] =
          l$reachout_ord?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('is_reachout')) {
      final l$is_reachout = is_reachout;
      result$data['is_reachout'] = l$is_reachout;
    }
    if (_$data.containsKey('reachout_date')) {
      final l$reachout_date = reachout_date;
      result$data['reachout_date'] = l$reachout_date;
    }
    if (_$data.containsKey('time_zone')) {
      final l$time_zone = time_zone;
      result$data['time_zone'] = l$time_zone;
    }
    if (_$data.containsKey('is_reinvite')) {
      final l$is_reinvite = is_reinvite;
      result$data['is_reinvite'] = l$is_reinvite;
    }
    if (_$data.containsKey('is_alert_notification')) {
      final l$is_alert_notification = is_alert_notification;
      result$data['is_alert_notification'] = l$is_alert_notification;
    }
    if (_$data.containsKey('event_approved')) {
      final l$event_approved = event_approved;
      result$data['event_approved'] = l$event_approved;
    }
    return result$data;
  }

  CopyWith$Input$sendMatchInviteInput<Input$sendMatchInviteInput>
      get copyWith => CopyWith$Input$sendMatchInviteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$sendMatchInviteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$reachout_ord = reachout_ord;
    final lOther$reachout_ord = other.reachout_ord;
    if (_$data.containsKey('reachout_ord') !=
        other._$data.containsKey('reachout_ord')) {
      return false;
    }
    if (l$reachout_ord != null && lOther$reachout_ord != null) {
      if (l$reachout_ord.length != lOther$reachout_ord.length) {
        return false;
      }
      for (int i = 0; i < l$reachout_ord.length; i++) {
        final l$reachout_ord$entry = l$reachout_ord[i];
        final lOther$reachout_ord$entry = lOther$reachout_ord[i];
        if (l$reachout_ord$entry != lOther$reachout_ord$entry) {
          return false;
        }
      }
    } else if (l$reachout_ord != lOther$reachout_ord) {
      return false;
    }
    final l$is_reachout = is_reachout;
    final lOther$is_reachout = other.is_reachout;
    if (_$data.containsKey('is_reachout') !=
        other._$data.containsKey('is_reachout')) {
      return false;
    }
    if (l$is_reachout != lOther$is_reachout) {
      return false;
    }
    final l$reachout_date = reachout_date;
    final lOther$reachout_date = other.reachout_date;
    if (_$data.containsKey('reachout_date') !=
        other._$data.containsKey('reachout_date')) {
      return false;
    }
    if (l$reachout_date != lOther$reachout_date) {
      return false;
    }
    final l$time_zone = time_zone;
    final lOther$time_zone = other.time_zone;
    if (_$data.containsKey('time_zone') !=
        other._$data.containsKey('time_zone')) {
      return false;
    }
    if (l$time_zone != lOther$time_zone) {
      return false;
    }
    final l$is_reinvite = is_reinvite;
    final lOther$is_reinvite = other.is_reinvite;
    if (_$data.containsKey('is_reinvite') !=
        other._$data.containsKey('is_reinvite')) {
      return false;
    }
    if (l$is_reinvite != lOther$is_reinvite) {
      return false;
    }
    final l$is_alert_notification = is_alert_notification;
    final lOther$is_alert_notification = other.is_alert_notification;
    if (_$data.containsKey('is_alert_notification') !=
        other._$data.containsKey('is_alert_notification')) {
      return false;
    }
    if (l$is_alert_notification != lOther$is_alert_notification) {
      return false;
    }
    final l$event_approved = event_approved;
    final lOther$event_approved = other.event_approved;
    if (_$data.containsKey('event_approved') !=
        other._$data.containsKey('event_approved')) {
      return false;
    }
    if (l$event_approved != lOther$event_approved) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$reachout_ord = reachout_ord;
    final l$is_reachout = is_reachout;
    final l$reachout_date = reachout_date;
    final l$time_zone = time_zone;
    final l$is_reinvite = is_reinvite;
    final l$is_alert_notification = is_alert_notification;
    final l$event_approved = event_approved;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('reachout_ord')
          ? l$reachout_ord == null
              ? null
              : Object.hashAll(l$reachout_ord.map((v) => v))
          : const {},
      _$data.containsKey('is_reachout') ? l$is_reachout : const {},
      _$data.containsKey('reachout_date') ? l$reachout_date : const {},
      _$data.containsKey('time_zone') ? l$time_zone : const {},
      _$data.containsKey('is_reinvite') ? l$is_reinvite : const {},
      _$data.containsKey('is_alert_notification')
          ? l$is_alert_notification
          : const {},
      _$data.containsKey('event_approved') ? l$event_approved : const {},
    ]);
  }
}

abstract class CopyWith$Input$sendMatchInviteInput<TRes> {
  factory CopyWith$Input$sendMatchInviteInput(
    Input$sendMatchInviteInput instance,
    TRes Function(Input$sendMatchInviteInput) then,
  ) = _CopyWithImpl$Input$sendMatchInviteInput;

  factory CopyWith$Input$sendMatchInviteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$sendMatchInviteInput;

  TRes call({
    String? match_id,
    List<Input$reachout_ord?>? reachout_ord,
    int? is_reachout,
    String? reachout_date,
    String? time_zone,
    bool? is_reinvite,
    bool? is_alert_notification,
    int? event_approved,
  });
  TRes reachout_ord(
      Iterable<Input$reachout_ord?>? Function(
              Iterable<CopyWith$Input$reachout_ord<Input$reachout_ord>?>?)
          _fn);
}

class _CopyWithImpl$Input$sendMatchInviteInput<TRes>
    implements CopyWith$Input$sendMatchInviteInput<TRes> {
  _CopyWithImpl$Input$sendMatchInviteInput(
    this._instance,
    this._then,
  );

  final Input$sendMatchInviteInput _instance;

  final TRes Function(Input$sendMatchInviteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? reachout_ord = _undefined,
    Object? is_reachout = _undefined,
    Object? reachout_date = _undefined,
    Object? time_zone = _undefined,
    Object? is_reinvite = _undefined,
    Object? is_alert_notification = _undefined,
    Object? event_approved = _undefined,
  }) =>
      _then(Input$sendMatchInviteInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (reachout_ord != _undefined)
          'reachout_ord': (reachout_ord as List<Input$reachout_ord?>?),
        if (is_reachout != _undefined) 'is_reachout': (is_reachout as int?),
        if (reachout_date != _undefined)
          'reachout_date': (reachout_date as String?),
        if (time_zone != _undefined) 'time_zone': (time_zone as String?),
        if (is_reinvite != _undefined) 'is_reinvite': (is_reinvite as bool?),
        if (is_alert_notification != _undefined)
          'is_alert_notification': (is_alert_notification as bool?),
        if (event_approved != _undefined)
          'event_approved': (event_approved as int?),
      }));

  TRes reachout_ord(
          Iterable<Input$reachout_ord?>? Function(
                  Iterable<CopyWith$Input$reachout_ord<Input$reachout_ord>?>?)
              _fn) =>
      call(
          reachout_ord: _fn(_instance.reachout_ord?.map((e) => e == null
              ? null
              : CopyWith$Input$reachout_ord(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$sendMatchInviteInput<TRes>
    implements CopyWith$Input$sendMatchInviteInput<TRes> {
  _CopyWithStubImpl$Input$sendMatchInviteInput(this._res);

  TRes _res;

  call({
    String? match_id,
    List<Input$reachout_ord?>? reachout_ord,
    int? is_reachout,
    String? reachout_date,
    String? time_zone,
    bool? is_reinvite,
    bool? is_alert_notification,
    int? event_approved,
  }) =>
      _res;

  reachout_ord(_fn) => _res;
}

class Input$reachout_ord {
  factory Input$reachout_ord({
    int? hours,
    int? minute,
    int? slab_no,
    List<Input$players_info?>? players,
  }) =>
      Input$reachout_ord._({
        if (hours != null) r'hours': hours,
        if (minute != null) r'minute': minute,
        if (slab_no != null) r'slab_no': slab_no,
        if (players != null) r'players': players,
      });

  Input$reachout_ord._(this._$data);

  factory Input$reachout_ord.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('hours')) {
      final l$hours = data['hours'];
      result$data['hours'] = (l$hours as int?);
    }
    if (data.containsKey('minute')) {
      final l$minute = data['minute'];
      result$data['minute'] = (l$minute as int?);
    }
    if (data.containsKey('slab_no')) {
      final l$slab_no = data['slab_no'];
      result$data['slab_no'] = (l$slab_no as int?);
    }
    if (data.containsKey('players')) {
      final l$players = data['players'];
      result$data['players'] = (l$players as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$players_info.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$reachout_ord._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get hours => (_$data['hours'] as int?);

  int? get minute => (_$data['minute'] as int?);

  int? get slab_no => (_$data['slab_no'] as int?);

  List<Input$players_info?>? get players =>
      (_$data['players'] as List<Input$players_info?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('hours')) {
      final l$hours = hours;
      result$data['hours'] = l$hours;
    }
    if (_$data.containsKey('minute')) {
      final l$minute = minute;
      result$data['minute'] = l$minute;
    }
    if (_$data.containsKey('slab_no')) {
      final l$slab_no = slab_no;
      result$data['slab_no'] = l$slab_no;
    }
    if (_$data.containsKey('players')) {
      final l$players = players;
      result$data['players'] = l$players?.map((e) => e?.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$reachout_ord<Input$reachout_ord> get copyWith =>
      CopyWith$Input$reachout_ord(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$reachout_ord) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$hours = hours;
    final lOther$hours = other.hours;
    if (_$data.containsKey('hours') != other._$data.containsKey('hours')) {
      return false;
    }
    if (l$hours != lOther$hours) {
      return false;
    }
    final l$minute = minute;
    final lOther$minute = other.minute;
    if (_$data.containsKey('minute') != other._$data.containsKey('minute')) {
      return false;
    }
    if (l$minute != lOther$minute) {
      return false;
    }
    final l$slab_no = slab_no;
    final lOther$slab_no = other.slab_no;
    if (_$data.containsKey('slab_no') != other._$data.containsKey('slab_no')) {
      return false;
    }
    if (l$slab_no != lOther$slab_no) {
      return false;
    }
    final l$players = players;
    final lOther$players = other.players;
    if (_$data.containsKey('players') != other._$data.containsKey('players')) {
      return false;
    }
    if (l$players != null && lOther$players != null) {
      if (l$players.length != lOther$players.length) {
        return false;
      }
      for (int i = 0; i < l$players.length; i++) {
        final l$players$entry = l$players[i];
        final lOther$players$entry = lOther$players[i];
        if (l$players$entry != lOther$players$entry) {
          return false;
        }
      }
    } else if (l$players != lOther$players) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$hours = hours;
    final l$minute = minute;
    final l$slab_no = slab_no;
    final l$players = players;
    return Object.hashAll([
      _$data.containsKey('hours') ? l$hours : const {},
      _$data.containsKey('minute') ? l$minute : const {},
      _$data.containsKey('slab_no') ? l$slab_no : const {},
      _$data.containsKey('players')
          ? l$players == null
              ? null
              : Object.hashAll(l$players.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$reachout_ord<TRes> {
  factory CopyWith$Input$reachout_ord(
    Input$reachout_ord instance,
    TRes Function(Input$reachout_ord) then,
  ) = _CopyWithImpl$Input$reachout_ord;

  factory CopyWith$Input$reachout_ord.stub(TRes res) =
      _CopyWithStubImpl$Input$reachout_ord;

  TRes call({
    int? hours,
    int? minute,
    int? slab_no,
    List<Input$players_info?>? players,
  });
  TRes players(
      Iterable<Input$players_info?>? Function(
              Iterable<CopyWith$Input$players_info<Input$players_info>?>?)
          _fn);
}

class _CopyWithImpl$Input$reachout_ord<TRes>
    implements CopyWith$Input$reachout_ord<TRes> {
  _CopyWithImpl$Input$reachout_ord(
    this._instance,
    this._then,
  );

  final Input$reachout_ord _instance;

  final TRes Function(Input$reachout_ord) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? hours = _undefined,
    Object? minute = _undefined,
    Object? slab_no = _undefined,
    Object? players = _undefined,
  }) =>
      _then(Input$reachout_ord._({
        ..._instance._$data,
        if (hours != _undefined) 'hours': (hours as int?),
        if (minute != _undefined) 'minute': (minute as int?),
        if (slab_no != _undefined) 'slab_no': (slab_no as int?),
        if (players != _undefined)
          'players': (players as List<Input$players_info?>?),
      }));

  TRes players(
          Iterable<Input$players_info?>? Function(
                  Iterable<CopyWith$Input$players_info<Input$players_info>?>?)
              _fn) =>
      call(
          players: _fn(_instance.players?.map((e) => e == null
              ? null
              : CopyWith$Input$players_info(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$reachout_ord<TRes>
    implements CopyWith$Input$reachout_ord<TRes> {
  _CopyWithStubImpl$Input$reachout_ord(this._res);

  TRes _res;

  call({
    int? hours,
    int? minute,
    int? slab_no,
    List<Input$players_info?>? players,
  }) =>
      _res;

  players(_fn) => _res;
}

class Input$players_info {
  factory Input$players_info({
    String? player_id,
    int? type,
    String? group_id,
  }) =>
      Input$players_info._({
        if (player_id != null) r'player_id': player_id,
        if (type != null) r'type': type,
        if (group_id != null) r'group_id': group_id,
      });

  Input$players_info._(this._$data);

  factory Input$players_info.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('player_id')) {
      final l$player_id = data['player_id'];
      result$data['player_id'] = (l$player_id as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    if (data.containsKey('group_id')) {
      final l$group_id = data['group_id'];
      result$data['group_id'] = (l$group_id as String?);
    }
    return Input$players_info._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get player_id => (_$data['player_id'] as String?);

  int? get type => (_$data['type'] as int?);

  String? get group_id => (_$data['group_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('player_id')) {
      final l$player_id = player_id;
      result$data['player_id'] = l$player_id;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('group_id')) {
      final l$group_id = group_id;
      result$data['group_id'] = l$group_id;
    }
    return result$data;
  }

  CopyWith$Input$players_info<Input$players_info> get copyWith =>
      CopyWith$Input$players_info(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$players_info) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$player_id = player_id;
    final lOther$player_id = other.player_id;
    if (_$data.containsKey('player_id') !=
        other._$data.containsKey('player_id')) {
      return false;
    }
    if (l$player_id != lOther$player_id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$group_id = group_id;
    final lOther$group_id = other.group_id;
    if (_$data.containsKey('group_id') !=
        other._$data.containsKey('group_id')) {
      return false;
    }
    if (l$group_id != lOther$group_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$player_id = player_id;
    final l$type = type;
    final l$group_id = group_id;
    return Object.hashAll([
      _$data.containsKey('player_id') ? l$player_id : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('group_id') ? l$group_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$players_info<TRes> {
  factory CopyWith$Input$players_info(
    Input$players_info instance,
    TRes Function(Input$players_info) then,
  ) = _CopyWithImpl$Input$players_info;

  factory CopyWith$Input$players_info.stub(TRes res) =
      _CopyWithStubImpl$Input$players_info;

  TRes call({
    String? player_id,
    int? type,
    String? group_id,
  });
}

class _CopyWithImpl$Input$players_info<TRes>
    implements CopyWith$Input$players_info<TRes> {
  _CopyWithImpl$Input$players_info(
    this._instance,
    this._then,
  );

  final Input$players_info _instance;

  final TRes Function(Input$players_info) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? player_id = _undefined,
    Object? type = _undefined,
    Object? group_id = _undefined,
  }) =>
      _then(Input$players_info._({
        ..._instance._$data,
        if (player_id != _undefined) 'player_id': (player_id as String?),
        if (type != _undefined) 'type': (type as int?),
        if (group_id != _undefined) 'group_id': (group_id as String?),
      }));
}

class _CopyWithStubImpl$Input$players_info<TRes>
    implements CopyWith$Input$players_info<TRes> {
  _CopyWithStubImpl$Input$players_info(this._res);

  TRes _res;

  call({
    String? player_id,
    int? type,
    String? group_id,
  }) =>
      _res;
}

class Input$sendMatchReInviteInput {
  factory Input$sendMatchReInviteInput({
    String? match_id,
    String? user_id,
  }) =>
      Input$sendMatchReInviteInput._({
        if (match_id != null) r'match_id': match_id,
        if (user_id != null) r'user_id': user_id,
      });

  Input$sendMatchReInviteInput._(this._$data);

  factory Input$sendMatchReInviteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$sendMatchReInviteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$sendMatchReInviteInput<Input$sendMatchReInviteInput>
      get copyWith => CopyWith$Input$sendMatchReInviteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$sendMatchReInviteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$sendMatchReInviteInput<TRes> {
  factory CopyWith$Input$sendMatchReInviteInput(
    Input$sendMatchReInviteInput instance,
    TRes Function(Input$sendMatchReInviteInput) then,
  ) = _CopyWithImpl$Input$sendMatchReInviteInput;

  factory CopyWith$Input$sendMatchReInviteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$sendMatchReInviteInput;

  TRes call({
    String? match_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$sendMatchReInviteInput<TRes>
    implements CopyWith$Input$sendMatchReInviteInput<TRes> {
  _CopyWithImpl$Input$sendMatchReInviteInput(
    this._instance,
    this._then,
  );

  final Input$sendMatchReInviteInput _instance;

  final TRes Function(Input$sendMatchReInviteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$sendMatchReInviteInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$sendMatchReInviteInput<TRes>
    implements CopyWith$Input$sendMatchReInviteInput<TRes> {
  _CopyWithStubImpl$Input$sendMatchReInviteInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
  }) =>
      _res;
}

class Input$OpenMatchListFrontPaginationInput {
  factory Input$OpenMatchListFrontPaginationInput({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
  }) =>
      Input$OpenMatchListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
      });

  Input$OpenMatchListFrontPaginationInput._(this._$data);

  factory Input$OpenMatchListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$OpenMatchListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$OpenMatchListFrontPaginationInput<
          Input$OpenMatchListFrontPaginationInput>
      get copyWith => CopyWith$Input$OpenMatchListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpenMatchListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpenMatchListFrontPaginationInput<TRes> {
  factory CopyWith$Input$OpenMatchListFrontPaginationInput(
    Input$OpenMatchListFrontPaginationInput instance,
    TRes Function(Input$OpenMatchListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$OpenMatchListFrontPaginationInput;

  factory CopyWith$Input$OpenMatchListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OpenMatchListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
  });
}

class _CopyWithImpl$Input$OpenMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenMatchListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$OpenMatchListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$OpenMatchListFrontPaginationInput _instance;

  final TRes Function(Input$OpenMatchListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
  }) =>
      _then(Input$OpenMatchListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$OpenMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenMatchListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$OpenMatchListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
  }) =>
      _res;
}

class Input$viewGroupInput {
  factory Input$viewGroupInput({required String uuid}) =>
      Input$viewGroupInput._({
        r'uuid': uuid,
      });

  Input$viewGroupInput._(this._$data);

  factory Input$viewGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewGroupInput<Input$viewGroupInput> get copyWith =>
      CopyWith$Input$viewGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewGroupInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewGroupInput<TRes> {
  factory CopyWith$Input$viewGroupInput(
    Input$viewGroupInput instance,
    TRes Function(Input$viewGroupInput) then,
  ) = _CopyWithImpl$Input$viewGroupInput;

  factory CopyWith$Input$viewGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewGroupInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewGroupInput<TRes>
    implements CopyWith$Input$viewGroupInput<TRes> {
  _CopyWithImpl$Input$viewGroupInput(
    this._instance,
    this._then,
  );

  final Input$viewGroupInput _instance;

  final TRes Function(Input$viewGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewGroupInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewGroupInput<TRes>
    implements CopyWith$Input$viewGroupInput<TRes> {
  _CopyWithStubImpl$Input$viewGroupInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AddRequestPlayInput {
  factory Input$AddRequestPlayInput({
    required String match_id,
    required String user_id,
  }) =>
      Input$AddRequestPlayInput._({
        r'match_id': match_id,
        r'user_id': user_id,
      });

  Input$AddRequestPlayInput._(this._$data);

  factory Input$AddRequestPlayInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    return Input$AddRequestPlayInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    return result$data;
  }

  CopyWith$Input$AddRequestPlayInput<Input$AddRequestPlayInput> get copyWith =>
      CopyWith$Input$AddRequestPlayInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddRequestPlayInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    return Object.hashAll([
      l$match_id,
      l$user_id,
    ]);
  }
}

abstract class CopyWith$Input$AddRequestPlayInput<TRes> {
  factory CopyWith$Input$AddRequestPlayInput(
    Input$AddRequestPlayInput instance,
    TRes Function(Input$AddRequestPlayInput) then,
  ) = _CopyWithImpl$Input$AddRequestPlayInput;

  factory CopyWith$Input$AddRequestPlayInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddRequestPlayInput;

  TRes call({
    String? match_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$AddRequestPlayInput<TRes>
    implements CopyWith$Input$AddRequestPlayInput<TRes> {
  _CopyWithImpl$Input$AddRequestPlayInput(
    this._instance,
    this._then,
  );

  final Input$AddRequestPlayInput _instance;

  final TRes Function(Input$AddRequestPlayInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$AddRequestPlayInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddRequestPlayInput<TRes>
    implements CopyWith$Input$AddRequestPlayInput<TRes> {
  _CopyWithStubImpl$Input$AddRequestPlayInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
  }) =>
      _res;
}

class Input$PlyerRequestAcceptInput {
  factory Input$PlyerRequestAcceptInput({
    required String match_id,
    required String user_id,
    int? tier_price,
    String? tier_description,
  }) =>
      Input$PlyerRequestAcceptInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        if (tier_price != null) r'tier_price': tier_price,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$PlyerRequestAcceptInput._(this._$data);

  factory Input$PlyerRequestAcceptInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    if (data.containsKey('tier_price')) {
      final l$tier_price = data['tier_price'];
      result$data['tier_price'] = (l$tier_price as int?);
    }
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$PlyerRequestAcceptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  int? get tier_price => (_$data['tier_price'] as int?);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    if (_$data.containsKey('tier_price')) {
      final l$tier_price = tier_price;
      result$data['tier_price'] = l$tier_price;
    }
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$PlyerRequestAcceptInput<Input$PlyerRequestAcceptInput>
      get copyWith => CopyWith$Input$PlyerRequestAcceptInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlyerRequestAcceptInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$tier_price = tier_price;
    final lOther$tier_price = other.tier_price;
    if (_$data.containsKey('tier_price') !=
        other._$data.containsKey('tier_price')) {
      return false;
    }
    if (l$tier_price != lOther$tier_price) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$tier_price = tier_price;
    final l$tier_description = tier_description;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      _$data.containsKey('tier_price') ? l$tier_price : const {},
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlyerRequestAcceptInput<TRes> {
  factory CopyWith$Input$PlyerRequestAcceptInput(
    Input$PlyerRequestAcceptInput instance,
    TRes Function(Input$PlyerRequestAcceptInput) then,
  ) = _CopyWithImpl$Input$PlyerRequestAcceptInput;

  factory CopyWith$Input$PlyerRequestAcceptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlyerRequestAcceptInput;

  TRes call({
    String? match_id,
    String? user_id,
    int? tier_price,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$PlyerRequestAcceptInput<TRes>
    implements CopyWith$Input$PlyerRequestAcceptInput<TRes> {
  _CopyWithImpl$Input$PlyerRequestAcceptInput(
    this._instance,
    this._then,
  );

  final Input$PlyerRequestAcceptInput _instance;

  final TRes Function(Input$PlyerRequestAcceptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? tier_price = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$PlyerRequestAcceptInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (tier_price != _undefined) 'tier_price': (tier_price as int?),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$PlyerRequestAcceptInput<TRes>
    implements CopyWith$Input$PlyerRequestAcceptInput<TRes> {
  _CopyWithStubImpl$Input$PlyerRequestAcceptInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    int? tier_price,
    String? tier_description,
  }) =>
      _res;
}

class Input$PlyerRequestRejectInput {
  factory Input$PlyerRequestRejectInput({
    required String match_id,
    required String user_id,
    bool? is_host_reject,
  }) =>
      Input$PlyerRequestRejectInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        if (is_host_reject != null) r'is_host_reject': is_host_reject,
      });

  Input$PlyerRequestRejectInput._(this._$data);

  factory Input$PlyerRequestRejectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    if (data.containsKey('is_host_reject')) {
      final l$is_host_reject = data['is_host_reject'];
      result$data['is_host_reject'] = (l$is_host_reject as bool?);
    }
    return Input$PlyerRequestRejectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  bool? get is_host_reject => (_$data['is_host_reject'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    if (_$data.containsKey('is_host_reject')) {
      final l$is_host_reject = is_host_reject;
      result$data['is_host_reject'] = l$is_host_reject;
    }
    return result$data;
  }

  CopyWith$Input$PlyerRequestRejectInput<Input$PlyerRequestRejectInput>
      get copyWith => CopyWith$Input$PlyerRequestRejectInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlyerRequestRejectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_host_reject = is_host_reject;
    final lOther$is_host_reject = other.is_host_reject;
    if (_$data.containsKey('is_host_reject') !=
        other._$data.containsKey('is_host_reject')) {
      return false;
    }
    if (l$is_host_reject != lOther$is_host_reject) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_host_reject = is_host_reject;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      _$data.containsKey('is_host_reject') ? l$is_host_reject : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlyerRequestRejectInput<TRes> {
  factory CopyWith$Input$PlyerRequestRejectInput(
    Input$PlyerRequestRejectInput instance,
    TRes Function(Input$PlyerRequestRejectInput) then,
  ) = _CopyWithImpl$Input$PlyerRequestRejectInput;

  factory CopyWith$Input$PlyerRequestRejectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlyerRequestRejectInput;

  TRes call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
  });
}

class _CopyWithImpl$Input$PlyerRequestRejectInput<TRes>
    implements CopyWith$Input$PlyerRequestRejectInput<TRes> {
  _CopyWithImpl$Input$PlyerRequestRejectInput(
    this._instance,
    this._then,
  );

  final Input$PlyerRequestRejectInput _instance;

  final TRes Function(Input$PlyerRequestRejectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_host_reject = _undefined,
  }) =>
      _then(Input$PlyerRequestRejectInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_host_reject != _undefined)
          'is_host_reject': (is_host_reject as bool?),
      }));
}

class _CopyWithStubImpl$Input$PlyerRequestRejectInput<TRes>
    implements CopyWith$Input$PlyerRequestRejectInput<TRes> {
  _CopyWithStubImpl$Input$PlyerRequestRejectInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
  }) =>
      _res;
}

class Input$matchUserInput {
  factory Input$matchUserInput({
    required String match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$matchUserInput._({
        r'match_id': match_id,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$matchUserInput._(this._$data);

  factory Input$matchUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$matchUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$matchUserInput<Input$matchUserInput> get copyWith =>
      CopyWith$Input$matchUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$matchUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$match_id,
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$matchUserInput<TRes> {
  factory CopyWith$Input$matchUserInput(
    Input$matchUserInput instance,
    TRes Function(Input$matchUserInput) then,
  ) = _CopyWithImpl$Input$matchUserInput;

  factory CopyWith$Input$matchUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$matchUserInput;

  TRes call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$matchUserInput<TRes>
    implements CopyWith$Input$matchUserInput<TRes> {
  _CopyWithImpl$Input$matchUserInput(
    this._instance,
    this._then,
  );

  final Input$matchUserInput _instance;

  final TRes Function(Input$matchUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$matchUserInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$matchUserInput<TRes>
    implements CopyWith$Input$matchUserInput<TRes> {
  _CopyWithStubImpl$Input$matchUserInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddSupportInput {
  factory Input$AddSupportInput({
    String? version,
    String? platform,
    String? category,
    String? message,
  }) =>
      Input$AddSupportInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (category != null) r'category': category,
        if (message != null) r'message': message,
      });

  Input$AddSupportInput._(this._$data);

  factory Input$AddSupportInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    return Input$AddSupportInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get category => (_$data['category'] as String?);

  String? get message => (_$data['message'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    return result$data;
  }

  CopyWith$Input$AddSupportInput<Input$AddSupportInput> get copyWith =>
      CopyWith$Input$AddSupportInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddSupportInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$category = category;
    final l$message = message;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('message') ? l$message : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddSupportInput<TRes> {
  factory CopyWith$Input$AddSupportInput(
    Input$AddSupportInput instance,
    TRes Function(Input$AddSupportInput) then,
  ) = _CopyWithImpl$Input$AddSupportInput;

  factory CopyWith$Input$AddSupportInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddSupportInput;

  TRes call({
    String? version,
    String? platform,
    String? category,
    String? message,
  });
}

class _CopyWithImpl$Input$AddSupportInput<TRes>
    implements CopyWith$Input$AddSupportInput<TRes> {
  _CopyWithImpl$Input$AddSupportInput(
    this._instance,
    this._then,
  );

  final Input$AddSupportInput _instance;

  final TRes Function(Input$AddSupportInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? category = _undefined,
    Object? message = _undefined,
  }) =>
      _then(Input$AddSupportInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (category != _undefined) 'category': (category as String?),
        if (message != _undefined) 'message': (message as String?),
      }));
}

class _CopyWithStubImpl$Input$AddSupportInput<TRes>
    implements CopyWith$Input$AddSupportInput<TRes> {
  _CopyWithStubImpl$Input$AddSupportInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? category,
    String? message,
  }) =>
      _res;
}

class Input$SupportListPaginationInput {
  factory Input$SupportListPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$SupportListPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$SupportListPaginationInput._(this._$data);

  factory Input$SupportListPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$SupportListPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$SupportListPaginationInput<Input$SupportListPaginationInput>
      get copyWith => CopyWith$Input$SupportListPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SupportListPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$SupportListPaginationInput<TRes> {
  factory CopyWith$Input$SupportListPaginationInput(
    Input$SupportListPaginationInput instance,
    TRes Function(Input$SupportListPaginationInput) then,
  ) = _CopyWithImpl$Input$SupportListPaginationInput;

  factory CopyWith$Input$SupportListPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SupportListPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$SupportListPaginationInput<TRes>
    implements CopyWith$Input$SupportListPaginationInput<TRes> {
  _CopyWithImpl$Input$SupportListPaginationInput(
    this._instance,
    this._then,
  );

  final Input$SupportListPaginationInput _instance;

  final TRes Function(Input$SupportListPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$SupportListPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$SupportListPaginationInput<TRes>
    implements CopyWith$Input$SupportListPaginationInput<TRes> {
  _CopyWithStubImpl$Input$SupportListPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewSupportDetailInput {
  factory Input$viewSupportDetailInput({required String uuid}) =>
      Input$viewSupportDetailInput._({
        r'uuid': uuid,
      });

  Input$viewSupportDetailInput._(this._$data);

  factory Input$viewSupportDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewSupportDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewSupportDetailInput<Input$viewSupportDetailInput>
      get copyWith => CopyWith$Input$viewSupportDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewSupportDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewSupportDetailInput<TRes> {
  factory CopyWith$Input$viewSupportDetailInput(
    Input$viewSupportDetailInput instance,
    TRes Function(Input$viewSupportDetailInput) then,
  ) = _CopyWithImpl$Input$viewSupportDetailInput;

  factory CopyWith$Input$viewSupportDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewSupportDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewSupportDetailInput<TRes>
    implements CopyWith$Input$viewSupportDetailInput<TRes> {
  _CopyWithImpl$Input$viewSupportDetailInput(
    this._instance,
    this._then,
  );

  final Input$viewSupportDetailInput _instance;

  final TRes Function(Input$viewSupportDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$viewSupportDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewSupportDetailInput<TRes>
    implements CopyWith$Input$viewSupportDetailInput<TRes> {
  _CopyWithStubImpl$Input$viewSupportDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ReplaySupportInput {
  factory Input$ReplaySupportInput({
    required String uuid,
    String? note,
  }) =>
      Input$ReplaySupportInput._({
        r'uuid': uuid,
        if (note != null) r'note': note,
      });

  Input$ReplaySupportInput._(this._$data);

  factory Input$ReplaySupportInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$ReplaySupportInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$ReplaySupportInput<Input$ReplaySupportInput> get copyWith =>
      CopyWith$Input$ReplaySupportInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReplaySupportInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$note = note;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReplaySupportInput<TRes> {
  factory CopyWith$Input$ReplaySupportInput(
    Input$ReplaySupportInput instance,
    TRes Function(Input$ReplaySupportInput) then,
  ) = _CopyWithImpl$Input$ReplaySupportInput;

  factory CopyWith$Input$ReplaySupportInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReplaySupportInput;

  TRes call({
    String? uuid,
    String? note,
  });
}

class _CopyWithImpl$Input$ReplaySupportInput<TRes>
    implements CopyWith$Input$ReplaySupportInput<TRes> {
  _CopyWithImpl$Input$ReplaySupportInput(
    this._instance,
    this._then,
  );

  final Input$ReplaySupportInput _instance;

  final TRes Function(Input$ReplaySupportInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? note = _undefined,
  }) =>
      _then(Input$ReplaySupportInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (note != _undefined) 'note': (note as String?),
      }));
}

class _CopyWithStubImpl$Input$ReplaySupportInput<TRes>
    implements CopyWith$Input$ReplaySupportInput<TRes> {
  _CopyWithStubImpl$Input$ReplaySupportInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? note,
  }) =>
      _res;
}

class Input$ReportReasonInput {
  factory Input$ReportReasonInput({int? type}) => Input$ReportReasonInput._({
        if (type != null) r'type': type,
      });

  Input$ReportReasonInput._(this._$data);

  factory Input$ReportReasonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    return Input$ReportReasonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get type => (_$data['type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    return result$data;
  }

  CopyWith$Input$ReportReasonInput<Input$ReportReasonInput> get copyWith =>
      CopyWith$Input$ReportReasonInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReportReasonInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    return Object.hashAll([_$data.containsKey('type') ? l$type : const {}]);
  }
}

abstract class CopyWith$Input$ReportReasonInput<TRes> {
  factory CopyWith$Input$ReportReasonInput(
    Input$ReportReasonInput instance,
    TRes Function(Input$ReportReasonInput) then,
  ) = _CopyWithImpl$Input$ReportReasonInput;

  factory CopyWith$Input$ReportReasonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportReasonInput;

  TRes call({int? type});
}

class _CopyWithImpl$Input$ReportReasonInput<TRes>
    implements CopyWith$Input$ReportReasonInput<TRes> {
  _CopyWithImpl$Input$ReportReasonInput(
    this._instance,
    this._then,
  );

  final Input$ReportReasonInput _instance;

  final TRes Function(Input$ReportReasonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? type = _undefined}) => _then(Input$ReportReasonInput._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as int?),
      }));
}

class _CopyWithStubImpl$Input$ReportReasonInput<TRes>
    implements CopyWith$Input$ReportReasonInput<TRes> {
  _CopyWithStubImpl$Input$ReportReasonInput(this._res);

  TRes _res;

  call({int? type}) => _res;
}

class Input$AddReportInput {
  factory Input$AddReportInput({
    String? version,
    String? platform,
    String? reason,
    String? report_uesr_email,
    String? description,
  }) =>
      Input$AddReportInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (reason != null) r'reason': reason,
        if (report_uesr_email != null) r'report_uesr_email': report_uesr_email,
        if (description != null) r'description': description,
      });

  Input$AddReportInput._(this._$data);

  factory Input$AddReportInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    if (data.containsKey('report_uesr_email')) {
      final l$report_uesr_email = data['report_uesr_email'];
      result$data['report_uesr_email'] = (l$report_uesr_email as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$AddReportInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get reason => (_$data['reason'] as String?);

  String? get report_uesr_email => (_$data['report_uesr_email'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    if (_$data.containsKey('report_uesr_email')) {
      final l$report_uesr_email = report_uesr_email;
      result$data['report_uesr_email'] = l$report_uesr_email;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$AddReportInput<Input$AddReportInput> get copyWith =>
      CopyWith$Input$AddReportInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddReportInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$report_uesr_email = report_uesr_email;
    final lOther$report_uesr_email = other.report_uesr_email;
    if (_$data.containsKey('report_uesr_email') !=
        other._$data.containsKey('report_uesr_email')) {
      return false;
    }
    if (l$report_uesr_email != lOther$report_uesr_email) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$reason = reason;
    final l$report_uesr_email = report_uesr_email;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('report_uesr_email') ? l$report_uesr_email : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddReportInput<TRes> {
  factory CopyWith$Input$AddReportInput(
    Input$AddReportInput instance,
    TRes Function(Input$AddReportInput) then,
  ) = _CopyWithImpl$Input$AddReportInput;

  factory CopyWith$Input$AddReportInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddReportInput;

  TRes call({
    String? version,
    String? platform,
    String? reason,
    String? report_uesr_email,
    String? description,
  });
}

class _CopyWithImpl$Input$AddReportInput<TRes>
    implements CopyWith$Input$AddReportInput<TRes> {
  _CopyWithImpl$Input$AddReportInput(
    this._instance,
    this._then,
  );

  final Input$AddReportInput _instance;

  final TRes Function(Input$AddReportInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? reason = _undefined,
    Object? report_uesr_email = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$AddReportInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (reason != _undefined) 'reason': (reason as String?),
        if (report_uesr_email != _undefined)
          'report_uesr_email': (report_uesr_email as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$AddReportInput<TRes>
    implements CopyWith$Input$AddReportInput<TRes> {
  _CopyWithStubImpl$Input$AddReportInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? reason,
    String? report_uesr_email,
    String? description,
  }) =>
      _res;
}

class Input$AddCommentReportInput {
  factory Input$AddCommentReportInput({
    String? version,
    String? platform,
    String? comment_uuid,
    String? reason,
    String? description,
  }) =>
      Input$AddCommentReportInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (comment_uuid != null) r'comment_uuid': comment_uuid,
        if (reason != null) r'reason': reason,
        if (description != null) r'description': description,
      });

  Input$AddCommentReportInput._(this._$data);

  factory Input$AddCommentReportInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('comment_uuid')) {
      final l$comment_uuid = data['comment_uuid'];
      result$data['comment_uuid'] = (l$comment_uuid as String?);
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = (l$reason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$AddCommentReportInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get comment_uuid => (_$data['comment_uuid'] as String?);

  String? get reason => (_$data['reason'] as String?);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('comment_uuid')) {
      final l$comment_uuid = comment_uuid;
      result$data['comment_uuid'] = l$comment_uuid;
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$AddCommentReportInput<Input$AddCommentReportInput>
      get copyWith => CopyWith$Input$AddCommentReportInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddCommentReportInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$comment_uuid = comment_uuid;
    final lOther$comment_uuid = other.comment_uuid;
    if (_$data.containsKey('comment_uuid') !=
        other._$data.containsKey('comment_uuid')) {
      return false;
    }
    if (l$comment_uuid != lOther$comment_uuid) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$comment_uuid = comment_uuid;
    final l$reason = reason;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('comment_uuid') ? l$comment_uuid : const {},
      _$data.containsKey('reason') ? l$reason : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddCommentReportInput<TRes> {
  factory CopyWith$Input$AddCommentReportInput(
    Input$AddCommentReportInput instance,
    TRes Function(Input$AddCommentReportInput) then,
  ) = _CopyWithImpl$Input$AddCommentReportInput;

  factory CopyWith$Input$AddCommentReportInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCommentReportInput;

  TRes call({
    String? version,
    String? platform,
    String? comment_uuid,
    String? reason,
    String? description,
  });
}

class _CopyWithImpl$Input$AddCommentReportInput<TRes>
    implements CopyWith$Input$AddCommentReportInput<TRes> {
  _CopyWithImpl$Input$AddCommentReportInput(
    this._instance,
    this._then,
  );

  final Input$AddCommentReportInput _instance;

  final TRes Function(Input$AddCommentReportInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? comment_uuid = _undefined,
    Object? reason = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$AddCommentReportInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (comment_uuid != _undefined)
          'comment_uuid': (comment_uuid as String?),
        if (reason != _undefined) 'reason': (reason as String?),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$AddCommentReportInput<TRes>
    implements CopyWith$Input$AddCommentReportInput<TRes> {
  _CopyWithStubImpl$Input$AddCommentReportInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? comment_uuid,
    String? reason,
    String? description,
  }) =>
      _res;
}

class Input$ReportDataInput {
  factory Input$ReportDataInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$ReportDataInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$ReportDataInput._(this._$data);

  factory Input$ReportDataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$ReportDataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$ReportDataInput<Input$ReportDataInput> get copyWith =>
      CopyWith$Input$ReportDataInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReportDataInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportDataInput<TRes> {
  factory CopyWith$Input$ReportDataInput(
    Input$ReportDataInput instance,
    TRes Function(Input$ReportDataInput) then,
  ) = _CopyWithImpl$Input$ReportDataInput;

  factory CopyWith$Input$ReportDataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportDataInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$ReportDataInput<TRes>
    implements CopyWith$Input$ReportDataInput<TRes> {
  _CopyWithImpl$Input$ReportDataInput(
    this._instance,
    this._then,
  );

  final Input$ReportDataInput _instance;

  final TRes Function(Input$ReportDataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$ReportDataInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$ReportDataInput<TRes>
    implements CopyWith$Input$ReportDataInput<TRes> {
  _CopyWithStubImpl$Input$ReportDataInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$CommentReportDataInput {
  factory Input$CommentReportDataInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$CommentReportDataInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$CommentReportDataInput._(this._$data);

  factory Input$CommentReportDataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$CommentReportDataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$CommentReportDataInput<Input$CommentReportDataInput>
      get copyWith => CopyWith$Input$CommentReportDataInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommentReportDataInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommentReportDataInput<TRes> {
  factory CopyWith$Input$CommentReportDataInput(
    Input$CommentReportDataInput instance,
    TRes Function(Input$CommentReportDataInput) then,
  ) = _CopyWithImpl$Input$CommentReportDataInput;

  factory CopyWith$Input$CommentReportDataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentReportDataInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$CommentReportDataInput<TRes>
    implements CopyWith$Input$CommentReportDataInput<TRes> {
  _CopyWithImpl$Input$CommentReportDataInput(
    this._instance,
    this._then,
  );

  final Input$CommentReportDataInput _instance;

  final TRes Function(Input$CommentReportDataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$CommentReportDataInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$CommentReportDataInput<TRes>
    implements CopyWith$Input$CommentReportDataInput<TRes> {
  _CopyWithStubImpl$Input$CommentReportDataInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$getCmsDataInput {
  factory Input$getCmsDataInput({required String slug}) =>
      Input$getCmsDataInput._({
        r'slug': slug,
      });

  Input$getCmsDataInput._(this._$data);

  factory Input$getCmsDataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$slug = data['slug'];
    result$data['slug'] = (l$slug as String);
    return Input$getCmsDataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get slug => (_$data['slug'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$slug = slug;
    result$data['slug'] = l$slug;
    return result$data;
  }

  CopyWith$Input$getCmsDataInput<Input$getCmsDataInput> get copyWith =>
      CopyWith$Input$getCmsDataInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getCmsDataInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$slug = slug;
    final lOther$slug = other.slug;
    if (l$slug != lOther$slug) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$slug = slug;
    return Object.hashAll([l$slug]);
  }
}

abstract class CopyWith$Input$getCmsDataInput<TRes> {
  factory CopyWith$Input$getCmsDataInput(
    Input$getCmsDataInput instance,
    TRes Function(Input$getCmsDataInput) then,
  ) = _CopyWithImpl$Input$getCmsDataInput;

  factory CopyWith$Input$getCmsDataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getCmsDataInput;

  TRes call({String? slug});
}

class _CopyWithImpl$Input$getCmsDataInput<TRes>
    implements CopyWith$Input$getCmsDataInput<TRes> {
  _CopyWithImpl$Input$getCmsDataInput(
    this._instance,
    this._then,
  );

  final Input$getCmsDataInput _instance;

  final TRes Function(Input$getCmsDataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? slug = _undefined}) => _then(Input$getCmsDataInput._({
        ..._instance._$data,
        if (slug != _undefined && slug != null) 'slug': (slug as String),
      }));
}

class _CopyWithStubImpl$Input$getCmsDataInput<TRes>
    implements CopyWith$Input$getCmsDataInput<TRes> {
  _CopyWithStubImpl$Input$getCmsDataInput(this._res);

  TRes _res;

  call({String? slug}) => _res;
}

class Input$AcceptMatchInviteInput {
  factory Input$AcceptMatchInviteInput({String? match_id}) =>
      Input$AcceptMatchInviteInput._({
        if (match_id != null) r'match_id': match_id,
      });

  Input$AcceptMatchInviteInput._(this._$data);

  factory Input$AcceptMatchInviteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$AcceptMatchInviteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$AcceptMatchInviteInput<Input$AcceptMatchInviteInput>
      get copyWith => CopyWith$Input$AcceptMatchInviteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AcceptMatchInviteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    return Object.hashAll(
        [_$data.containsKey('match_id') ? l$match_id : const {}]);
  }
}

abstract class CopyWith$Input$AcceptMatchInviteInput<TRes> {
  factory CopyWith$Input$AcceptMatchInviteInput(
    Input$AcceptMatchInviteInput instance,
    TRes Function(Input$AcceptMatchInviteInput) then,
  ) = _CopyWithImpl$Input$AcceptMatchInviteInput;

  factory CopyWith$Input$AcceptMatchInviteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AcceptMatchInviteInput;

  TRes call({String? match_id});
}

class _CopyWithImpl$Input$AcceptMatchInviteInput<TRes>
    implements CopyWith$Input$AcceptMatchInviteInput<TRes> {
  _CopyWithImpl$Input$AcceptMatchInviteInput(
    this._instance,
    this._then,
  );

  final Input$AcceptMatchInviteInput _instance;

  final TRes Function(Input$AcceptMatchInviteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_id = _undefined}) =>
      _then(Input$AcceptMatchInviteInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AcceptMatchInviteInput<TRes>
    implements CopyWith$Input$AcceptMatchInviteInput<TRes> {
  _CopyWithStubImpl$Input$AcceptMatchInviteInput(this._res);

  TRes _res;

  call({String? match_id}) => _res;
}

class Input$RejectMatchInviteInput {
  factory Input$RejectMatchInviteInput({String? match_id}) =>
      Input$RejectMatchInviteInput._({
        if (match_id != null) r'match_id': match_id,
      });

  Input$RejectMatchInviteInput._(this._$data);

  factory Input$RejectMatchInviteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$RejectMatchInviteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$RejectMatchInviteInput<Input$RejectMatchInviteInput>
      get copyWith => CopyWith$Input$RejectMatchInviteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RejectMatchInviteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    return Object.hashAll(
        [_$data.containsKey('match_id') ? l$match_id : const {}]);
  }
}

abstract class CopyWith$Input$RejectMatchInviteInput<TRes> {
  factory CopyWith$Input$RejectMatchInviteInput(
    Input$RejectMatchInviteInput instance,
    TRes Function(Input$RejectMatchInviteInput) then,
  ) = _CopyWithImpl$Input$RejectMatchInviteInput;

  factory CopyWith$Input$RejectMatchInviteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RejectMatchInviteInput;

  TRes call({String? match_id});
}

class _CopyWithImpl$Input$RejectMatchInviteInput<TRes>
    implements CopyWith$Input$RejectMatchInviteInput<TRes> {
  _CopyWithImpl$Input$RejectMatchInviteInput(
    this._instance,
    this._then,
  );

  final Input$RejectMatchInviteInput _instance;

  final TRes Function(Input$RejectMatchInviteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_id = _undefined}) =>
      _then(Input$RejectMatchInviteInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$RejectMatchInviteInput<TRes>
    implements CopyWith$Input$RejectMatchInviteInput<TRes> {
  _CopyWithStubImpl$Input$RejectMatchInviteInput(this._res);

  TRes _res;

  call({String? match_id}) => _res;
}

class Input$WeekDetailsInput {
  factory Input$WeekDetailsInput({
    String? video_title,
    String? thumbnail_image,
    String? file_path,
    String? video_link,
    int? video_type,
    int? order,
  }) =>
      Input$WeekDetailsInput._({
        if (video_title != null) r'video_title': video_title,
        if (thumbnail_image != null) r'thumbnail_image': thumbnail_image,
        if (file_path != null) r'file_path': file_path,
        if (video_link != null) r'video_link': video_link,
        if (video_type != null) r'video_type': video_type,
        if (order != null) r'order': order,
      });

  Input$WeekDetailsInput._(this._$data);

  factory Input$WeekDetailsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('video_title')) {
      final l$video_title = data['video_title'];
      result$data['video_title'] = (l$video_title as String?);
    }
    if (data.containsKey('thumbnail_image')) {
      final l$thumbnail_image = data['thumbnail_image'];
      result$data['thumbnail_image'] = (l$thumbnail_image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('video_link')) {
      final l$video_link = data['video_link'];
      result$data['video_link'] = (l$video_link as String?);
    }
    if (data.containsKey('video_type')) {
      final l$video_type = data['video_type'];
      result$data['video_type'] = (l$video_type as int?);
    }
    if (data.containsKey('order')) {
      final l$order = data['order'];
      result$data['order'] = (l$order as int?);
    }
    return Input$WeekDetailsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get video_title => (_$data['video_title'] as String?);

  String? get thumbnail_image => (_$data['thumbnail_image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get video_link => (_$data['video_link'] as String?);

  int? get video_type => (_$data['video_type'] as int?);

  int? get order => (_$data['order'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('video_title')) {
      final l$video_title = video_title;
      result$data['video_title'] = l$video_title;
    }
    if (_$data.containsKey('thumbnail_image')) {
      final l$thumbnail_image = thumbnail_image;
      result$data['thumbnail_image'] = l$thumbnail_image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('video_link')) {
      final l$video_link = video_link;
      result$data['video_link'] = l$video_link;
    }
    if (_$data.containsKey('video_type')) {
      final l$video_type = video_type;
      result$data['video_type'] = l$video_type;
    }
    if (_$data.containsKey('order')) {
      final l$order = order;
      result$data['order'] = l$order;
    }
    return result$data;
  }

  CopyWith$Input$WeekDetailsInput<Input$WeekDetailsInput> get copyWith =>
      CopyWith$Input$WeekDetailsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WeekDetailsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$video_title = video_title;
    final lOther$video_title = other.video_title;
    if (_$data.containsKey('video_title') !=
        other._$data.containsKey('video_title')) {
      return false;
    }
    if (l$video_title != lOther$video_title) {
      return false;
    }
    final l$thumbnail_image = thumbnail_image;
    final lOther$thumbnail_image = other.thumbnail_image;
    if (_$data.containsKey('thumbnail_image') !=
        other._$data.containsKey('thumbnail_image')) {
      return false;
    }
    if (l$thumbnail_image != lOther$thumbnail_image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$video_link = video_link;
    final lOther$video_link = other.video_link;
    if (_$data.containsKey('video_link') !=
        other._$data.containsKey('video_link')) {
      return false;
    }
    if (l$video_link != lOther$video_link) {
      return false;
    }
    final l$video_type = video_type;
    final lOther$video_type = other.video_type;
    if (_$data.containsKey('video_type') !=
        other._$data.containsKey('video_type')) {
      return false;
    }
    if (l$video_type != lOther$video_type) {
      return false;
    }
    final l$order = order;
    final lOther$order = other.order;
    if (_$data.containsKey('order') != other._$data.containsKey('order')) {
      return false;
    }
    if (l$order != lOther$order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$video_title = video_title;
    final l$thumbnail_image = thumbnail_image;
    final l$file_path = file_path;
    final l$video_link = video_link;
    final l$video_type = video_type;
    final l$order = order;
    return Object.hashAll([
      _$data.containsKey('video_title') ? l$video_title : const {},
      _$data.containsKey('thumbnail_image') ? l$thumbnail_image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('video_link') ? l$video_link : const {},
      _$data.containsKey('video_type') ? l$video_type : const {},
      _$data.containsKey('order') ? l$order : const {},
    ]);
  }
}

abstract class CopyWith$Input$WeekDetailsInput<TRes> {
  factory CopyWith$Input$WeekDetailsInput(
    Input$WeekDetailsInput instance,
    TRes Function(Input$WeekDetailsInput) then,
  ) = _CopyWithImpl$Input$WeekDetailsInput;

  factory CopyWith$Input$WeekDetailsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WeekDetailsInput;

  TRes call({
    String? video_title,
    String? thumbnail_image,
    String? file_path,
    String? video_link,
    int? video_type,
    int? order,
  });
}

class _CopyWithImpl$Input$WeekDetailsInput<TRes>
    implements CopyWith$Input$WeekDetailsInput<TRes> {
  _CopyWithImpl$Input$WeekDetailsInput(
    this._instance,
    this._then,
  );

  final Input$WeekDetailsInput _instance;

  final TRes Function(Input$WeekDetailsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? video_title = _undefined,
    Object? thumbnail_image = _undefined,
    Object? file_path = _undefined,
    Object? video_link = _undefined,
    Object? video_type = _undefined,
    Object? order = _undefined,
  }) =>
      _then(Input$WeekDetailsInput._({
        ..._instance._$data,
        if (video_title != _undefined) 'video_title': (video_title as String?),
        if (thumbnail_image != _undefined)
          'thumbnail_image': (thumbnail_image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (video_link != _undefined) 'video_link': (video_link as String?),
        if (video_type != _undefined) 'video_type': (video_type as int?),
        if (order != _undefined) 'order': (order as int?),
      }));
}

class _CopyWithStubImpl$Input$WeekDetailsInput<TRes>
    implements CopyWith$Input$WeekDetailsInput<TRes> {
  _CopyWithStubImpl$Input$WeekDetailsInput(this._res);

  TRes _res;

  call({
    String? video_title,
    String? thumbnail_image,
    String? file_path,
    String? video_link,
    int? video_type,
    int? order,
  }) =>
      _res;
}

class Input$WeekDetailPaginationInput {
  factory Input$WeekDetailPaginationInput({
    required int offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$WeekDetailPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$WeekDetailPaginationInput._(this._$data);

  factory Input$WeekDetailPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$WeekDetailPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$WeekDetailPaginationInput<Input$WeekDetailPaginationInput>
      get copyWith => CopyWith$Input$WeekDetailPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WeekDetailPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$WeekDetailPaginationInput<TRes> {
  factory CopyWith$Input$WeekDetailPaginationInput(
    Input$WeekDetailPaginationInput instance,
    TRes Function(Input$WeekDetailPaginationInput) then,
  ) = _CopyWithImpl$Input$WeekDetailPaginationInput;

  factory CopyWith$Input$WeekDetailPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WeekDetailPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$WeekDetailPaginationInput<TRes>
    implements CopyWith$Input$WeekDetailPaginationInput<TRes> {
  _CopyWithImpl$Input$WeekDetailPaginationInput(
    this._instance,
    this._then,
  );

  final Input$WeekDetailPaginationInput _instance;

  final TRes Function(Input$WeekDetailPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$WeekDetailPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$WeekDetailPaginationInput<TRes>
    implements CopyWith$Input$WeekDetailPaginationInput<TRes> {
  _CopyWithStubImpl$Input$WeekDetailPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$WeekDetailViewInput {
  factory Input$WeekDetailViewInput({required String uuid}) =>
      Input$WeekDetailViewInput._({
        r'uuid': uuid,
      });

  Input$WeekDetailViewInput._(this._$data);

  factory Input$WeekDetailViewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$WeekDetailViewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$WeekDetailViewInput<Input$WeekDetailViewInput> get copyWith =>
      CopyWith$Input$WeekDetailViewInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WeekDetailViewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$WeekDetailViewInput<TRes> {
  factory CopyWith$Input$WeekDetailViewInput(
    Input$WeekDetailViewInput instance,
    TRes Function(Input$WeekDetailViewInput) then,
  ) = _CopyWithImpl$Input$WeekDetailViewInput;

  factory CopyWith$Input$WeekDetailViewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WeekDetailViewInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$WeekDetailViewInput<TRes>
    implements CopyWith$Input$WeekDetailViewInput<TRes> {
  _CopyWithImpl$Input$WeekDetailViewInput(
    this._instance,
    this._then,
  );

  final Input$WeekDetailViewInput _instance;

  final TRes Function(Input$WeekDetailViewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$WeekDetailViewInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$WeekDetailViewInput<TRes>
    implements CopyWith$Input$WeekDetailViewInput<TRes> {
  _CopyWithStubImpl$Input$WeekDetailViewInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$DeleteWeekDataInput {
  factory Input$DeleteWeekDataInput({required String uuid}) =>
      Input$DeleteWeekDataInput._({
        r'uuid': uuid,
      });

  Input$DeleteWeekDataInput._(this._$data);

  factory Input$DeleteWeekDataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$DeleteWeekDataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$DeleteWeekDataInput<Input$DeleteWeekDataInput> get copyWith =>
      CopyWith$Input$DeleteWeekDataInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteWeekDataInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$DeleteWeekDataInput<TRes> {
  factory CopyWith$Input$DeleteWeekDataInput(
    Input$DeleteWeekDataInput instance,
    TRes Function(Input$DeleteWeekDataInput) then,
  ) = _CopyWithImpl$Input$DeleteWeekDataInput;

  factory CopyWith$Input$DeleteWeekDataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteWeekDataInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$DeleteWeekDataInput<TRes>
    implements CopyWith$Input$DeleteWeekDataInput<TRes> {
  _CopyWithImpl$Input$DeleteWeekDataInput(
    this._instance,
    this._then,
  );

  final Input$DeleteWeekDataInput _instance;

  final TRes Function(Input$DeleteWeekDataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$DeleteWeekDataInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteWeekDataInput<TRes>
    implements CopyWith$Input$DeleteWeekDataInput<TRes> {
  _CopyWithStubImpl$Input$DeleteWeekDataInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$WeekDataInput {
  factory Input$WeekDataInput({
    required String uuid,
    String? video_title,
    String? file_path,
    String? thumbnail_image,
    int? video_type,
    String? video_link,
    int? order,
  }) =>
      Input$WeekDataInput._({
        r'uuid': uuid,
        if (video_title != null) r'video_title': video_title,
        if (file_path != null) r'file_path': file_path,
        if (thumbnail_image != null) r'thumbnail_image': thumbnail_image,
        if (video_type != null) r'video_type': video_type,
        if (video_link != null) r'video_link': video_link,
        if (order != null) r'order': order,
      });

  Input$WeekDataInput._(this._$data);

  factory Input$WeekDataInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('video_title')) {
      final l$video_title = data['video_title'];
      result$data['video_title'] = (l$video_title as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('thumbnail_image')) {
      final l$thumbnail_image = data['thumbnail_image'];
      result$data['thumbnail_image'] = (l$thumbnail_image as String?);
    }
    if (data.containsKey('video_type')) {
      final l$video_type = data['video_type'];
      result$data['video_type'] = (l$video_type as int?);
    }
    if (data.containsKey('video_link')) {
      final l$video_link = data['video_link'];
      result$data['video_link'] = (l$video_link as String?);
    }
    if (data.containsKey('order')) {
      final l$order = data['order'];
      result$data['order'] = (l$order as int?);
    }
    return Input$WeekDataInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get video_title => (_$data['video_title'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get thumbnail_image => (_$data['thumbnail_image'] as String?);

  int? get video_type => (_$data['video_type'] as int?);

  String? get video_link => (_$data['video_link'] as String?);

  int? get order => (_$data['order'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('video_title')) {
      final l$video_title = video_title;
      result$data['video_title'] = l$video_title;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('thumbnail_image')) {
      final l$thumbnail_image = thumbnail_image;
      result$data['thumbnail_image'] = l$thumbnail_image;
    }
    if (_$data.containsKey('video_type')) {
      final l$video_type = video_type;
      result$data['video_type'] = l$video_type;
    }
    if (_$data.containsKey('video_link')) {
      final l$video_link = video_link;
      result$data['video_link'] = l$video_link;
    }
    if (_$data.containsKey('order')) {
      final l$order = order;
      result$data['order'] = l$order;
    }
    return result$data;
  }

  CopyWith$Input$WeekDataInput<Input$WeekDataInput> get copyWith =>
      CopyWith$Input$WeekDataInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WeekDataInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$video_title = video_title;
    final lOther$video_title = other.video_title;
    if (_$data.containsKey('video_title') !=
        other._$data.containsKey('video_title')) {
      return false;
    }
    if (l$video_title != lOther$video_title) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$thumbnail_image = thumbnail_image;
    final lOther$thumbnail_image = other.thumbnail_image;
    if (_$data.containsKey('thumbnail_image') !=
        other._$data.containsKey('thumbnail_image')) {
      return false;
    }
    if (l$thumbnail_image != lOther$thumbnail_image) {
      return false;
    }
    final l$video_type = video_type;
    final lOther$video_type = other.video_type;
    if (_$data.containsKey('video_type') !=
        other._$data.containsKey('video_type')) {
      return false;
    }
    if (l$video_type != lOther$video_type) {
      return false;
    }
    final l$video_link = video_link;
    final lOther$video_link = other.video_link;
    if (_$data.containsKey('video_link') !=
        other._$data.containsKey('video_link')) {
      return false;
    }
    if (l$video_link != lOther$video_link) {
      return false;
    }
    final l$order = order;
    final lOther$order = other.order;
    if (_$data.containsKey('order') != other._$data.containsKey('order')) {
      return false;
    }
    if (l$order != lOther$order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$video_title = video_title;
    final l$file_path = file_path;
    final l$thumbnail_image = thumbnail_image;
    final l$video_type = video_type;
    final l$video_link = video_link;
    final l$order = order;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('video_title') ? l$video_title : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('thumbnail_image') ? l$thumbnail_image : const {},
      _$data.containsKey('video_type') ? l$video_type : const {},
      _$data.containsKey('video_link') ? l$video_link : const {},
      _$data.containsKey('order') ? l$order : const {},
    ]);
  }
}

abstract class CopyWith$Input$WeekDataInput<TRes> {
  factory CopyWith$Input$WeekDataInput(
    Input$WeekDataInput instance,
    TRes Function(Input$WeekDataInput) then,
  ) = _CopyWithImpl$Input$WeekDataInput;

  factory CopyWith$Input$WeekDataInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WeekDataInput;

  TRes call({
    String? uuid,
    String? video_title,
    String? file_path,
    String? thumbnail_image,
    int? video_type,
    String? video_link,
    int? order,
  });
}

class _CopyWithImpl$Input$WeekDataInput<TRes>
    implements CopyWith$Input$WeekDataInput<TRes> {
  _CopyWithImpl$Input$WeekDataInput(
    this._instance,
    this._then,
  );

  final Input$WeekDataInput _instance;

  final TRes Function(Input$WeekDataInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? video_title = _undefined,
    Object? file_path = _undefined,
    Object? thumbnail_image = _undefined,
    Object? video_type = _undefined,
    Object? video_link = _undefined,
    Object? order = _undefined,
  }) =>
      _then(Input$WeekDataInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (video_title != _undefined) 'video_title': (video_title as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (thumbnail_image != _undefined)
          'thumbnail_image': (thumbnail_image as String?),
        if (video_type != _undefined) 'video_type': (video_type as int?),
        if (video_link != _undefined) 'video_link': (video_link as String?),
        if (order != _undefined) 'order': (order as int?),
      }));
}

class _CopyWithStubImpl$Input$WeekDataInput<TRes>
    implements CopyWith$Input$WeekDataInput<TRes> {
  _CopyWithStubImpl$Input$WeekDataInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? video_title,
    String? file_path,
    String? thumbnail_image,
    int? video_type,
    String? video_link,
    int? order,
  }) =>
      _res;
}

class Input$SocialSignUpInput {
  factory Input$SocialSignUpInput({
    required String version,
    required String platform,
    String? first_name,
    String? last_name,
    String? email,
    required String provider_type,
    required String provider_key,
    String? mobile,
    String? profile,
    String? device_token,
    String? device_info,
  }) =>
      Input$SocialSignUpInput._({
        r'version': version,
        r'platform': platform,
        if (first_name != null) r'first_name': first_name,
        if (last_name != null) r'last_name': last_name,
        if (email != null) r'email': email,
        r'provider_type': provider_type,
        r'provider_key': provider_key,
        if (mobile != null) r'mobile': mobile,
        if (profile != null) r'profile': profile,
        if (device_token != null) r'device_token': device_token,
        if (device_info != null) r'device_info': device_info,
      });

  Input$SocialSignUpInput._(this._$data);

  factory Input$SocialSignUpInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$version = data['version'];
    result$data['version'] = (l$version as String);
    final l$platform = data['platform'];
    result$data['platform'] = (l$platform as String);
    if (data.containsKey('first_name')) {
      final l$first_name = data['first_name'];
      result$data['first_name'] = (l$first_name as String?);
    }
    if (data.containsKey('last_name')) {
      final l$last_name = data['last_name'];
      result$data['last_name'] = (l$last_name as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$provider_type = data['provider_type'];
    result$data['provider_type'] = (l$provider_type as String);
    final l$provider_key = data['provider_key'];
    result$data['provider_key'] = (l$provider_key as String);
    if (data.containsKey('mobile')) {
      final l$mobile = data['mobile'];
      result$data['mobile'] = (l$mobile as String?);
    }
    if (data.containsKey('profile')) {
      final l$profile = data['profile'];
      result$data['profile'] = (l$profile as String?);
    }
    if (data.containsKey('device_token')) {
      final l$device_token = data['device_token'];
      result$data['device_token'] = (l$device_token as String?);
    }
    if (data.containsKey('device_info')) {
      final l$device_info = data['device_info'];
      result$data['device_info'] = (l$device_info as String?);
    }
    return Input$SocialSignUpInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get version => (_$data['version'] as String);

  String get platform => (_$data['platform'] as String);

  String? get first_name => (_$data['first_name'] as String?);

  String? get last_name => (_$data['last_name'] as String?);

  String? get email => (_$data['email'] as String?);

  String get provider_type => (_$data['provider_type'] as String);

  String get provider_key => (_$data['provider_key'] as String);

  String? get mobile => (_$data['mobile'] as String?);

  String? get profile => (_$data['profile'] as String?);

  String? get device_token => (_$data['device_token'] as String?);

  String? get device_info => (_$data['device_info'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$version = version;
    result$data['version'] = l$version;
    final l$platform = platform;
    result$data['platform'] = l$platform;
    if (_$data.containsKey('first_name')) {
      final l$first_name = first_name;
      result$data['first_name'] = l$first_name;
    }
    if (_$data.containsKey('last_name')) {
      final l$last_name = last_name;
      result$data['last_name'] = l$last_name;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$provider_type = provider_type;
    result$data['provider_type'] = l$provider_type;
    final l$provider_key = provider_key;
    result$data['provider_key'] = l$provider_key;
    if (_$data.containsKey('mobile')) {
      final l$mobile = mobile;
      result$data['mobile'] = l$mobile;
    }
    if (_$data.containsKey('profile')) {
      final l$profile = profile;
      result$data['profile'] = l$profile;
    }
    if (_$data.containsKey('device_token')) {
      final l$device_token = device_token;
      result$data['device_token'] = l$device_token;
    }
    if (_$data.containsKey('device_info')) {
      final l$device_info = device_info;
      result$data['device_info'] = l$device_info;
    }
    return result$data;
  }

  CopyWith$Input$SocialSignUpInput<Input$SocialSignUpInput> get copyWith =>
      CopyWith$Input$SocialSignUpInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SocialSignUpInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (_$data.containsKey('first_name') !=
        other._$data.containsKey('first_name')) {
      return false;
    }
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (_$data.containsKey('last_name') !=
        other._$data.containsKey('last_name')) {
      return false;
    }
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$provider_type = provider_type;
    final lOther$provider_type = other.provider_type;
    if (l$provider_type != lOther$provider_type) {
      return false;
    }
    final l$provider_key = provider_key;
    final lOther$provider_key = other.provider_key;
    if (l$provider_key != lOther$provider_key) {
      return false;
    }
    final l$mobile = mobile;
    final lOther$mobile = other.mobile;
    if (_$data.containsKey('mobile') != other._$data.containsKey('mobile')) {
      return false;
    }
    if (l$mobile != lOther$mobile) {
      return false;
    }
    final l$profile = profile;
    final lOther$profile = other.profile;
    if (_$data.containsKey('profile') != other._$data.containsKey('profile')) {
      return false;
    }
    if (l$profile != lOther$profile) {
      return false;
    }
    final l$device_token = device_token;
    final lOther$device_token = other.device_token;
    if (_$data.containsKey('device_token') !=
        other._$data.containsKey('device_token')) {
      return false;
    }
    if (l$device_token != lOther$device_token) {
      return false;
    }
    final l$device_info = device_info;
    final lOther$device_info = other.device_info;
    if (_$data.containsKey('device_info') !=
        other._$data.containsKey('device_info')) {
      return false;
    }
    if (l$device_info != lOther$device_info) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$email = email;
    final l$provider_type = provider_type;
    final l$provider_key = provider_key;
    final l$mobile = mobile;
    final l$profile = profile;
    final l$device_token = device_token;
    final l$device_info = device_info;
    return Object.hashAll([
      l$version,
      l$platform,
      _$data.containsKey('first_name') ? l$first_name : const {},
      _$data.containsKey('last_name') ? l$last_name : const {},
      _$data.containsKey('email') ? l$email : const {},
      l$provider_type,
      l$provider_key,
      _$data.containsKey('mobile') ? l$mobile : const {},
      _$data.containsKey('profile') ? l$profile : const {},
      _$data.containsKey('device_token') ? l$device_token : const {},
      _$data.containsKey('device_info') ? l$device_info : const {},
    ]);
  }
}

abstract class CopyWith$Input$SocialSignUpInput<TRes> {
  factory CopyWith$Input$SocialSignUpInput(
    Input$SocialSignUpInput instance,
    TRes Function(Input$SocialSignUpInput) then,
  ) = _CopyWithImpl$Input$SocialSignUpInput;

  factory CopyWith$Input$SocialSignUpInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SocialSignUpInput;

  TRes call({
    String? version,
    String? platform,
    String? first_name,
    String? last_name,
    String? email,
    String? provider_type,
    String? provider_key,
    String? mobile,
    String? profile,
    String? device_token,
    String? device_info,
  });
}

class _CopyWithImpl$Input$SocialSignUpInput<TRes>
    implements CopyWith$Input$SocialSignUpInput<TRes> {
  _CopyWithImpl$Input$SocialSignUpInput(
    this._instance,
    this._then,
  );

  final Input$SocialSignUpInput _instance;

  final TRes Function(Input$SocialSignUpInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? email = _undefined,
    Object? provider_type = _undefined,
    Object? provider_key = _undefined,
    Object? mobile = _undefined,
    Object? profile = _undefined,
    Object? device_token = _undefined,
    Object? device_info = _undefined,
  }) =>
      _then(Input$SocialSignUpInput._({
        ..._instance._$data,
        if (version != _undefined && version != null)
          'version': (version as String),
        if (platform != _undefined && platform != null)
          'platform': (platform as String),
        if (first_name != _undefined) 'first_name': (first_name as String?),
        if (last_name != _undefined) 'last_name': (last_name as String?),
        if (email != _undefined) 'email': (email as String?),
        if (provider_type != _undefined && provider_type != null)
          'provider_type': (provider_type as String),
        if (provider_key != _undefined && provider_key != null)
          'provider_key': (provider_key as String),
        if (mobile != _undefined) 'mobile': (mobile as String?),
        if (profile != _undefined) 'profile': (profile as String?),
        if (device_token != _undefined)
          'device_token': (device_token as String?),
        if (device_info != _undefined) 'device_info': (device_info as String?),
      }));
}

class _CopyWithStubImpl$Input$SocialSignUpInput<TRes>
    implements CopyWith$Input$SocialSignUpInput<TRes> {
  _CopyWithStubImpl$Input$SocialSignUpInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? first_name,
    String? last_name,
    String? email,
    String? provider_type,
    String? provider_key,
    String? mobile,
    String? profile,
    String? device_token,
    String? device_info,
  }) =>
      _res;
}

class Input$DashboardFitterInput {
  factory Input$DashboardFitterInput({
    String? fitter,
    String? start_date,
    String? end_date,
  }) =>
      Input$DashboardFitterInput._({
        if (fitter != null) r'fitter': fitter,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
      });

  Input$DashboardFitterInput._(this._$data);

  factory Input$DashboardFitterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('fitter')) {
      final l$fitter = data['fitter'];
      result$data['fitter'] = (l$fitter as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    return Input$DashboardFitterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get fitter => (_$data['fitter'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('fitter')) {
      final l$fitter = fitter;
      result$data['fitter'] = l$fitter;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    return result$data;
  }

  CopyWith$Input$DashboardFitterInput<Input$DashboardFitterInput>
      get copyWith => CopyWith$Input$DashboardFitterInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DashboardFitterInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$fitter = fitter;
    final lOther$fitter = other.fitter;
    if (_$data.containsKey('fitter') != other._$data.containsKey('fitter')) {
      return false;
    }
    if (l$fitter != lOther$fitter) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$fitter = fitter;
    final l$start_date = start_date;
    final l$end_date = end_date;
    return Object.hashAll([
      _$data.containsKey('fitter') ? l$fitter : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
    ]);
  }
}

abstract class CopyWith$Input$DashboardFitterInput<TRes> {
  factory CopyWith$Input$DashboardFitterInput(
    Input$DashboardFitterInput instance,
    TRes Function(Input$DashboardFitterInput) then,
  ) = _CopyWithImpl$Input$DashboardFitterInput;

  factory CopyWith$Input$DashboardFitterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DashboardFitterInput;

  TRes call({
    String? fitter,
    String? start_date,
    String? end_date,
  });
}

class _CopyWithImpl$Input$DashboardFitterInput<TRes>
    implements CopyWith$Input$DashboardFitterInput<TRes> {
  _CopyWithImpl$Input$DashboardFitterInput(
    this._instance,
    this._then,
  );

  final Input$DashboardFitterInput _instance;

  final TRes Function(Input$DashboardFitterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? fitter = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
  }) =>
      _then(Input$DashboardFitterInput._({
        ..._instance._$data,
        if (fitter != _undefined) 'fitter': (fitter as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
      }));
}

class _CopyWithStubImpl$Input$DashboardFitterInput<TRes>
    implements CopyWith$Input$DashboardFitterInput<TRes> {
  _CopyWithStubImpl$Input$DashboardFitterInput(this._res);

  TRes _res;

  call({
    String? fitter,
    String? start_date,
    String? end_date,
  }) =>
      _res;
}

class Input$ScheduleMatchListFrontPaginationInput {
  factory Input$ScheduleMatchListFrontPaginationInput({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      Input$ScheduleMatchListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schedual_type != null) r'schedual_type': schedual_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
      });

  Input$ScheduleMatchListFrontPaginationInput._(this._$data);

  factory Input$ScheduleMatchListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schedual_type')) {
      final l$schedual_type = data['schedual_type'];
      result$data['schedual_type'] = (l$schedual_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    return Input$ScheduleMatchListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schedual_type => (_$data['schedual_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schedual_type')) {
      final l$schedual_type = schedual_type;
      result$data['schedual_type'] = l$schedual_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    return result$data;
  }

  CopyWith$Input$ScheduleMatchListFrontPaginationInput<
          Input$ScheduleMatchListFrontPaginationInput>
      get copyWith => CopyWith$Input$ScheduleMatchListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ScheduleMatchListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schedual_type = schedual_type;
    final lOther$schedual_type = other.schedual_type;
    if (_$data.containsKey('schedual_type') !=
        other._$data.containsKey('schedual_type')) {
      return false;
    }
    if (l$schedual_type != lOther$schedual_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schedual_type = schedual_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$schdeuled_type = schdeuled_type;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schedual_type') ? l$schedual_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ScheduleMatchListFrontPaginationInput<TRes> {
  factory CopyWith$Input$ScheduleMatchListFrontPaginationInput(
    Input$ScheduleMatchListFrontPaginationInput instance,
    TRes Function(Input$ScheduleMatchListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$ScheduleMatchListFrontPaginationInput;

  factory CopyWith$Input$ScheduleMatchListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ScheduleMatchListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
  });
}

class _CopyWithImpl$Input$ScheduleMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$ScheduleMatchListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$ScheduleMatchListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$ScheduleMatchListFrontPaginationInput _instance;

  final TRes Function(Input$ScheduleMatchListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schedual_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? schdeuled_type = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
  }) =>
      _then(Input$ScheduleMatchListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schedual_type != _undefined)
          'schedual_type': (schedual_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
      }));
}

class _CopyWithStubImpl$Input$ScheduleMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$ScheduleMatchListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$ScheduleMatchListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      _res;
}

class Input$viewScheduleInput {
  factory Input$viewScheduleInput({required String uuid}) =>
      Input$viewScheduleInput._({
        r'uuid': uuid,
      });

  Input$viewScheduleInput._(this._$data);

  factory Input$viewScheduleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewScheduleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewScheduleInput<Input$viewScheduleInput> get copyWith =>
      CopyWith$Input$viewScheduleInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewScheduleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewScheduleInput<TRes> {
  factory CopyWith$Input$viewScheduleInput(
    Input$viewScheduleInput instance,
    TRes Function(Input$viewScheduleInput) then,
  ) = _CopyWithImpl$Input$viewScheduleInput;

  factory CopyWith$Input$viewScheduleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewScheduleInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewScheduleInput<TRes>
    implements CopyWith$Input$viewScheduleInput<TRes> {
  _CopyWithImpl$Input$viewScheduleInput(
    this._instance,
    this._then,
  );

  final Input$viewScheduleInput _instance;

  final TRes Function(Input$viewScheduleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewScheduleInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewScheduleInput<TRes>
    implements CopyWith$Input$viewScheduleInput<TRes> {
  _CopyWithStubImpl$Input$viewScheduleInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ScheduleMatchSetFlagsInput {
  factory Input$ScheduleMatchSetFlagsInput({
    String? match_id,
    int? flag_value,
    String? flag_type,
  }) =>
      Input$ScheduleMatchSetFlagsInput._({
        if (match_id != null) r'match_id': match_id,
        if (flag_value != null) r'flag_value': flag_value,
        if (flag_type != null) r'flag_type': flag_type,
      });

  Input$ScheduleMatchSetFlagsInput._(this._$data);

  factory Input$ScheduleMatchSetFlagsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('flag_value')) {
      final l$flag_value = data['flag_value'];
      result$data['flag_value'] = (l$flag_value as int?);
    }
    if (data.containsKey('flag_type')) {
      final l$flag_type = data['flag_type'];
      result$data['flag_type'] = (l$flag_type as String?);
    }
    return Input$ScheduleMatchSetFlagsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  int? get flag_value => (_$data['flag_value'] as int?);

  String? get flag_type => (_$data['flag_type'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('flag_value')) {
      final l$flag_value = flag_value;
      result$data['flag_value'] = l$flag_value;
    }
    if (_$data.containsKey('flag_type')) {
      final l$flag_type = flag_type;
      result$data['flag_type'] = l$flag_type;
    }
    return result$data;
  }

  CopyWith$Input$ScheduleMatchSetFlagsInput<Input$ScheduleMatchSetFlagsInput>
      get copyWith => CopyWith$Input$ScheduleMatchSetFlagsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ScheduleMatchSetFlagsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$flag_value = flag_value;
    final lOther$flag_value = other.flag_value;
    if (_$data.containsKey('flag_value') !=
        other._$data.containsKey('flag_value')) {
      return false;
    }
    if (l$flag_value != lOther$flag_value) {
      return false;
    }
    final l$flag_type = flag_type;
    final lOther$flag_type = other.flag_type;
    if (_$data.containsKey('flag_type') !=
        other._$data.containsKey('flag_type')) {
      return false;
    }
    if (l$flag_type != lOther$flag_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$flag_value = flag_value;
    final l$flag_type = flag_type;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('flag_value') ? l$flag_value : const {},
      _$data.containsKey('flag_type') ? l$flag_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$ScheduleMatchSetFlagsInput<TRes> {
  factory CopyWith$Input$ScheduleMatchSetFlagsInput(
    Input$ScheduleMatchSetFlagsInput instance,
    TRes Function(Input$ScheduleMatchSetFlagsInput) then,
  ) = _CopyWithImpl$Input$ScheduleMatchSetFlagsInput;

  factory CopyWith$Input$ScheduleMatchSetFlagsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ScheduleMatchSetFlagsInput;

  TRes call({
    String? match_id,
    int? flag_value,
    String? flag_type,
  });
}

class _CopyWithImpl$Input$ScheduleMatchSetFlagsInput<TRes>
    implements CopyWith$Input$ScheduleMatchSetFlagsInput<TRes> {
  _CopyWithImpl$Input$ScheduleMatchSetFlagsInput(
    this._instance,
    this._then,
  );

  final Input$ScheduleMatchSetFlagsInput _instance;

  final TRes Function(Input$ScheduleMatchSetFlagsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? flag_value = _undefined,
    Object? flag_type = _undefined,
  }) =>
      _then(Input$ScheduleMatchSetFlagsInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (flag_value != _undefined) 'flag_value': (flag_value as int?),
        if (flag_type != _undefined) 'flag_type': (flag_type as String?),
      }));
}

class _CopyWithStubImpl$Input$ScheduleMatchSetFlagsInput<TRes>
    implements CopyWith$Input$ScheduleMatchSetFlagsInput<TRes> {
  _CopyWithStubImpl$Input$ScheduleMatchSetFlagsInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? flag_value,
    String? flag_type,
  }) =>
      _res;
}

class Input$MatchLikeInput {
  factory Input$MatchLikeInput({
    String? match_id,
    bool? is_like,
  }) =>
      Input$MatchLikeInput._({
        if (match_id != null) r'match_id': match_id,
        if (is_like != null) r'is_like': is_like,
      });

  Input$MatchLikeInput._(this._$data);

  factory Input$MatchLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as bool?);
    }
    return Input$MatchLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  bool? get is_like => (_$data['is_like'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$MatchLikeInput<Input$MatchLikeInput> get copyWith =>
      CopyWith$Input$MatchLikeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchLikeInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchLikeInput<TRes> {
  factory CopyWith$Input$MatchLikeInput(
    Input$MatchLikeInput instance,
    TRes Function(Input$MatchLikeInput) then,
  ) = _CopyWithImpl$Input$MatchLikeInput;

  factory CopyWith$Input$MatchLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchLikeInput;

  TRes call({
    String? match_id,
    bool? is_like,
  });
}

class _CopyWithImpl$Input$MatchLikeInput<TRes>
    implements CopyWith$Input$MatchLikeInput<TRes> {
  _CopyWithImpl$Input$MatchLikeInput(
    this._instance,
    this._then,
  );

  final Input$MatchLikeInput _instance;

  final TRes Function(Input$MatchLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$MatchLikeInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (is_like != _undefined) 'is_like': (is_like as bool?),
      }));
}

class _CopyWithStubImpl$Input$MatchLikeInput<TRes>
    implements CopyWith$Input$MatchLikeInput<TRes> {
  _CopyWithStubImpl$Input$MatchLikeInput(this._res);

  TRes _res;

  call({
    String? match_id,
    bool? is_like,
  }) =>
      _res;
}

class Input$MatchCancelInput {
  factory Input$MatchCancelInput({
    String? match_id,
    int? cancel_all,
  }) =>
      Input$MatchCancelInput._({
        if (match_id != null) r'match_id': match_id,
        if (cancel_all != null) r'cancel_all': cancel_all,
      });

  Input$MatchCancelInput._(this._$data);

  factory Input$MatchCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('cancel_all')) {
      final l$cancel_all = data['cancel_all'];
      result$data['cancel_all'] = (l$cancel_all as int?);
    }
    return Input$MatchCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  int? get cancel_all => (_$data['cancel_all'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('cancel_all')) {
      final l$cancel_all = cancel_all;
      result$data['cancel_all'] = l$cancel_all;
    }
    return result$data;
  }

  CopyWith$Input$MatchCancelInput<Input$MatchCancelInput> get copyWith =>
      CopyWith$Input$MatchCancelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchCancelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$cancel_all = cancel_all;
    final lOther$cancel_all = other.cancel_all;
    if (_$data.containsKey('cancel_all') !=
        other._$data.containsKey('cancel_all')) {
      return false;
    }
    if (l$cancel_all != lOther$cancel_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$cancel_all = cancel_all;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('cancel_all') ? l$cancel_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$MatchCancelInput<TRes> {
  factory CopyWith$Input$MatchCancelInput(
    Input$MatchCancelInput instance,
    TRes Function(Input$MatchCancelInput) then,
  ) = _CopyWithImpl$Input$MatchCancelInput;

  factory CopyWith$Input$MatchCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchCancelInput;

  TRes call({
    String? match_id,
    int? cancel_all,
  });
}

class _CopyWithImpl$Input$MatchCancelInput<TRes>
    implements CopyWith$Input$MatchCancelInput<TRes> {
  _CopyWithImpl$Input$MatchCancelInput(
    this._instance,
    this._then,
  );

  final Input$MatchCancelInput _instance;

  final TRes Function(Input$MatchCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? cancel_all = _undefined,
  }) =>
      _then(Input$MatchCancelInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (cancel_all != _undefined) 'cancel_all': (cancel_all as int?),
      }));
}

class _CopyWithStubImpl$Input$MatchCancelInput<TRes>
    implements CopyWith$Input$MatchCancelInput<TRes> {
  _CopyWithStubImpl$Input$MatchCancelInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? cancel_all,
  }) =>
      _res;
}

class Input$PastMatchListFrontPaginationInput {
  factory Input$PastMatchListFrontPaginationInput({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
  }) =>
      Input$PastMatchListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (organized_by != null) r'organized_by': organized_by,
        if (matchlevel != null) r'matchlevel': matchlevel,
        if (matchlevel_label != null) r'matchlevel_label': matchlevel_label,
        if (total_players != null) r'total_players': total_players,
        if (is_booked_court != null) r'is_booked_court': is_booked_court,
      });

  Input$PastMatchListFrontPaginationInput._(this._$data);

  factory Input$PastMatchListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('matchlevel')) {
      final l$matchlevel = data['matchlevel'];
      result$data['matchlevel'] = (l$matchlevel as String?);
    }
    if (data.containsKey('matchlevel_label')) {
      final l$matchlevel_label = data['matchlevel_label'];
      result$data['matchlevel_label'] = (l$matchlevel_label as String?);
    }
    if (data.containsKey('total_players')) {
      final l$total_players = data['total_players'];
      result$data['total_players'] = (l$total_players as int?);
    }
    if (data.containsKey('is_booked_court')) {
      final l$is_booked_court = data['is_booked_court'];
      result$data['is_booked_court'] = (l$is_booked_court as int?);
    }
    return Input$PastMatchListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get matchlevel => (_$data['matchlevel'] as String?);

  String? get matchlevel_label => (_$data['matchlevel_label'] as String?);

  int? get total_players => (_$data['total_players'] as int?);

  int? get is_booked_court => (_$data['is_booked_court'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('matchlevel')) {
      final l$matchlevel = matchlevel;
      result$data['matchlevel'] = l$matchlevel;
    }
    if (_$data.containsKey('matchlevel_label')) {
      final l$matchlevel_label = matchlevel_label;
      result$data['matchlevel_label'] = l$matchlevel_label;
    }
    if (_$data.containsKey('total_players')) {
      final l$total_players = total_players;
      result$data['total_players'] = l$total_players;
    }
    if (_$data.containsKey('is_booked_court')) {
      final l$is_booked_court = is_booked_court;
      result$data['is_booked_court'] = l$is_booked_court;
    }
    return result$data;
  }

  CopyWith$Input$PastMatchListFrontPaginationInput<
          Input$PastMatchListFrontPaginationInput>
      get copyWith => CopyWith$Input$PastMatchListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PastMatchListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$matchlevel = matchlevel;
    final lOther$matchlevel = other.matchlevel;
    if (_$data.containsKey('matchlevel') !=
        other._$data.containsKey('matchlevel')) {
      return false;
    }
    if (l$matchlevel != lOther$matchlevel) {
      return false;
    }
    final l$matchlevel_label = matchlevel_label;
    final lOther$matchlevel_label = other.matchlevel_label;
    if (_$data.containsKey('matchlevel_label') !=
        other._$data.containsKey('matchlevel_label')) {
      return false;
    }
    if (l$matchlevel_label != lOther$matchlevel_label) {
      return false;
    }
    final l$total_players = total_players;
    final lOther$total_players = other.total_players;
    if (_$data.containsKey('total_players') !=
        other._$data.containsKey('total_players')) {
      return false;
    }
    if (l$total_players != lOther$total_players) {
      return false;
    }
    final l$is_booked_court = is_booked_court;
    final lOther$is_booked_court = other.is_booked_court;
    if (_$data.containsKey('is_booked_court') !=
        other._$data.containsKey('is_booked_court')) {
      return false;
    }
    if (l$is_booked_court != lOther$is_booked_court) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$organized_by = organized_by;
    final l$matchlevel = matchlevel;
    final l$matchlevel_label = matchlevel_label;
    final l$total_players = total_players;
    final l$is_booked_court = is_booked_court;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('matchlevel') ? l$matchlevel : const {},
      _$data.containsKey('matchlevel_label') ? l$matchlevel_label : const {},
      _$data.containsKey('total_players') ? l$total_players : const {},
      _$data.containsKey('is_booked_court') ? l$is_booked_court : const {},
    ]);
  }
}

abstract class CopyWith$Input$PastMatchListFrontPaginationInput<TRes> {
  factory CopyWith$Input$PastMatchListFrontPaginationInput(
    Input$PastMatchListFrontPaginationInput instance,
    TRes Function(Input$PastMatchListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$PastMatchListFrontPaginationInput;

  factory CopyWith$Input$PastMatchListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PastMatchListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
  });
}

class _CopyWithImpl$Input$PastMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastMatchListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$PastMatchListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$PastMatchListFrontPaginationInput _instance;

  final TRes Function(Input$PastMatchListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? organized_by = _undefined,
    Object? matchlevel = _undefined,
    Object? matchlevel_label = _undefined,
    Object? total_players = _undefined,
    Object? is_booked_court = _undefined,
  }) =>
      _then(Input$PastMatchListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (matchlevel != _undefined) 'matchlevel': (matchlevel as String?),
        if (matchlevel_label != _undefined)
          'matchlevel_label': (matchlevel_label as String?),
        if (total_players != _undefined)
          'total_players': (total_players as int?),
        if (is_booked_court != _undefined)
          'is_booked_court': (is_booked_court as int?),
      }));
}

class _CopyWithStubImpl$Input$PastMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastMatchListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$PastMatchListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
  }) =>
      _res;
}

class Input$ViewPastInput {
  factory Input$ViewPastInput({required String uuid}) => Input$ViewPastInput._({
        r'uuid': uuid,
      });

  Input$ViewPastInput._(this._$data);

  factory Input$ViewPastInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$ViewPastInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$ViewPastInput<Input$ViewPastInput> get copyWith =>
      CopyWith$Input$ViewPastInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ViewPastInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$ViewPastInput<TRes> {
  factory CopyWith$Input$ViewPastInput(
    Input$ViewPastInput instance,
    TRes Function(Input$ViewPastInput) then,
  ) = _CopyWithImpl$Input$ViewPastInput;

  factory CopyWith$Input$ViewPastInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ViewPastInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$ViewPastInput<TRes>
    implements CopyWith$Input$ViewPastInput<TRes> {
  _CopyWithImpl$Input$ViewPastInput(
    this._instance,
    this._then,
  );

  final Input$ViewPastInput _instance;

  final TRes Function(Input$ViewPastInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$ViewPastInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$ViewPastInput<TRes>
    implements CopyWith$Input$ViewPastInput<TRes> {
  _CopyWithStubImpl$Input$ViewPastInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$MatchShareInput {
  factory Input$MatchShareInput({String? match_id}) => Input$MatchShareInput._({
        if (match_id != null) r'match_id': match_id,
      });

  Input$MatchShareInput._(this._$data);

  factory Input$MatchShareInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$MatchShareInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$MatchShareInput<Input$MatchShareInput> get copyWith =>
      CopyWith$Input$MatchShareInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchShareInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    return Object.hashAll(
        [_$data.containsKey('match_id') ? l$match_id : const {}]);
  }
}

abstract class CopyWith$Input$MatchShareInput<TRes> {
  factory CopyWith$Input$MatchShareInput(
    Input$MatchShareInput instance,
    TRes Function(Input$MatchShareInput) then,
  ) = _CopyWithImpl$Input$MatchShareInput;

  factory CopyWith$Input$MatchShareInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchShareInput;

  TRes call({String? match_id});
}

class _CopyWithImpl$Input$MatchShareInput<TRes>
    implements CopyWith$Input$MatchShareInput<TRes> {
  _CopyWithImpl$Input$MatchShareInput(
    this._instance,
    this._then,
  );

  final Input$MatchShareInput _instance;

  final TRes Function(Input$MatchShareInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_id = _undefined}) => _then(Input$MatchShareInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$MatchShareInput<TRes>
    implements CopyWith$Input$MatchShareInput<TRes> {
  _CopyWithStubImpl$Input$MatchShareInput(this._res);

  TRes _res;

  call({String? match_id}) => _res;
}

class Input$NewsListFrontPaginationInput {
  factory Input$NewsListFrontPaginationInput({
    String? title,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$NewsListFrontPaginationInput._({
        if (title != null) r'title': title,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$NewsListFrontPaginationInput._(this._$data);

  factory Input$NewsListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$NewsListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$NewsListFrontPaginationInput<
          Input$NewsListFrontPaginationInput>
      get copyWith => CopyWith$Input$NewsListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$NewsListFrontPaginationInput<TRes> {
  factory CopyWith$Input$NewsListFrontPaginationInput(
    Input$NewsListFrontPaginationInput instance,
    TRes Function(Input$NewsListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$NewsListFrontPaginationInput;

  factory CopyWith$Input$NewsListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsListFrontPaginationInput;

  TRes call({
    String? title,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$NewsListFrontPaginationInput<TRes>
    implements CopyWith$Input$NewsListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$NewsListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$NewsListFrontPaginationInput _instance;

  final TRes Function(Input$NewsListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$NewsListFrontPaginationInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$NewsListFrontPaginationInput<TRes>
    implements CopyWith$Input$NewsListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$NewsListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? title,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$GetNewsDetailInput {
  factory Input$GetNewsDetailInput({String? uuid}) =>
      Input$GetNewsDetailInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$GetNewsDetailInput._(this._$data);

  factory Input$GetNewsDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$GetNewsDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$GetNewsDetailInput<Input$GetNewsDetailInput> get copyWith =>
      CopyWith$Input$GetNewsDetailInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GetNewsDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$GetNewsDetailInput<TRes> {
  factory CopyWith$Input$GetNewsDetailInput(
    Input$GetNewsDetailInput instance,
    TRes Function(Input$GetNewsDetailInput) then,
  ) = _CopyWithImpl$Input$GetNewsDetailInput;

  factory CopyWith$Input$GetNewsDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GetNewsDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$GetNewsDetailInput<TRes>
    implements CopyWith$Input$GetNewsDetailInput<TRes> {
  _CopyWithImpl$Input$GetNewsDetailInput(
    this._instance,
    this._then,
  );

  final Input$GetNewsDetailInput _instance;

  final TRes Function(Input$GetNewsDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$GetNewsDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$GetNewsDetailInput<TRes>
    implements CopyWith$Input$GetNewsDetailInput<TRes> {
  _CopyWithStubImpl$Input$GetNewsDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AddNewsCommentInput {
  factory Input$AddNewsCommentInput({
    String? news_uuid,
    String? comment,
    String? parent_id,
  }) =>
      Input$AddNewsCommentInput._({
        if (news_uuid != null) r'news_uuid': news_uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$AddNewsCommentInput._(this._$data);

  factory Input$AddNewsCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('news_uuid')) {
      final l$news_uuid = data['news_uuid'];
      result$data['news_uuid'] = (l$news_uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$AddNewsCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get news_uuid => (_$data['news_uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('news_uuid')) {
      final l$news_uuid = news_uuid;
      result$data['news_uuid'] = l$news_uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$AddNewsCommentInput<Input$AddNewsCommentInput> get copyWith =>
      CopyWith$Input$AddNewsCommentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddNewsCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$news_uuid = news_uuid;
    final lOther$news_uuid = other.news_uuid;
    if (_$data.containsKey('news_uuid') !=
        other._$data.containsKey('news_uuid')) {
      return false;
    }
    if (l$news_uuid != lOther$news_uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$news_uuid = news_uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('news_uuid') ? l$news_uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddNewsCommentInput<TRes> {
  factory CopyWith$Input$AddNewsCommentInput(
    Input$AddNewsCommentInput instance,
    TRes Function(Input$AddNewsCommentInput) then,
  ) = _CopyWithImpl$Input$AddNewsCommentInput;

  factory CopyWith$Input$AddNewsCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddNewsCommentInput;

  TRes call({
    String? news_uuid,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$AddNewsCommentInput<TRes>
    implements CopyWith$Input$AddNewsCommentInput<TRes> {
  _CopyWithImpl$Input$AddNewsCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddNewsCommentInput _instance;

  final TRes Function(Input$AddNewsCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? news_uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$AddNewsCommentInput._({
        ..._instance._$data,
        if (news_uuid != _undefined) 'news_uuid': (news_uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AddNewsCommentInput<TRes>
    implements CopyWith$Input$AddNewsCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddNewsCommentInput(this._res);

  TRes _res;

  call({
    String? news_uuid,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$NewsCommentsInput {
  factory Input$NewsCommentsInput({String? news_uuid}) =>
      Input$NewsCommentsInput._({
        if (news_uuid != null) r'news_uuid': news_uuid,
      });

  Input$NewsCommentsInput._(this._$data);

  factory Input$NewsCommentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('news_uuid')) {
      final l$news_uuid = data['news_uuid'];
      result$data['news_uuid'] = (l$news_uuid as String?);
    }
    return Input$NewsCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get news_uuid => (_$data['news_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('news_uuid')) {
      final l$news_uuid = news_uuid;
      result$data['news_uuid'] = l$news_uuid;
    }
    return result$data;
  }

  CopyWith$Input$NewsCommentsInput<Input$NewsCommentsInput> get copyWith =>
      CopyWith$Input$NewsCommentsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$news_uuid = news_uuid;
    final lOther$news_uuid = other.news_uuid;
    if (_$data.containsKey('news_uuid') !=
        other._$data.containsKey('news_uuid')) {
      return false;
    }
    if (l$news_uuid != lOther$news_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$news_uuid = news_uuid;
    return Object.hashAll(
        [_$data.containsKey('news_uuid') ? l$news_uuid : const {}]);
  }
}

abstract class CopyWith$Input$NewsCommentsInput<TRes> {
  factory CopyWith$Input$NewsCommentsInput(
    Input$NewsCommentsInput instance,
    TRes Function(Input$NewsCommentsInput) then,
  ) = _CopyWithImpl$Input$NewsCommentsInput;

  factory CopyWith$Input$NewsCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsCommentsInput;

  TRes call({String? news_uuid});
}

class _CopyWithImpl$Input$NewsCommentsInput<TRes>
    implements CopyWith$Input$NewsCommentsInput<TRes> {
  _CopyWithImpl$Input$NewsCommentsInput(
    this._instance,
    this._then,
  );

  final Input$NewsCommentsInput _instance;

  final TRes Function(Input$NewsCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? news_uuid = _undefined}) =>
      _then(Input$NewsCommentsInput._({
        ..._instance._$data,
        if (news_uuid != _undefined) 'news_uuid': (news_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$NewsCommentsInput<TRes>
    implements CopyWith$Input$NewsCommentsInput<TRes> {
  _CopyWithStubImpl$Input$NewsCommentsInput(this._res);

  TRes _res;

  call({String? news_uuid}) => _res;
}

class Input$NewsLikeInput {
  factory Input$NewsLikeInput({
    String? news_uuid,
    int? is_like,
  }) =>
      Input$NewsLikeInput._({
        if (news_uuid != null) r'news_uuid': news_uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$NewsLikeInput._(this._$data);

  factory Input$NewsLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('news_uuid')) {
      final l$news_uuid = data['news_uuid'];
      result$data['news_uuid'] = (l$news_uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as int?);
    }
    return Input$NewsLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get news_uuid => (_$data['news_uuid'] as String?);

  int? get is_like => (_$data['is_like'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('news_uuid')) {
      final l$news_uuid = news_uuid;
      result$data['news_uuid'] = l$news_uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$NewsLikeInput<Input$NewsLikeInput> get copyWith =>
      CopyWith$Input$NewsLikeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsLikeInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$news_uuid = news_uuid;
    final lOther$news_uuid = other.news_uuid;
    if (_$data.containsKey('news_uuid') !=
        other._$data.containsKey('news_uuid')) {
      return false;
    }
    if (l$news_uuid != lOther$news_uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$news_uuid = news_uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('news_uuid') ? l$news_uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$NewsLikeInput<TRes> {
  factory CopyWith$Input$NewsLikeInput(
    Input$NewsLikeInput instance,
    TRes Function(Input$NewsLikeInput) then,
  ) = _CopyWithImpl$Input$NewsLikeInput;

  factory CopyWith$Input$NewsLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsLikeInput;

  TRes call({
    String? news_uuid,
    int? is_like,
  });
}

class _CopyWithImpl$Input$NewsLikeInput<TRes>
    implements CopyWith$Input$NewsLikeInput<TRes> {
  _CopyWithImpl$Input$NewsLikeInput(
    this._instance,
    this._then,
  );

  final Input$NewsLikeInput _instance;

  final TRes Function(Input$NewsLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? news_uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$NewsLikeInput._({
        ..._instance._$data,
        if (news_uuid != _undefined) 'news_uuid': (news_uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as int?),
      }));
}

class _CopyWithStubImpl$Input$NewsLikeInput<TRes>
    implements CopyWith$Input$NewsLikeInput<TRes> {
  _CopyWithStubImpl$Input$NewsLikeInput(this._res);

  TRes _res;

  call({
    String? news_uuid,
    int? is_like,
  }) =>
      _res;
}

class Input$NewsShareInput {
  factory Input$NewsShareInput({String? news_uuid}) => Input$NewsShareInput._({
        if (news_uuid != null) r'news_uuid': news_uuid,
      });

  Input$NewsShareInput._(this._$data);

  factory Input$NewsShareInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('news_uuid')) {
      final l$news_uuid = data['news_uuid'];
      result$data['news_uuid'] = (l$news_uuid as String?);
    }
    return Input$NewsShareInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get news_uuid => (_$data['news_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('news_uuid')) {
      final l$news_uuid = news_uuid;
      result$data['news_uuid'] = l$news_uuid;
    }
    return result$data;
  }

  CopyWith$Input$NewsShareInput<Input$NewsShareInput> get copyWith =>
      CopyWith$Input$NewsShareInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewsShareInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$news_uuid = news_uuid;
    final lOther$news_uuid = other.news_uuid;
    if (_$data.containsKey('news_uuid') !=
        other._$data.containsKey('news_uuid')) {
      return false;
    }
    if (l$news_uuid != lOther$news_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$news_uuid = news_uuid;
    return Object.hashAll(
        [_$data.containsKey('news_uuid') ? l$news_uuid : const {}]);
  }
}

abstract class CopyWith$Input$NewsShareInput<TRes> {
  factory CopyWith$Input$NewsShareInput(
    Input$NewsShareInput instance,
    TRes Function(Input$NewsShareInput) then,
  ) = _CopyWithImpl$Input$NewsShareInput;

  factory CopyWith$Input$NewsShareInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewsShareInput;

  TRes call({String? news_uuid});
}

class _CopyWithImpl$Input$NewsShareInput<TRes>
    implements CopyWith$Input$NewsShareInput<TRes> {
  _CopyWithImpl$Input$NewsShareInput(
    this._instance,
    this._then,
  );

  final Input$NewsShareInput _instance;

  final TRes Function(Input$NewsShareInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? news_uuid = _undefined}) => _then(Input$NewsShareInput._({
        ..._instance._$data,
        if (news_uuid != _undefined) 'news_uuid': (news_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$NewsShareInput<TRes>
    implements CopyWith$Input$NewsShareInput<TRes> {
  _CopyWithStubImpl$Input$NewsShareInput(this._res);

  TRes _res;

  call({String? news_uuid}) => _res;
}

class Input$PlayerOfWeekListPaginationInput {
  factory Input$PlayerOfWeekListPaginationInput({
    String? title,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$PlayerOfWeekListPaginationInput._({
        if (title != null) r'title': title,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$PlayerOfWeekListPaginationInput._(this._$data);

  factory Input$PlayerOfWeekListPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$PlayerOfWeekListPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get title => (_$data['title'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$PlayerOfWeekListPaginationInput<
          Input$PlayerOfWeekListPaginationInput>
      get copyWith => CopyWith$Input$PlayerOfWeekListPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlayerOfWeekListPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('title') ? l$title : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlayerOfWeekListPaginationInput<TRes> {
  factory CopyWith$Input$PlayerOfWeekListPaginationInput(
    Input$PlayerOfWeekListPaginationInput instance,
    TRes Function(Input$PlayerOfWeekListPaginationInput) then,
  ) = _CopyWithImpl$Input$PlayerOfWeekListPaginationInput;

  factory CopyWith$Input$PlayerOfWeekListPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlayerOfWeekListPaginationInput;

  TRes call({
    String? title,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$PlayerOfWeekListPaginationInput<TRes>
    implements CopyWith$Input$PlayerOfWeekListPaginationInput<TRes> {
  _CopyWithImpl$Input$PlayerOfWeekListPaginationInput(
    this._instance,
    this._then,
  );

  final Input$PlayerOfWeekListPaginationInput _instance;

  final TRes Function(Input$PlayerOfWeekListPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$PlayerOfWeekListPaginationInput._({
        ..._instance._$data,
        if (title != _undefined) 'title': (title as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$PlayerOfWeekListPaginationInput<TRes>
    implements CopyWith$Input$PlayerOfWeekListPaginationInput<TRes> {
  _CopyWithStubImpl$Input$PlayerOfWeekListPaginationInput(this._res);

  TRes _res;

  call({
    String? title,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$PlayerOfWeekCommentInput {
  factory Input$PlayerOfWeekCommentInput({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      Input$PlayerOfWeekCommentInput._({
        if (uuid != null) r'uuid': uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$PlayerOfWeekCommentInput._(this._$data);

  factory Input$PlayerOfWeekCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$PlayerOfWeekCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$PlayerOfWeekCommentInput<Input$PlayerOfWeekCommentInput>
      get copyWith => CopyWith$Input$PlayerOfWeekCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlayerOfWeekCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlayerOfWeekCommentInput<TRes> {
  factory CopyWith$Input$PlayerOfWeekCommentInput(
    Input$PlayerOfWeekCommentInput instance,
    TRes Function(Input$PlayerOfWeekCommentInput) then,
  ) = _CopyWithImpl$Input$PlayerOfWeekCommentInput;

  factory CopyWith$Input$PlayerOfWeekCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlayerOfWeekCommentInput;

  TRes call({
    String? uuid,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$PlayerOfWeekCommentInput<TRes>
    implements CopyWith$Input$PlayerOfWeekCommentInput<TRes> {
  _CopyWithImpl$Input$PlayerOfWeekCommentInput(
    this._instance,
    this._then,
  );

  final Input$PlayerOfWeekCommentInput _instance;

  final TRes Function(Input$PlayerOfWeekCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$PlayerOfWeekCommentInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$PlayerOfWeekCommentInput<TRes>
    implements CopyWith$Input$PlayerOfWeekCommentInput<TRes> {
  _CopyWithStubImpl$Input$PlayerOfWeekCommentInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$PlayerOfWeekCommentsInput {
  factory Input$PlayerOfWeekCommentsInput({String? uuid}) =>
      Input$PlayerOfWeekCommentsInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$PlayerOfWeekCommentsInput._(this._$data);

  factory Input$PlayerOfWeekCommentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$PlayerOfWeekCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$PlayerOfWeekCommentsInput<Input$PlayerOfWeekCommentsInput>
      get copyWith => CopyWith$Input$PlayerOfWeekCommentsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlayerOfWeekCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$PlayerOfWeekCommentsInput<TRes> {
  factory CopyWith$Input$PlayerOfWeekCommentsInput(
    Input$PlayerOfWeekCommentsInput instance,
    TRes Function(Input$PlayerOfWeekCommentsInput) then,
  ) = _CopyWithImpl$Input$PlayerOfWeekCommentsInput;

  factory CopyWith$Input$PlayerOfWeekCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlayerOfWeekCommentsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$PlayerOfWeekCommentsInput<TRes>
    implements CopyWith$Input$PlayerOfWeekCommentsInput<TRes> {
  _CopyWithImpl$Input$PlayerOfWeekCommentsInput(
    this._instance,
    this._then,
  );

  final Input$PlayerOfWeekCommentsInput _instance;

  final TRes Function(Input$PlayerOfWeekCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$PlayerOfWeekCommentsInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$PlayerOfWeekCommentsInput<TRes>
    implements CopyWith$Input$PlayerOfWeekCommentsInput<TRes> {
  _CopyWithStubImpl$Input$PlayerOfWeekCommentsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$PlayOfWeekLikeInput {
  factory Input$PlayOfWeekLikeInput({
    String? uuid,
    int? is_like,
  }) =>
      Input$PlayOfWeekLikeInput._({
        if (uuid != null) r'uuid': uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$PlayOfWeekLikeInput._(this._$data);

  factory Input$PlayOfWeekLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as int?);
    }
    return Input$PlayOfWeekLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get is_like => (_$data['is_like'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$PlayOfWeekLikeInput<Input$PlayOfWeekLikeInput> get copyWith =>
      CopyWith$Input$PlayOfWeekLikeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlayOfWeekLikeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$PlayOfWeekLikeInput<TRes> {
  factory CopyWith$Input$PlayOfWeekLikeInput(
    Input$PlayOfWeekLikeInput instance,
    TRes Function(Input$PlayOfWeekLikeInput) then,
  ) = _CopyWithImpl$Input$PlayOfWeekLikeInput;

  factory CopyWith$Input$PlayOfWeekLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlayOfWeekLikeInput;

  TRes call({
    String? uuid,
    int? is_like,
  });
}

class _CopyWithImpl$Input$PlayOfWeekLikeInput<TRes>
    implements CopyWith$Input$PlayOfWeekLikeInput<TRes> {
  _CopyWithImpl$Input$PlayOfWeekLikeInput(
    this._instance,
    this._then,
  );

  final Input$PlayOfWeekLikeInput _instance;

  final TRes Function(Input$PlayOfWeekLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$PlayOfWeekLikeInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as int?),
      }));
}

class _CopyWithStubImpl$Input$PlayOfWeekLikeInput<TRes>
    implements CopyWith$Input$PlayOfWeekLikeInput<TRes> {
  _CopyWithStubImpl$Input$PlayOfWeekLikeInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? is_like,
  }) =>
      _res;
}

class Input$PlayOfWeekShareInput {
  factory Input$PlayOfWeekShareInput({String? uuid}) =>
      Input$PlayOfWeekShareInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$PlayOfWeekShareInput._(this._$data);

  factory Input$PlayOfWeekShareInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$PlayOfWeekShareInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$PlayOfWeekShareInput<Input$PlayOfWeekShareInput>
      get copyWith => CopyWith$Input$PlayOfWeekShareInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PlayOfWeekShareInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$PlayOfWeekShareInput<TRes> {
  factory CopyWith$Input$PlayOfWeekShareInput(
    Input$PlayOfWeekShareInput instance,
    TRes Function(Input$PlayOfWeekShareInput) then,
  ) = _CopyWithImpl$Input$PlayOfWeekShareInput;

  factory CopyWith$Input$PlayOfWeekShareInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PlayOfWeekShareInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$PlayOfWeekShareInput<TRes>
    implements CopyWith$Input$PlayOfWeekShareInput<TRes> {
  _CopyWithImpl$Input$PlayOfWeekShareInput(
    this._instance,
    this._then,
  );

  final Input$PlayOfWeekShareInput _instance;

  final TRes Function(Input$PlayOfWeekShareInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$PlayOfWeekShareInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$PlayOfWeekShareInput<TRes>
    implements CopyWith$Input$PlayOfWeekShareInput<TRes> {
  _CopyWithStubImpl$Input$PlayOfWeekShareInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CongListFrontPaginationInput {
  factory Input$CongListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$CongListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$CongListFrontPaginationInput._(this._$data);

  factory Input$CongListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$CongListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$CongListFrontPaginationInput<
          Input$CongListFrontPaginationInput>
      get copyWith => CopyWith$Input$CongListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CongListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$CongListFrontPaginationInput<TRes> {
  factory CopyWith$Input$CongListFrontPaginationInput(
    Input$CongListFrontPaginationInput instance,
    TRes Function(Input$CongListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$CongListFrontPaginationInput;

  factory CopyWith$Input$CongListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CongListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$CongListFrontPaginationInput<TRes>
    implements CopyWith$Input$CongListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$CongListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$CongListFrontPaginationInput _instance;

  final TRes Function(Input$CongListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$CongListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$CongListFrontPaginationInput<TRes>
    implements CopyWith$Input$CongListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$CongListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddCongratulationCommentInput {
  factory Input$AddCongratulationCommentInput({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      Input$AddCongratulationCommentInput._({
        if (uuid != null) r'uuid': uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$AddCongratulationCommentInput._(this._$data);

  factory Input$AddCongratulationCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$AddCongratulationCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$AddCongratulationCommentInput<
          Input$AddCongratulationCommentInput>
      get copyWith => CopyWith$Input$AddCongratulationCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddCongratulationCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddCongratulationCommentInput<TRes> {
  factory CopyWith$Input$AddCongratulationCommentInput(
    Input$AddCongratulationCommentInput instance,
    TRes Function(Input$AddCongratulationCommentInput) then,
  ) = _CopyWithImpl$Input$AddCongratulationCommentInput;

  factory CopyWith$Input$AddCongratulationCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCongratulationCommentInput;

  TRes call({
    String? uuid,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$AddCongratulationCommentInput<TRes>
    implements CopyWith$Input$AddCongratulationCommentInput<TRes> {
  _CopyWithImpl$Input$AddCongratulationCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddCongratulationCommentInput _instance;

  final TRes Function(Input$AddCongratulationCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$AddCongratulationCommentInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AddCongratulationCommentInput<TRes>
    implements CopyWith$Input$AddCongratulationCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddCongratulationCommentInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$CongraCommentsInput {
  factory Input$CongraCommentsInput({String? uuid}) =>
      Input$CongraCommentsInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$CongraCommentsInput._(this._$data);

  factory Input$CongraCommentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$CongraCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$CongraCommentsInput<Input$CongraCommentsInput> get copyWith =>
      CopyWith$Input$CongraCommentsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CongraCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$CongraCommentsInput<TRes> {
  factory CopyWith$Input$CongraCommentsInput(
    Input$CongraCommentsInput instance,
    TRes Function(Input$CongraCommentsInput) then,
  ) = _CopyWithImpl$Input$CongraCommentsInput;

  factory CopyWith$Input$CongraCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CongraCommentsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$CongraCommentsInput<TRes>
    implements CopyWith$Input$CongraCommentsInput<TRes> {
  _CopyWithImpl$Input$CongraCommentsInput(
    this._instance,
    this._then,
  );

  final Input$CongraCommentsInput _instance;

  final TRes Function(Input$CongraCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$CongraCommentsInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$CongraCommentsInput<TRes>
    implements CopyWith$Input$CongraCommentsInput<TRes> {
  _CopyWithStubImpl$Input$CongraCommentsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CongratulationLikeInput {
  factory Input$CongratulationLikeInput({
    String? uuid,
    int? is_like,
  }) =>
      Input$CongratulationLikeInput._({
        if (uuid != null) r'uuid': uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$CongratulationLikeInput._(this._$data);

  factory Input$CongratulationLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as int?);
    }
    return Input$CongratulationLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get is_like => (_$data['is_like'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$CongratulationLikeInput<Input$CongratulationLikeInput>
      get copyWith => CopyWith$Input$CongratulationLikeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CongratulationLikeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$CongratulationLikeInput<TRes> {
  factory CopyWith$Input$CongratulationLikeInput(
    Input$CongratulationLikeInput instance,
    TRes Function(Input$CongratulationLikeInput) then,
  ) = _CopyWithImpl$Input$CongratulationLikeInput;

  factory CopyWith$Input$CongratulationLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CongratulationLikeInput;

  TRes call({
    String? uuid,
    int? is_like,
  });
}

class _CopyWithImpl$Input$CongratulationLikeInput<TRes>
    implements CopyWith$Input$CongratulationLikeInput<TRes> {
  _CopyWithImpl$Input$CongratulationLikeInput(
    this._instance,
    this._then,
  );

  final Input$CongratulationLikeInput _instance;

  final TRes Function(Input$CongratulationLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$CongratulationLikeInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as int?),
      }));
}

class _CopyWithStubImpl$Input$CongratulationLikeInput<TRes>
    implements CopyWith$Input$CongratulationLikeInput<TRes> {
  _CopyWithStubImpl$Input$CongratulationLikeInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? is_like,
  }) =>
      _res;
}

class Input$CongratulationShareInput {
  factory Input$CongratulationShareInput({String? uuid}) =>
      Input$CongratulationShareInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$CongratulationShareInput._(this._$data);

  factory Input$CongratulationShareInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$CongratulationShareInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$CongratulationShareInput<Input$CongratulationShareInput>
      get copyWith => CopyWith$Input$CongratulationShareInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CongratulationShareInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$CongratulationShareInput<TRes> {
  factory CopyWith$Input$CongratulationShareInput(
    Input$CongratulationShareInput instance,
    TRes Function(Input$CongratulationShareInput) then,
  ) = _CopyWithImpl$Input$CongratulationShareInput;

  factory CopyWith$Input$CongratulationShareInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CongratulationShareInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$CongratulationShareInput<TRes>
    implements CopyWith$Input$CongratulationShareInput<TRes> {
  _CopyWithImpl$Input$CongratulationShareInput(
    this._instance,
    this._then,
  );

  final Input$CongratulationShareInput _instance;

  final TRes Function(Input$CongratulationShareInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$CongratulationShareInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$CongratulationShareInput<TRes>
    implements CopyWith$Input$CongratulationShareInput<TRes> {
  _CopyWithStubImpl$Input$CongratulationShareInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$UpcommingListFrontPaginationInput {
  factory Input$UpcommingListFrontPaginationInput({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$UpcommingListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schedual_type != null) r'schedual_type': schedual_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$UpcommingListFrontPaginationInput._(this._$data);

  factory Input$UpcommingListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schedual_type')) {
      final l$schedual_type = data['schedual_type'];
      result$data['schedual_type'] = (l$schedual_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$UpcommingListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schedual_type => (_$data['schedual_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schedual_type')) {
      final l$schedual_type = schedual_type;
      result$data['schedual_type'] = l$schedual_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$UpcommingListFrontPaginationInput<
          Input$UpcommingListFrontPaginationInput>
      get copyWith => CopyWith$Input$UpcommingListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpcommingListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schedual_type = schedual_type;
    final lOther$schedual_type = other.schedual_type;
    if (_$data.containsKey('schedual_type') !=
        other._$data.containsKey('schedual_type')) {
      return false;
    }
    if (l$schedual_type != lOther$schedual_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schedual_type = schedual_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schedual_type') ? l$schedual_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpcommingListFrontPaginationInput<TRes> {
  factory CopyWith$Input$UpcommingListFrontPaginationInput(
    Input$UpcommingListFrontPaginationInput instance,
    TRes Function(Input$UpcommingListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$UpcommingListFrontPaginationInput;

  factory CopyWith$Input$UpcommingListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpcommingListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$UpcommingListFrontPaginationInput<TRes>
    implements CopyWith$Input$UpcommingListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$UpcommingListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$UpcommingListFrontPaginationInput _instance;

  final TRes Function(Input$UpcommingListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schedual_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$UpcommingListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schedual_type != _undefined)
          'schedual_type': (schedual_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$UpcommingListFrontPaginationInput<TRes>
    implements CopyWith$Input$UpcommingListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$UpcommingListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddUpcommingEventCommentInput {
  factory Input$AddUpcommingEventCommentInput({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      Input$AddUpcommingEventCommentInput._({
        if (uuid != null) r'uuid': uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
      });

  Input$AddUpcommingEventCommentInput._(this._$data);

  factory Input$AddUpcommingEventCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    return Input$AddUpcommingEventCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    return result$data;
  }

  CopyWith$Input$AddUpcommingEventCommentInput<
          Input$AddUpcommingEventCommentInput>
      get copyWith => CopyWith$Input$AddUpcommingEventCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddUpcommingEventCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddUpcommingEventCommentInput<TRes> {
  factory CopyWith$Input$AddUpcommingEventCommentInput(
    Input$AddUpcommingEventCommentInput instance,
    TRes Function(Input$AddUpcommingEventCommentInput) then,
  ) = _CopyWithImpl$Input$AddUpcommingEventCommentInput;

  factory CopyWith$Input$AddUpcommingEventCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddUpcommingEventCommentInput;

  TRes call({
    String? uuid,
    String? comment,
    String? parent_id,
  });
}

class _CopyWithImpl$Input$AddUpcommingEventCommentInput<TRes>
    implements CopyWith$Input$AddUpcommingEventCommentInput<TRes> {
  _CopyWithImpl$Input$AddUpcommingEventCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddUpcommingEventCommentInput _instance;

  final TRes Function(Input$AddUpcommingEventCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
  }) =>
      _then(Input$AddUpcommingEventCommentInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
      }));
}

class _CopyWithStubImpl$Input$AddUpcommingEventCommentInput<TRes>
    implements CopyWith$Input$AddUpcommingEventCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddUpcommingEventCommentInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? comment,
    String? parent_id,
  }) =>
      _res;
}

class Input$UpcommingEnentLikeInput {
  factory Input$UpcommingEnentLikeInput({
    String? uuid,
    int? is_like,
  }) =>
      Input$UpcommingEnentLikeInput._({
        if (uuid != null) r'uuid': uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$UpcommingEnentLikeInput._(this._$data);

  factory Input$UpcommingEnentLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as int?);
    }
    return Input$UpcommingEnentLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get is_like => (_$data['is_like'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$UpcommingEnentLikeInput<Input$UpcommingEnentLikeInput>
      get copyWith => CopyWith$Input$UpcommingEnentLikeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpcommingEnentLikeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpcommingEnentLikeInput<TRes> {
  factory CopyWith$Input$UpcommingEnentLikeInput(
    Input$UpcommingEnentLikeInput instance,
    TRes Function(Input$UpcommingEnentLikeInput) then,
  ) = _CopyWithImpl$Input$UpcommingEnentLikeInput;

  factory CopyWith$Input$UpcommingEnentLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpcommingEnentLikeInput;

  TRes call({
    String? uuid,
    int? is_like,
  });
}

class _CopyWithImpl$Input$UpcommingEnentLikeInput<TRes>
    implements CopyWith$Input$UpcommingEnentLikeInput<TRes> {
  _CopyWithImpl$Input$UpcommingEnentLikeInput(
    this._instance,
    this._then,
  );

  final Input$UpcommingEnentLikeInput _instance;

  final TRes Function(Input$UpcommingEnentLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$UpcommingEnentLikeInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as int?),
      }));
}

class _CopyWithStubImpl$Input$UpcommingEnentLikeInput<TRes>
    implements CopyWith$Input$UpcommingEnentLikeInput<TRes> {
  _CopyWithStubImpl$Input$UpcommingEnentLikeInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? is_like,
  }) =>
      _res;
}

class Input$UpcommingEventCommentsInput {
  factory Input$UpcommingEventCommentsInput({String? uuid}) =>
      Input$UpcommingEventCommentsInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$UpcommingEventCommentsInput._(this._$data);

  factory Input$UpcommingEventCommentsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$UpcommingEventCommentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$UpcommingEventCommentsInput<Input$UpcommingEventCommentsInput>
      get copyWith => CopyWith$Input$UpcommingEventCommentsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpcommingEventCommentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$UpcommingEventCommentsInput<TRes> {
  factory CopyWith$Input$UpcommingEventCommentsInput(
    Input$UpcommingEventCommentsInput instance,
    TRes Function(Input$UpcommingEventCommentsInput) then,
  ) = _CopyWithImpl$Input$UpcommingEventCommentsInput;

  factory CopyWith$Input$UpcommingEventCommentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpcommingEventCommentsInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$UpcommingEventCommentsInput<TRes>
    implements CopyWith$Input$UpcommingEventCommentsInput<TRes> {
  _CopyWithImpl$Input$UpcommingEventCommentsInput(
    this._instance,
    this._then,
  );

  final Input$UpcommingEventCommentsInput _instance;

  final TRes Function(Input$UpcommingEventCommentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$UpcommingEventCommentsInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$UpcommingEventCommentsInput<TRes>
    implements CopyWith$Input$UpcommingEventCommentsInput<TRes> {
  _CopyWithStubImpl$Input$UpcommingEventCommentsInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$UpcommingEventShareInput {
  factory Input$UpcommingEventShareInput({String? uuid}) =>
      Input$UpcommingEventShareInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$UpcommingEventShareInput._(this._$data);

  factory Input$UpcommingEventShareInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$UpcommingEventShareInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$UpcommingEventShareInput<Input$UpcommingEventShareInput>
      get copyWith => CopyWith$Input$UpcommingEventShareInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpcommingEventShareInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$UpcommingEventShareInput<TRes> {
  factory CopyWith$Input$UpcommingEventShareInput(
    Input$UpcommingEventShareInput instance,
    TRes Function(Input$UpcommingEventShareInput) then,
  ) = _CopyWithImpl$Input$UpcommingEventShareInput;

  factory CopyWith$Input$UpcommingEventShareInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpcommingEventShareInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$UpcommingEventShareInput<TRes>
    implements CopyWith$Input$UpcommingEventShareInput<TRes> {
  _CopyWithImpl$Input$UpcommingEventShareInput(
    this._instance,
    this._then,
  );

  final Input$UpcommingEventShareInput _instance;

  final TRes Function(Input$UpcommingEventShareInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$UpcommingEventShareInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$UpcommingEventShareInput<TRes>
    implements CopyWith$Input$UpcommingEventShareInput<TRes> {
  _CopyWithStubImpl$Input$UpcommingEventShareInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$addUserRecommendationInput {
  factory Input$addUserRecommendationInput({
    String? match_uuid,
    String? user_uuid,
    String? recommendation_user_uuid,
    int? is_event,
    String? is_decline,
  }) =>
      Input$addUserRecommendationInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (recommendation_user_uuid != null)
          r'recommendation_user_uuid': recommendation_user_uuid,
        if (is_event != null) r'is_event': is_event,
        if (is_decline != null) r'is_decline': is_decline,
      });

  Input$addUserRecommendationInput._(this._$data);

  factory Input$addUserRecommendationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('recommendation_user_uuid')) {
      final l$recommendation_user_uuid = data['recommendation_user_uuid'];
      result$data['recommendation_user_uuid'] =
          (l$recommendation_user_uuid as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('is_decline')) {
      final l$is_decline = data['is_decline'];
      result$data['is_decline'] = (l$is_decline as String?);
    }
    return Input$addUserRecommendationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get recommendation_user_uuid =>
      (_$data['recommendation_user_uuid'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  String? get is_decline => (_$data['is_decline'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('recommendation_user_uuid')) {
      final l$recommendation_user_uuid = recommendation_user_uuid;
      result$data['recommendation_user_uuid'] = l$recommendation_user_uuid;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('is_decline')) {
      final l$is_decline = is_decline;
      result$data['is_decline'] = l$is_decline;
    }
    return result$data;
  }

  CopyWith$Input$addUserRecommendationInput<Input$addUserRecommendationInput>
      get copyWith => CopyWith$Input$addUserRecommendationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addUserRecommendationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$recommendation_user_uuid = recommendation_user_uuid;
    final lOther$recommendation_user_uuid = other.recommendation_user_uuid;
    if (_$data.containsKey('recommendation_user_uuid') !=
        other._$data.containsKey('recommendation_user_uuid')) {
      return false;
    }
    if (l$recommendation_user_uuid != lOther$recommendation_user_uuid) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$is_decline = is_decline;
    final lOther$is_decline = other.is_decline;
    if (_$data.containsKey('is_decline') !=
        other._$data.containsKey('is_decline')) {
      return false;
    }
    if (l$is_decline != lOther$is_decline) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    final l$recommendation_user_uuid = recommendation_user_uuid;
    final l$is_event = is_event;
    final l$is_decline = is_decline;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('recommendation_user_uuid')
          ? l$recommendation_user_uuid
          : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('is_decline') ? l$is_decline : const {},
    ]);
  }
}

abstract class CopyWith$Input$addUserRecommendationInput<TRes> {
  factory CopyWith$Input$addUserRecommendationInput(
    Input$addUserRecommendationInput instance,
    TRes Function(Input$addUserRecommendationInput) then,
  ) = _CopyWithImpl$Input$addUserRecommendationInput;

  factory CopyWith$Input$addUserRecommendationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$addUserRecommendationInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
    String? recommendation_user_uuid,
    int? is_event,
    String? is_decline,
  });
}

class _CopyWithImpl$Input$addUserRecommendationInput<TRes>
    implements CopyWith$Input$addUserRecommendationInput<TRes> {
  _CopyWithImpl$Input$addUserRecommendationInput(
    this._instance,
    this._then,
  );

  final Input$addUserRecommendationInput _instance;

  final TRes Function(Input$addUserRecommendationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
    Object? recommendation_user_uuid = _undefined,
    Object? is_event = _undefined,
    Object? is_decline = _undefined,
  }) =>
      _then(Input$addUserRecommendationInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (recommendation_user_uuid != _undefined)
          'recommendation_user_uuid': (recommendation_user_uuid as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (is_decline != _undefined) 'is_decline': (is_decline as String?),
      }));
}

class _CopyWithStubImpl$Input$addUserRecommendationInput<TRes>
    implements CopyWith$Input$addUserRecommendationInput<TRes> {
  _CopyWithStubImpl$Input$addUserRecommendationInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
    String? recommendation_user_uuid,
    int? is_event,
    String? is_decline,
  }) =>
      _res;
}

class Input$PastEventListFrontPaginationInput {
  factory Input$PastEventListFrontPaginationInput({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$PastEventListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$PastEventListFrontPaginationInput._(this._$data);

  factory Input$PastEventListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$PastEventListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$PastEventListFrontPaginationInput<
          Input$PastEventListFrontPaginationInput>
      get copyWith => CopyWith$Input$PastEventListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PastEventListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$PastEventListFrontPaginationInput<TRes> {
  factory CopyWith$Input$PastEventListFrontPaginationInput(
    Input$PastEventListFrontPaginationInput instance,
    TRes Function(Input$PastEventListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$PastEventListFrontPaginationInput;

  factory CopyWith$Input$PastEventListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PastEventListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$PastEventListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastEventListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$PastEventListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$PastEventListFrontPaginationInput _instance;

  final TRes Function(Input$PastEventListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$PastEventListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$PastEventListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastEventListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$PastEventListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$ViewPastEventInput {
  factory Input$ViewPastEventInput({required String uuid}) =>
      Input$ViewPastEventInput._({
        r'uuid': uuid,
      });

  Input$ViewPastEventInput._(this._$data);

  factory Input$ViewPastEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$ViewPastEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$ViewPastEventInput<Input$ViewPastEventInput> get copyWith =>
      CopyWith$Input$ViewPastEventInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ViewPastEventInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$ViewPastEventInput<TRes> {
  factory CopyWith$Input$ViewPastEventInput(
    Input$ViewPastEventInput instance,
    TRes Function(Input$ViewPastEventInput) then,
  ) = _CopyWithImpl$Input$ViewPastEventInput;

  factory CopyWith$Input$ViewPastEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ViewPastEventInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$ViewPastEventInput<TRes>
    implements CopyWith$Input$ViewPastEventInput<TRes> {
  _CopyWithImpl$Input$ViewPastEventInput(
    this._instance,
    this._then,
  );

  final Input$ViewPastEventInput _instance;

  final TRes Function(Input$ViewPastEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$ViewPastEventInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$ViewPastEventInput<TRes>
    implements CopyWith$Input$ViewPastEventInput<TRes> {
  _CopyWithStubImpl$Input$ViewPastEventInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$matchInviteSlabInput {
  factory Input$matchInviteSlabInput({
    String? match_uuid,
    String? reachout_time,
    String? time_zone,
  }) =>
      Input$matchInviteSlabInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (reachout_time != null) r'reachout_time': reachout_time,
        if (time_zone != null) r'time_zone': time_zone,
      });

  Input$matchInviteSlabInput._(this._$data);

  factory Input$matchInviteSlabInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('reachout_time')) {
      final l$reachout_time = data['reachout_time'];
      result$data['reachout_time'] = (l$reachout_time as String?);
    }
    if (data.containsKey('time_zone')) {
      final l$time_zone = data['time_zone'];
      result$data['time_zone'] = (l$time_zone as String?);
    }
    return Input$matchInviteSlabInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get reachout_time => (_$data['reachout_time'] as String?);

  String? get time_zone => (_$data['time_zone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('reachout_time')) {
      final l$reachout_time = reachout_time;
      result$data['reachout_time'] = l$reachout_time;
    }
    if (_$data.containsKey('time_zone')) {
      final l$time_zone = time_zone;
      result$data['time_zone'] = l$time_zone;
    }
    return result$data;
  }

  CopyWith$Input$matchInviteSlabInput<Input$matchInviteSlabInput>
      get copyWith => CopyWith$Input$matchInviteSlabInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$matchInviteSlabInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$reachout_time = reachout_time;
    final lOther$reachout_time = other.reachout_time;
    if (_$data.containsKey('reachout_time') !=
        other._$data.containsKey('reachout_time')) {
      return false;
    }
    if (l$reachout_time != lOther$reachout_time) {
      return false;
    }
    final l$time_zone = time_zone;
    final lOther$time_zone = other.time_zone;
    if (_$data.containsKey('time_zone') !=
        other._$data.containsKey('time_zone')) {
      return false;
    }
    if (l$time_zone != lOther$time_zone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$reachout_time = reachout_time;
    final l$time_zone = time_zone;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('reachout_time') ? l$reachout_time : const {},
      _$data.containsKey('time_zone') ? l$time_zone : const {},
    ]);
  }
}

abstract class CopyWith$Input$matchInviteSlabInput<TRes> {
  factory CopyWith$Input$matchInviteSlabInput(
    Input$matchInviteSlabInput instance,
    TRes Function(Input$matchInviteSlabInput) then,
  ) = _CopyWithImpl$Input$matchInviteSlabInput;

  factory CopyWith$Input$matchInviteSlabInput.stub(TRes res) =
      _CopyWithStubImpl$Input$matchInviteSlabInput;

  TRes call({
    String? match_uuid,
    String? reachout_time,
    String? time_zone,
  });
}

class _CopyWithImpl$Input$matchInviteSlabInput<TRes>
    implements CopyWith$Input$matchInviteSlabInput<TRes> {
  _CopyWithImpl$Input$matchInviteSlabInput(
    this._instance,
    this._then,
  );

  final Input$matchInviteSlabInput _instance;

  final TRes Function(Input$matchInviteSlabInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? reachout_time = _undefined,
    Object? time_zone = _undefined,
  }) =>
      _then(Input$matchInviteSlabInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (reachout_time != _undefined)
          'reachout_time': (reachout_time as String?),
        if (time_zone != _undefined) 'time_zone': (time_zone as String?),
      }));
}

class _CopyWithStubImpl$Input$matchInviteSlabInput<TRes>
    implements CopyWith$Input$matchInviteSlabInput<TRes> {
  _CopyWithStubImpl$Input$matchInviteSlabInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? reachout_time,
    String? time_zone,
  }) =>
      _res;
}

class Input$MatchInvitePopupInput {
  factory Input$MatchInvitePopupInput({String? match_id}) =>
      Input$MatchInvitePopupInput._({
        if (match_id != null) r'match_id': match_id,
      });

  Input$MatchInvitePopupInput._(this._$data);

  factory Input$MatchInvitePopupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$MatchInvitePopupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$MatchInvitePopupInput<Input$MatchInvitePopupInput>
      get copyWith => CopyWith$Input$MatchInvitePopupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MatchInvitePopupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    return Object.hashAll(
        [_$data.containsKey('match_id') ? l$match_id : const {}]);
  }
}

abstract class CopyWith$Input$MatchInvitePopupInput<TRes> {
  factory CopyWith$Input$MatchInvitePopupInput(
    Input$MatchInvitePopupInput instance,
    TRes Function(Input$MatchInvitePopupInput) then,
  ) = _CopyWithImpl$Input$MatchInvitePopupInput;

  factory CopyWith$Input$MatchInvitePopupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MatchInvitePopupInput;

  TRes call({String? match_id});
}

class _CopyWithImpl$Input$MatchInvitePopupInput<TRes>
    implements CopyWith$Input$MatchInvitePopupInput<TRes> {
  _CopyWithImpl$Input$MatchInvitePopupInput(
    this._instance,
    this._then,
  );

  final Input$MatchInvitePopupInput _instance;

  final TRes Function(Input$MatchInvitePopupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_id = _undefined}) =>
      _then(Input$MatchInvitePopupInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$MatchInvitePopupInput<TRes>
    implements CopyWith$Input$MatchInvitePopupInput<TRes> {
  _CopyWithStubImpl$Input$MatchInvitePopupInput(this._res);

  TRes _res;

  call({String? match_id}) => _res;
}

class Input$MyMatchListFrontPaginationInput {
  factory Input$MyMatchListFrontPaginationInput({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    required int offset,
    int? limit,
    String? invitation_status,
    String? schdeuled_type,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$MyMatchListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$MyMatchListFrontPaginationInput._(this._$data);

  factory Input$MyMatchListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$MyMatchListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$MyMatchListFrontPaginationInput<
          Input$MyMatchListFrontPaginationInput>
      get copyWith => CopyWith$Input$MyMatchListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MyMatchListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$offset = offset;
    final l$limit = limit;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$MyMatchListFrontPaginationInput<TRes> {
  factory CopyWith$Input$MyMatchListFrontPaginationInput(
    Input$MyMatchListFrontPaginationInput instance,
    TRes Function(Input$MyMatchListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$MyMatchListFrontPaginationInput;

  factory CopyWith$Input$MyMatchListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MyMatchListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? invitation_status,
    String? schdeuled_type,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$MyMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyMatchListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$MyMatchListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MyMatchListFrontPaginationInput _instance;

  final TRes Function(Input$MyMatchListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$MyMatchListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$MyMatchListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyMatchListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MyMatchListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? invitation_status,
    String? schdeuled_type,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$MyGroupPaginationInput {
  factory Input$MyGroupPaginationInput({
    required int offset,
    int? limit,
    String? skill_level,
    String? group_type,
    String? club_name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$MyGroupPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (group_type != null) r'group_type': group_type,
        if (club_name != null) r'club_name': club_name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$MyGroupPaginationInput._(this._$data);

  factory Input$MyGroupPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('group_type')) {
      final l$group_type = data['group_type'];
      result$data['group_type'] = (l$group_type as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$MyGroupPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get group_type => (_$data['group_type'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('group_type')) {
      final l$group_type = group_type;
      result$data['group_type'] = l$group_type;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$MyGroupPaginationInput<Input$MyGroupPaginationInput>
      get copyWith => CopyWith$Input$MyGroupPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MyGroupPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$group_type = group_type;
    final lOther$group_type = other.group_type;
    if (_$data.containsKey('group_type') !=
        other._$data.containsKey('group_type')) {
      return false;
    }
    if (l$group_type != lOther$group_type) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$group_type = group_type;
    final l$club_name = club_name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('group_type') ? l$group_type : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$MyGroupPaginationInput<TRes> {
  factory CopyWith$Input$MyGroupPaginationInput(
    Input$MyGroupPaginationInput instance,
    TRes Function(Input$MyGroupPaginationInput) then,
  ) = _CopyWithImpl$Input$MyGroupPaginationInput;

  factory CopyWith$Input$MyGroupPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MyGroupPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? skill_level,
    String? group_type,
    String? club_name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$MyGroupPaginationInput<TRes>
    implements CopyWith$Input$MyGroupPaginationInput<TRes> {
  _CopyWithImpl$Input$MyGroupPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MyGroupPaginationInput _instance;

  final TRes Function(Input$MyGroupPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? group_type = _undefined,
    Object? club_name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$MyGroupPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (group_type != _undefined) 'group_type': (group_type as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$MyGroupPaginationInput<TRes>
    implements CopyWith$Input$MyGroupPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MyGroupPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? skill_level,
    String? group_type,
    String? club_name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$FrinedListInput {
  factory Input$FrinedListInput({
    required int offset,
    int? limit,
    String? club_name,
    String? skill_level,
    String? gender,
    int? age,
    int? recommendation_count,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$FrinedListInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (club_name != null) r'club_name': club_name,
        if (skill_level != null) r'skill_level': skill_level,
        if (gender != null) r'gender': gender,
        if (age != null) r'age': age,
        if (recommendation_count != null)
          r'recommendation_count': recommendation_count,
        if (name != null) r'name': name,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$FrinedListInput._(this._$data);

  factory Input$FrinedListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('age')) {
      final l$age = data['age'];
      result$data['age'] = (l$age as int?);
    }
    if (data.containsKey('recommendation_count')) {
      final l$recommendation_count = data['recommendation_count'];
      result$data['recommendation_count'] = (l$recommendation_count as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$FrinedListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get gender => (_$data['gender'] as String?);

  int? get age => (_$data['age'] as int?);

  int? get recommendation_count => (_$data['recommendation_count'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('age')) {
      final l$age = age;
      result$data['age'] = l$age;
    }
    if (_$data.containsKey('recommendation_count')) {
      final l$recommendation_count = recommendation_count;
      result$data['recommendation_count'] = l$recommendation_count;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$FrinedListInput<Input$FrinedListInput> get copyWith =>
      CopyWith$Input$FrinedListInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FrinedListInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$age = age;
    final lOther$age = other.age;
    if (_$data.containsKey('age') != other._$data.containsKey('age')) {
      return false;
    }
    if (l$age != lOther$age) {
      return false;
    }
    final l$recommendation_count = recommendation_count;
    final lOther$recommendation_count = other.recommendation_count;
    if (_$data.containsKey('recommendation_count') !=
        other._$data.containsKey('recommendation_count')) {
      return false;
    }
    if (l$recommendation_count != lOther$recommendation_count) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$club_name = club_name;
    final l$skill_level = skill_level;
    final l$gender = gender;
    final l$age = age;
    final l$recommendation_count = recommendation_count;
    final l$name = name;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('age') ? l$age : const {},
      _$data.containsKey('recommendation_count')
          ? l$recommendation_count
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$FrinedListInput<TRes> {
  factory CopyWith$Input$FrinedListInput(
    Input$FrinedListInput instance,
    TRes Function(Input$FrinedListInput) then,
  ) = _CopyWithImpl$Input$FrinedListInput;

  factory CopyWith$Input$FrinedListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FrinedListInput;

  TRes call({
    int? offset,
    int? limit,
    String? club_name,
    String? skill_level,
    String? gender,
    int? age,
    int? recommendation_count,
    String? name,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$FrinedListInput<TRes>
    implements CopyWith$Input$FrinedListInput<TRes> {
  _CopyWithImpl$Input$FrinedListInput(
    this._instance,
    this._then,
  );

  final Input$FrinedListInput _instance;

  final TRes Function(Input$FrinedListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? club_name = _undefined,
    Object? skill_level = _undefined,
    Object? gender = _undefined,
    Object? age = _undefined,
    Object? recommendation_count = _undefined,
    Object? name = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$FrinedListInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (age != _undefined) 'age': (age as int?),
        if (recommendation_count != _undefined)
          'recommendation_count': (recommendation_count as int?),
        if (name != _undefined) 'name': (name as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$FrinedListInput<TRes>
    implements CopyWith$Input$FrinedListInput<TRes> {
  _CopyWithStubImpl$Input$FrinedListInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? club_name,
    String? skill_level,
    String? gender,
    int? age,
    int? recommendation_count,
    String? name,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$MyEventListFrontPaginationInput {
  factory Input$MyEventListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      Input$MyEventListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
      });

  Input$MyEventListFrontPaginationInput._(this._$data);

  factory Input$MyEventListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    return Input$MyEventListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    return result$data;
  }

  CopyWith$Input$MyEventListFrontPaginationInput<
          Input$MyEventListFrontPaginationInput>
      get copyWith => CopyWith$Input$MyEventListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MyEventListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MyEventListFrontPaginationInput<TRes> {
  factory CopyWith$Input$MyEventListFrontPaginationInput(
    Input$MyEventListFrontPaginationInput instance,
    TRes Function(Input$MyEventListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$MyEventListFrontPaginationInput;

  factory CopyWith$Input$MyEventListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MyEventListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  });
}

class _CopyWithImpl$Input$MyEventListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyEventListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$MyEventListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MyEventListFrontPaginationInput _instance;

  final TRes Function(Input$MyEventListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
  }) =>
      _then(Input$MyEventListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
      }));
}

class _CopyWithStubImpl$Input$MyEventListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyEventListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MyEventListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      _res;
}

class Input$MentionInput {
  factory Input$MentionInput({String? name}) => Input$MentionInput._({
        if (name != null) r'name': name,
      });

  Input$MentionInput._(this._$data);

  factory Input$MentionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$MentionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$MentionInput<Input$MentionInput> get copyWith =>
      CopyWith$Input$MentionInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MentionInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([_$data.containsKey('name') ? l$name : const {}]);
  }
}

abstract class CopyWith$Input$MentionInput<TRes> {
  factory CopyWith$Input$MentionInput(
    Input$MentionInput instance,
    TRes Function(Input$MentionInput) then,
  ) = _CopyWithImpl$Input$MentionInput;

  factory CopyWith$Input$MentionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MentionInput;

  TRes call({String? name});
}

class _CopyWithImpl$Input$MentionInput<TRes>
    implements CopyWith$Input$MentionInput<TRes> {
  _CopyWithImpl$Input$MentionInput(
    this._instance,
    this._then,
  );

  final Input$MentionInput _instance;

  final TRes Function(Input$MentionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) => _then(Input$MentionInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$MentionInput<TRes>
    implements CopyWith$Input$MentionInput<TRes> {
  _CopyWithStubImpl$Input$MentionInput(this._res);

  TRes _res;

  call({String? name}) => _res;
}

class Input$notificationListInput {
  factory Input$notificationListInput({
    int? type,
    int? is_requested,
    int? limit,
    int? offset,
  }) =>
      Input$notificationListInput._({
        if (type != null) r'type': type,
        if (is_requested != null) r'is_requested': is_requested,
        if (limit != null) r'limit': limit,
        if (offset != null) r'offset': offset,
      });

  Input$notificationListInput._(this._$data);

  factory Input$notificationListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    if (data.containsKey('is_requested')) {
      final l$is_requested = data['is_requested'];
      result$data['is_requested'] = (l$is_requested as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    return Input$notificationListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get type => (_$data['type'] as int?);

  int? get is_requested => (_$data['is_requested'] as int?);

  int? get limit => (_$data['limit'] as int?);

  int? get offset => (_$data['offset'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('is_requested')) {
      final l$is_requested = is_requested;
      result$data['is_requested'] = l$is_requested;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    return result$data;
  }

  CopyWith$Input$notificationListInput<Input$notificationListInput>
      get copyWith => CopyWith$Input$notificationListInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$notificationListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$is_requested = is_requested;
    final lOther$is_requested = other.is_requested;
    if (_$data.containsKey('is_requested') !=
        other._$data.containsKey('is_requested')) {
      return false;
    }
    if (l$is_requested != lOther$is_requested) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$is_requested = is_requested;
    final l$limit = limit;
    final l$offset = offset;
    return Object.hashAll([
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('is_requested') ? l$is_requested : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('offset') ? l$offset : const {},
    ]);
  }
}

abstract class CopyWith$Input$notificationListInput<TRes> {
  factory CopyWith$Input$notificationListInput(
    Input$notificationListInput instance,
    TRes Function(Input$notificationListInput) then,
  ) = _CopyWithImpl$Input$notificationListInput;

  factory CopyWith$Input$notificationListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$notificationListInput;

  TRes call({
    int? type,
    int? is_requested,
    int? limit,
    int? offset,
  });
}

class _CopyWithImpl$Input$notificationListInput<TRes>
    implements CopyWith$Input$notificationListInput<TRes> {
  _CopyWithImpl$Input$notificationListInput(
    this._instance,
    this._then,
  );

  final Input$notificationListInput _instance;

  final TRes Function(Input$notificationListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? is_requested = _undefined,
    Object? limit = _undefined,
    Object? offset = _undefined,
  }) =>
      _then(Input$notificationListInput._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as int?),
        if (is_requested != _undefined) 'is_requested': (is_requested as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (offset != _undefined) 'offset': (offset as int?),
      }));
}

class _CopyWithStubImpl$Input$notificationListInput<TRes>
    implements CopyWith$Input$notificationListInput<TRes> {
  _CopyWithStubImpl$Input$notificationListInput(this._res);

  TRes _res;

  call({
    int? type,
    int? is_requested,
    int? limit,
    int? offset,
  }) =>
      _res;
}

class Input$ClearNotificationInput {
  factory Input$ClearNotificationInput({int? type}) =>
      Input$ClearNotificationInput._({
        if (type != null) r'type': type,
      });

  Input$ClearNotificationInput._(this._$data);

  factory Input$ClearNotificationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    return Input$ClearNotificationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get type => (_$data['type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    return result$data;
  }

  CopyWith$Input$ClearNotificationInput<Input$ClearNotificationInput>
      get copyWith => CopyWith$Input$ClearNotificationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClearNotificationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    return Object.hashAll([_$data.containsKey('type') ? l$type : const {}]);
  }
}

abstract class CopyWith$Input$ClearNotificationInput<TRes> {
  factory CopyWith$Input$ClearNotificationInput(
    Input$ClearNotificationInput instance,
    TRes Function(Input$ClearNotificationInput) then,
  ) = _CopyWithImpl$Input$ClearNotificationInput;

  factory CopyWith$Input$ClearNotificationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearNotificationInput;

  TRes call({int? type});
}

class _CopyWithImpl$Input$ClearNotificationInput<TRes>
    implements CopyWith$Input$ClearNotificationInput<TRes> {
  _CopyWithImpl$Input$ClearNotificationInput(
    this._instance,
    this._then,
  );

  final Input$ClearNotificationInput _instance;

  final TRes Function(Input$ClearNotificationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? type = _undefined}) =>
      _then(Input$ClearNotificationInput._({
        ..._instance._$data,
        if (type != _undefined) 'type': (type as int?),
      }));
}

class _CopyWithStubImpl$Input$ClearNotificationInput<TRes>
    implements CopyWith$Input$ClearNotificationInput<TRes> {
  _CopyWithStubImpl$Input$ClearNotificationInput(this._res);

  TRes _res;

  call({int? type}) => _res;
}

class Input$TransactionListPaginationInput {
  factory Input$TransactionListPaginationInput({
    required int offset,
    int? limit,
    String? id,
    String? date,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$TransactionListPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (id != null) r'id': id,
        if (date != null) r'date': date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$TransactionListPaginationInput._(this._$data);

  factory Input$TransactionListPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$TransactionListPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get id => (_$data['id'] as String?);

  String? get date => (_$data['date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$TransactionListPaginationInput<
          Input$TransactionListPaginationInput>
      get copyWith => CopyWith$Input$TransactionListPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionListPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$id = id;
    final l$date = date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionListPaginationInput<TRes> {
  factory CopyWith$Input$TransactionListPaginationInput(
    Input$TransactionListPaginationInput instance,
    TRes Function(Input$TransactionListPaginationInput) then,
  ) = _CopyWithImpl$Input$TransactionListPaginationInput;

  factory CopyWith$Input$TransactionListPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionListPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? id,
    String? date,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$TransactionListPaginationInput<TRes>
    implements CopyWith$Input$TransactionListPaginationInput<TRes> {
  _CopyWithImpl$Input$TransactionListPaginationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionListPaginationInput _instance;

  final TRes Function(Input$TransactionListPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? id = _undefined,
    Object? date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$TransactionListPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (id != _undefined) 'id': (id as String?),
        if (date != _undefined) 'date': (date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$TransactionListPaginationInput<TRes>
    implements CopyWith$Input$TransactionListPaginationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionListPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? id,
    String? date,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewTransactionDetailInput {
  factory Input$viewTransactionDetailInput({required String uuid}) =>
      Input$viewTransactionDetailInput._({
        r'uuid': uuid,
      });

  Input$viewTransactionDetailInput._(this._$data);

  factory Input$viewTransactionDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewTransactionDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewTransactionDetailInput<Input$viewTransactionDetailInput>
      get copyWith => CopyWith$Input$viewTransactionDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewTransactionDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewTransactionDetailInput<TRes> {
  factory CopyWith$Input$viewTransactionDetailInput(
    Input$viewTransactionDetailInput instance,
    TRes Function(Input$viewTransactionDetailInput) then,
  ) = _CopyWithImpl$Input$viewTransactionDetailInput;

  factory CopyWith$Input$viewTransactionDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewTransactionDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewTransactionDetailInput<TRes>
    implements CopyWith$Input$viewTransactionDetailInput<TRes> {
  _CopyWithImpl$Input$viewTransactionDetailInput(
    this._instance,
    this._then,
  );

  final Input$viewTransactionDetailInput _instance;

  final TRes Function(Input$viewTransactionDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$viewTransactionDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewTransactionDetailInput<TRes>
    implements CopyWith$Input$viewTransactionDetailInput<TRes> {
  _CopyWithStubImpl$Input$viewTransactionDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$NotificationReadInput {
  factory Input$NotificationReadInput({String? uuid}) =>
      Input$NotificationReadInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$NotificationReadInput._(this._$data);

  factory Input$NotificationReadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$NotificationReadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$NotificationReadInput<Input$NotificationReadInput>
      get copyWith => CopyWith$Input$NotificationReadInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NotificationReadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$NotificationReadInput<TRes> {
  factory CopyWith$Input$NotificationReadInput(
    Input$NotificationReadInput instance,
    TRes Function(Input$NotificationReadInput) then,
  ) = _CopyWithImpl$Input$NotificationReadInput;

  factory CopyWith$Input$NotificationReadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NotificationReadInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$NotificationReadInput<TRes>
    implements CopyWith$Input$NotificationReadInput<TRes> {
  _CopyWithImpl$Input$NotificationReadInput(
    this._instance,
    this._then,
  );

  final Input$NotificationReadInput _instance;

  final TRes Function(Input$NotificationReadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$NotificationReadInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$NotificationReadInput<TRes>
    implements CopyWith$Input$NotificationReadInput<TRes> {
  _CopyWithStubImpl$Input$NotificationReadInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$notificationSettingInput {
  factory Input$notificationSettingInput({
    int? is_inapp,
    int? in_app_day,
    int? in_app_night,
    int? is_snooze,
    String? time_interval,
    int? is_manual,
    int? hours,
    int? minute,
    int? is_openplay,
    int? is_lesson,
    int? is_social,
    int? is_tournament,
    int? is_camp,
    int? is_league,
    int? is_home_club,
    String? club_uuid,
    int? invite_match,
    int? invite_lesson,
    int? invite_openplay,
    int? invite_social,
    int? invite_league,
    int? invite_tournament,
    int? invite_camp,
    double? min_skill_range,
    double? max_skill_range,
  }) =>
      Input$notificationSettingInput._({
        if (is_inapp != null) r'is_inapp': is_inapp,
        if (in_app_day != null) r'in_app_day': in_app_day,
        if (in_app_night != null) r'in_app_night': in_app_night,
        if (is_snooze != null) r'is_snooze': is_snooze,
        if (time_interval != null) r'time_interval': time_interval,
        if (is_manual != null) r'is_manual': is_manual,
        if (hours != null) r'hours': hours,
        if (minute != null) r'minute': minute,
        if (is_openplay != null) r'is_openplay': is_openplay,
        if (is_lesson != null) r'is_lesson': is_lesson,
        if (is_social != null) r'is_social': is_social,
        if (is_tournament != null) r'is_tournament': is_tournament,
        if (is_camp != null) r'is_camp': is_camp,
        if (is_league != null) r'is_league': is_league,
        if (is_home_club != null) r'is_home_club': is_home_club,
        if (club_uuid != null) r'club_uuid': club_uuid,
        if (invite_match != null) r'invite_match': invite_match,
        if (invite_lesson != null) r'invite_lesson': invite_lesson,
        if (invite_openplay != null) r'invite_openplay': invite_openplay,
        if (invite_social != null) r'invite_social': invite_social,
        if (invite_league != null) r'invite_league': invite_league,
        if (invite_tournament != null) r'invite_tournament': invite_tournament,
        if (invite_camp != null) r'invite_camp': invite_camp,
        if (min_skill_range != null) r'min_skill_range': min_skill_range,
        if (max_skill_range != null) r'max_skill_range': max_skill_range,
      });

  Input$notificationSettingInput._(this._$data);

  factory Input$notificationSettingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is_inapp')) {
      final l$is_inapp = data['is_inapp'];
      result$data['is_inapp'] = (l$is_inapp as int?);
    }
    if (data.containsKey('in_app_day')) {
      final l$in_app_day = data['in_app_day'];
      result$data['in_app_day'] = (l$in_app_day as int?);
    }
    if (data.containsKey('in_app_night')) {
      final l$in_app_night = data['in_app_night'];
      result$data['in_app_night'] = (l$in_app_night as int?);
    }
    if (data.containsKey('is_snooze')) {
      final l$is_snooze = data['is_snooze'];
      result$data['is_snooze'] = (l$is_snooze as int?);
    }
    if (data.containsKey('time_interval')) {
      final l$time_interval = data['time_interval'];
      result$data['time_interval'] = (l$time_interval as String?);
    }
    if (data.containsKey('is_manual')) {
      final l$is_manual = data['is_manual'];
      result$data['is_manual'] = (l$is_manual as int?);
    }
    if (data.containsKey('hours')) {
      final l$hours = data['hours'];
      result$data['hours'] = (l$hours as int?);
    }
    if (data.containsKey('minute')) {
      final l$minute = data['minute'];
      result$data['minute'] = (l$minute as int?);
    }
    if (data.containsKey('is_openplay')) {
      final l$is_openplay = data['is_openplay'];
      result$data['is_openplay'] = (l$is_openplay as int?);
    }
    if (data.containsKey('is_lesson')) {
      final l$is_lesson = data['is_lesson'];
      result$data['is_lesson'] = (l$is_lesson as int?);
    }
    if (data.containsKey('is_social')) {
      final l$is_social = data['is_social'];
      result$data['is_social'] = (l$is_social as int?);
    }
    if (data.containsKey('is_tournament')) {
      final l$is_tournament = data['is_tournament'];
      result$data['is_tournament'] = (l$is_tournament as int?);
    }
    if (data.containsKey('is_camp')) {
      final l$is_camp = data['is_camp'];
      result$data['is_camp'] = (l$is_camp as int?);
    }
    if (data.containsKey('is_league')) {
      final l$is_league = data['is_league'];
      result$data['is_league'] = (l$is_league as int?);
    }
    if (data.containsKey('is_home_club')) {
      final l$is_home_club = data['is_home_club'];
      result$data['is_home_club'] = (l$is_home_club as int?);
    }
    if (data.containsKey('club_uuid')) {
      final l$club_uuid = data['club_uuid'];
      result$data['club_uuid'] = (l$club_uuid as String?);
    }
    if (data.containsKey('invite_match')) {
      final l$invite_match = data['invite_match'];
      result$data['invite_match'] = (l$invite_match as int?);
    }
    if (data.containsKey('invite_lesson')) {
      final l$invite_lesson = data['invite_lesson'];
      result$data['invite_lesson'] = (l$invite_lesson as int?);
    }
    if (data.containsKey('invite_openplay')) {
      final l$invite_openplay = data['invite_openplay'];
      result$data['invite_openplay'] = (l$invite_openplay as int?);
    }
    if (data.containsKey('invite_social')) {
      final l$invite_social = data['invite_social'];
      result$data['invite_social'] = (l$invite_social as int?);
    }
    if (data.containsKey('invite_league')) {
      final l$invite_league = data['invite_league'];
      result$data['invite_league'] = (l$invite_league as int?);
    }
    if (data.containsKey('invite_tournament')) {
      final l$invite_tournament = data['invite_tournament'];
      result$data['invite_tournament'] = (l$invite_tournament as int?);
    }
    if (data.containsKey('invite_camp')) {
      final l$invite_camp = data['invite_camp'];
      result$data['invite_camp'] = (l$invite_camp as int?);
    }
    if (data.containsKey('min_skill_range')) {
      final l$min_skill_range = data['min_skill_range'];
      result$data['min_skill_range'] = (l$min_skill_range as num?)?.toDouble();
    }
    if (data.containsKey('max_skill_range')) {
      final l$max_skill_range = data['max_skill_range'];
      result$data['max_skill_range'] = (l$max_skill_range as num?)?.toDouble();
    }
    return Input$notificationSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get is_inapp => (_$data['is_inapp'] as int?);

  int? get in_app_day => (_$data['in_app_day'] as int?);

  int? get in_app_night => (_$data['in_app_night'] as int?);

  int? get is_snooze => (_$data['is_snooze'] as int?);

  String? get time_interval => (_$data['time_interval'] as String?);

  int? get is_manual => (_$data['is_manual'] as int?);

  int? get hours => (_$data['hours'] as int?);

  int? get minute => (_$data['minute'] as int?);

  int? get is_openplay => (_$data['is_openplay'] as int?);

  int? get is_lesson => (_$data['is_lesson'] as int?);

  int? get is_social => (_$data['is_social'] as int?);

  int? get is_tournament => (_$data['is_tournament'] as int?);

  int? get is_camp => (_$data['is_camp'] as int?);

  int? get is_league => (_$data['is_league'] as int?);

  int? get is_home_club => (_$data['is_home_club'] as int?);

  String? get club_uuid => (_$data['club_uuid'] as String?);

  int? get invite_match => (_$data['invite_match'] as int?);

  int? get invite_lesson => (_$data['invite_lesson'] as int?);

  int? get invite_openplay => (_$data['invite_openplay'] as int?);

  int? get invite_social => (_$data['invite_social'] as int?);

  int? get invite_league => (_$data['invite_league'] as int?);

  int? get invite_tournament => (_$data['invite_tournament'] as int?);

  int? get invite_camp => (_$data['invite_camp'] as int?);

  double? get min_skill_range => (_$data['min_skill_range'] as double?);

  double? get max_skill_range => (_$data['max_skill_range'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is_inapp')) {
      final l$is_inapp = is_inapp;
      result$data['is_inapp'] = l$is_inapp;
    }
    if (_$data.containsKey('in_app_day')) {
      final l$in_app_day = in_app_day;
      result$data['in_app_day'] = l$in_app_day;
    }
    if (_$data.containsKey('in_app_night')) {
      final l$in_app_night = in_app_night;
      result$data['in_app_night'] = l$in_app_night;
    }
    if (_$data.containsKey('is_snooze')) {
      final l$is_snooze = is_snooze;
      result$data['is_snooze'] = l$is_snooze;
    }
    if (_$data.containsKey('time_interval')) {
      final l$time_interval = time_interval;
      result$data['time_interval'] = l$time_interval;
    }
    if (_$data.containsKey('is_manual')) {
      final l$is_manual = is_manual;
      result$data['is_manual'] = l$is_manual;
    }
    if (_$data.containsKey('hours')) {
      final l$hours = hours;
      result$data['hours'] = l$hours;
    }
    if (_$data.containsKey('minute')) {
      final l$minute = minute;
      result$data['minute'] = l$minute;
    }
    if (_$data.containsKey('is_openplay')) {
      final l$is_openplay = is_openplay;
      result$data['is_openplay'] = l$is_openplay;
    }
    if (_$data.containsKey('is_lesson')) {
      final l$is_lesson = is_lesson;
      result$data['is_lesson'] = l$is_lesson;
    }
    if (_$data.containsKey('is_social')) {
      final l$is_social = is_social;
      result$data['is_social'] = l$is_social;
    }
    if (_$data.containsKey('is_tournament')) {
      final l$is_tournament = is_tournament;
      result$data['is_tournament'] = l$is_tournament;
    }
    if (_$data.containsKey('is_camp')) {
      final l$is_camp = is_camp;
      result$data['is_camp'] = l$is_camp;
    }
    if (_$data.containsKey('is_league')) {
      final l$is_league = is_league;
      result$data['is_league'] = l$is_league;
    }
    if (_$data.containsKey('is_home_club')) {
      final l$is_home_club = is_home_club;
      result$data['is_home_club'] = l$is_home_club;
    }
    if (_$data.containsKey('club_uuid')) {
      final l$club_uuid = club_uuid;
      result$data['club_uuid'] = l$club_uuid;
    }
    if (_$data.containsKey('invite_match')) {
      final l$invite_match = invite_match;
      result$data['invite_match'] = l$invite_match;
    }
    if (_$data.containsKey('invite_lesson')) {
      final l$invite_lesson = invite_lesson;
      result$data['invite_lesson'] = l$invite_lesson;
    }
    if (_$data.containsKey('invite_openplay')) {
      final l$invite_openplay = invite_openplay;
      result$data['invite_openplay'] = l$invite_openplay;
    }
    if (_$data.containsKey('invite_social')) {
      final l$invite_social = invite_social;
      result$data['invite_social'] = l$invite_social;
    }
    if (_$data.containsKey('invite_league')) {
      final l$invite_league = invite_league;
      result$data['invite_league'] = l$invite_league;
    }
    if (_$data.containsKey('invite_tournament')) {
      final l$invite_tournament = invite_tournament;
      result$data['invite_tournament'] = l$invite_tournament;
    }
    if (_$data.containsKey('invite_camp')) {
      final l$invite_camp = invite_camp;
      result$data['invite_camp'] = l$invite_camp;
    }
    if (_$data.containsKey('min_skill_range')) {
      final l$min_skill_range = min_skill_range;
      result$data['min_skill_range'] = l$min_skill_range;
    }
    if (_$data.containsKey('max_skill_range')) {
      final l$max_skill_range = max_skill_range;
      result$data['max_skill_range'] = l$max_skill_range;
    }
    return result$data;
  }

  CopyWith$Input$notificationSettingInput<Input$notificationSettingInput>
      get copyWith => CopyWith$Input$notificationSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$notificationSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$is_inapp = is_inapp;
    final lOther$is_inapp = other.is_inapp;
    if (_$data.containsKey('is_inapp') !=
        other._$data.containsKey('is_inapp')) {
      return false;
    }
    if (l$is_inapp != lOther$is_inapp) {
      return false;
    }
    final l$in_app_day = in_app_day;
    final lOther$in_app_day = other.in_app_day;
    if (_$data.containsKey('in_app_day') !=
        other._$data.containsKey('in_app_day')) {
      return false;
    }
    if (l$in_app_day != lOther$in_app_day) {
      return false;
    }
    final l$in_app_night = in_app_night;
    final lOther$in_app_night = other.in_app_night;
    if (_$data.containsKey('in_app_night') !=
        other._$data.containsKey('in_app_night')) {
      return false;
    }
    if (l$in_app_night != lOther$in_app_night) {
      return false;
    }
    final l$is_snooze = is_snooze;
    final lOther$is_snooze = other.is_snooze;
    if (_$data.containsKey('is_snooze') !=
        other._$data.containsKey('is_snooze')) {
      return false;
    }
    if (l$is_snooze != lOther$is_snooze) {
      return false;
    }
    final l$time_interval = time_interval;
    final lOther$time_interval = other.time_interval;
    if (_$data.containsKey('time_interval') !=
        other._$data.containsKey('time_interval')) {
      return false;
    }
    if (l$time_interval != lOther$time_interval) {
      return false;
    }
    final l$is_manual = is_manual;
    final lOther$is_manual = other.is_manual;
    if (_$data.containsKey('is_manual') !=
        other._$data.containsKey('is_manual')) {
      return false;
    }
    if (l$is_manual != lOther$is_manual) {
      return false;
    }
    final l$hours = hours;
    final lOther$hours = other.hours;
    if (_$data.containsKey('hours') != other._$data.containsKey('hours')) {
      return false;
    }
    if (l$hours != lOther$hours) {
      return false;
    }
    final l$minute = minute;
    final lOther$minute = other.minute;
    if (_$data.containsKey('minute') != other._$data.containsKey('minute')) {
      return false;
    }
    if (l$minute != lOther$minute) {
      return false;
    }
    final l$is_openplay = is_openplay;
    final lOther$is_openplay = other.is_openplay;
    if (_$data.containsKey('is_openplay') !=
        other._$data.containsKey('is_openplay')) {
      return false;
    }
    if (l$is_openplay != lOther$is_openplay) {
      return false;
    }
    final l$is_lesson = is_lesson;
    final lOther$is_lesson = other.is_lesson;
    if (_$data.containsKey('is_lesson') !=
        other._$data.containsKey('is_lesson')) {
      return false;
    }
    if (l$is_lesson != lOther$is_lesson) {
      return false;
    }
    final l$is_social = is_social;
    final lOther$is_social = other.is_social;
    if (_$data.containsKey('is_social') !=
        other._$data.containsKey('is_social')) {
      return false;
    }
    if (l$is_social != lOther$is_social) {
      return false;
    }
    final l$is_tournament = is_tournament;
    final lOther$is_tournament = other.is_tournament;
    if (_$data.containsKey('is_tournament') !=
        other._$data.containsKey('is_tournament')) {
      return false;
    }
    if (l$is_tournament != lOther$is_tournament) {
      return false;
    }
    final l$is_camp = is_camp;
    final lOther$is_camp = other.is_camp;
    if (_$data.containsKey('is_camp') != other._$data.containsKey('is_camp')) {
      return false;
    }
    if (l$is_camp != lOther$is_camp) {
      return false;
    }
    final l$is_league = is_league;
    final lOther$is_league = other.is_league;
    if (_$data.containsKey('is_league') !=
        other._$data.containsKey('is_league')) {
      return false;
    }
    if (l$is_league != lOther$is_league) {
      return false;
    }
    final l$is_home_club = is_home_club;
    final lOther$is_home_club = other.is_home_club;
    if (_$data.containsKey('is_home_club') !=
        other._$data.containsKey('is_home_club')) {
      return false;
    }
    if (l$is_home_club != lOther$is_home_club) {
      return false;
    }
    final l$club_uuid = club_uuid;
    final lOther$club_uuid = other.club_uuid;
    if (_$data.containsKey('club_uuid') !=
        other._$data.containsKey('club_uuid')) {
      return false;
    }
    if (l$club_uuid != lOther$club_uuid) {
      return false;
    }
    final l$invite_match = invite_match;
    final lOther$invite_match = other.invite_match;
    if (_$data.containsKey('invite_match') !=
        other._$data.containsKey('invite_match')) {
      return false;
    }
    if (l$invite_match != lOther$invite_match) {
      return false;
    }
    final l$invite_lesson = invite_lesson;
    final lOther$invite_lesson = other.invite_lesson;
    if (_$data.containsKey('invite_lesson') !=
        other._$data.containsKey('invite_lesson')) {
      return false;
    }
    if (l$invite_lesson != lOther$invite_lesson) {
      return false;
    }
    final l$invite_openplay = invite_openplay;
    final lOther$invite_openplay = other.invite_openplay;
    if (_$data.containsKey('invite_openplay') !=
        other._$data.containsKey('invite_openplay')) {
      return false;
    }
    if (l$invite_openplay != lOther$invite_openplay) {
      return false;
    }
    final l$invite_social = invite_social;
    final lOther$invite_social = other.invite_social;
    if (_$data.containsKey('invite_social') !=
        other._$data.containsKey('invite_social')) {
      return false;
    }
    if (l$invite_social != lOther$invite_social) {
      return false;
    }
    final l$invite_league = invite_league;
    final lOther$invite_league = other.invite_league;
    if (_$data.containsKey('invite_league') !=
        other._$data.containsKey('invite_league')) {
      return false;
    }
    if (l$invite_league != lOther$invite_league) {
      return false;
    }
    final l$invite_tournament = invite_tournament;
    final lOther$invite_tournament = other.invite_tournament;
    if (_$data.containsKey('invite_tournament') !=
        other._$data.containsKey('invite_tournament')) {
      return false;
    }
    if (l$invite_tournament != lOther$invite_tournament) {
      return false;
    }
    final l$invite_camp = invite_camp;
    final lOther$invite_camp = other.invite_camp;
    if (_$data.containsKey('invite_camp') !=
        other._$data.containsKey('invite_camp')) {
      return false;
    }
    if (l$invite_camp != lOther$invite_camp) {
      return false;
    }
    final l$min_skill_range = min_skill_range;
    final lOther$min_skill_range = other.min_skill_range;
    if (_$data.containsKey('min_skill_range') !=
        other._$data.containsKey('min_skill_range')) {
      return false;
    }
    if (l$min_skill_range != lOther$min_skill_range) {
      return false;
    }
    final l$max_skill_range = max_skill_range;
    final lOther$max_skill_range = other.max_skill_range;
    if (_$data.containsKey('max_skill_range') !=
        other._$data.containsKey('max_skill_range')) {
      return false;
    }
    if (l$max_skill_range != lOther$max_skill_range) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$is_inapp = is_inapp;
    final l$in_app_day = in_app_day;
    final l$in_app_night = in_app_night;
    final l$is_snooze = is_snooze;
    final l$time_interval = time_interval;
    final l$is_manual = is_manual;
    final l$hours = hours;
    final l$minute = minute;
    final l$is_openplay = is_openplay;
    final l$is_lesson = is_lesson;
    final l$is_social = is_social;
    final l$is_tournament = is_tournament;
    final l$is_camp = is_camp;
    final l$is_league = is_league;
    final l$is_home_club = is_home_club;
    final l$club_uuid = club_uuid;
    final l$invite_match = invite_match;
    final l$invite_lesson = invite_lesson;
    final l$invite_openplay = invite_openplay;
    final l$invite_social = invite_social;
    final l$invite_league = invite_league;
    final l$invite_tournament = invite_tournament;
    final l$invite_camp = invite_camp;
    final l$min_skill_range = min_skill_range;
    final l$max_skill_range = max_skill_range;
    return Object.hashAll([
      _$data.containsKey('is_inapp') ? l$is_inapp : const {},
      _$data.containsKey('in_app_day') ? l$in_app_day : const {},
      _$data.containsKey('in_app_night') ? l$in_app_night : const {},
      _$data.containsKey('is_snooze') ? l$is_snooze : const {},
      _$data.containsKey('time_interval') ? l$time_interval : const {},
      _$data.containsKey('is_manual') ? l$is_manual : const {},
      _$data.containsKey('hours') ? l$hours : const {},
      _$data.containsKey('minute') ? l$minute : const {},
      _$data.containsKey('is_openplay') ? l$is_openplay : const {},
      _$data.containsKey('is_lesson') ? l$is_lesson : const {},
      _$data.containsKey('is_social') ? l$is_social : const {},
      _$data.containsKey('is_tournament') ? l$is_tournament : const {},
      _$data.containsKey('is_camp') ? l$is_camp : const {},
      _$data.containsKey('is_league') ? l$is_league : const {},
      _$data.containsKey('is_home_club') ? l$is_home_club : const {},
      _$data.containsKey('club_uuid') ? l$club_uuid : const {},
      _$data.containsKey('invite_match') ? l$invite_match : const {},
      _$data.containsKey('invite_lesson') ? l$invite_lesson : const {},
      _$data.containsKey('invite_openplay') ? l$invite_openplay : const {},
      _$data.containsKey('invite_social') ? l$invite_social : const {},
      _$data.containsKey('invite_league') ? l$invite_league : const {},
      _$data.containsKey('invite_tournament') ? l$invite_tournament : const {},
      _$data.containsKey('invite_camp') ? l$invite_camp : const {},
      _$data.containsKey('min_skill_range') ? l$min_skill_range : const {},
      _$data.containsKey('max_skill_range') ? l$max_skill_range : const {},
    ]);
  }
}

abstract class CopyWith$Input$notificationSettingInput<TRes> {
  factory CopyWith$Input$notificationSettingInput(
    Input$notificationSettingInput instance,
    TRes Function(Input$notificationSettingInput) then,
  ) = _CopyWithImpl$Input$notificationSettingInput;

  factory CopyWith$Input$notificationSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$notificationSettingInput;

  TRes call({
    int? is_inapp,
    int? in_app_day,
    int? in_app_night,
    int? is_snooze,
    String? time_interval,
    int? is_manual,
    int? hours,
    int? minute,
    int? is_openplay,
    int? is_lesson,
    int? is_social,
    int? is_tournament,
    int? is_camp,
    int? is_league,
    int? is_home_club,
    String? club_uuid,
    int? invite_match,
    int? invite_lesson,
    int? invite_openplay,
    int? invite_social,
    int? invite_league,
    int? invite_tournament,
    int? invite_camp,
    double? min_skill_range,
    double? max_skill_range,
  });
}

class _CopyWithImpl$Input$notificationSettingInput<TRes>
    implements CopyWith$Input$notificationSettingInput<TRes> {
  _CopyWithImpl$Input$notificationSettingInput(
    this._instance,
    this._then,
  );

  final Input$notificationSettingInput _instance;

  final TRes Function(Input$notificationSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? is_inapp = _undefined,
    Object? in_app_day = _undefined,
    Object? in_app_night = _undefined,
    Object? is_snooze = _undefined,
    Object? time_interval = _undefined,
    Object? is_manual = _undefined,
    Object? hours = _undefined,
    Object? minute = _undefined,
    Object? is_openplay = _undefined,
    Object? is_lesson = _undefined,
    Object? is_social = _undefined,
    Object? is_tournament = _undefined,
    Object? is_camp = _undefined,
    Object? is_league = _undefined,
    Object? is_home_club = _undefined,
    Object? club_uuid = _undefined,
    Object? invite_match = _undefined,
    Object? invite_lesson = _undefined,
    Object? invite_openplay = _undefined,
    Object? invite_social = _undefined,
    Object? invite_league = _undefined,
    Object? invite_tournament = _undefined,
    Object? invite_camp = _undefined,
    Object? min_skill_range = _undefined,
    Object? max_skill_range = _undefined,
  }) =>
      _then(Input$notificationSettingInput._({
        ..._instance._$data,
        if (is_inapp != _undefined) 'is_inapp': (is_inapp as int?),
        if (in_app_day != _undefined) 'in_app_day': (in_app_day as int?),
        if (in_app_night != _undefined) 'in_app_night': (in_app_night as int?),
        if (is_snooze != _undefined) 'is_snooze': (is_snooze as int?),
        if (time_interval != _undefined)
          'time_interval': (time_interval as String?),
        if (is_manual != _undefined) 'is_manual': (is_manual as int?),
        if (hours != _undefined) 'hours': (hours as int?),
        if (minute != _undefined) 'minute': (minute as int?),
        if (is_openplay != _undefined) 'is_openplay': (is_openplay as int?),
        if (is_lesson != _undefined) 'is_lesson': (is_lesson as int?),
        if (is_social != _undefined) 'is_social': (is_social as int?),
        if (is_tournament != _undefined)
          'is_tournament': (is_tournament as int?),
        if (is_camp != _undefined) 'is_camp': (is_camp as int?),
        if (is_league != _undefined) 'is_league': (is_league as int?),
        if (is_home_club != _undefined) 'is_home_club': (is_home_club as int?),
        if (club_uuid != _undefined) 'club_uuid': (club_uuid as String?),
        if (invite_match != _undefined) 'invite_match': (invite_match as int?),
        if (invite_lesson != _undefined)
          'invite_lesson': (invite_lesson as int?),
        if (invite_openplay != _undefined)
          'invite_openplay': (invite_openplay as int?),
        if (invite_social != _undefined)
          'invite_social': (invite_social as int?),
        if (invite_league != _undefined)
          'invite_league': (invite_league as int?),
        if (invite_tournament != _undefined)
          'invite_tournament': (invite_tournament as int?),
        if (invite_camp != _undefined) 'invite_camp': (invite_camp as int?),
        if (min_skill_range != _undefined)
          'min_skill_range': (min_skill_range as double?),
        if (max_skill_range != _undefined)
          'max_skill_range': (max_skill_range as double?),
      }));
}

class _CopyWithStubImpl$Input$notificationSettingInput<TRes>
    implements CopyWith$Input$notificationSettingInput<TRes> {
  _CopyWithStubImpl$Input$notificationSettingInput(this._res);

  TRes _res;

  call({
    int? is_inapp,
    int? in_app_day,
    int? in_app_night,
    int? is_snooze,
    String? time_interval,
    int? is_manual,
    int? hours,
    int? minute,
    int? is_openplay,
    int? is_lesson,
    int? is_social,
    int? is_tournament,
    int? is_camp,
    int? is_league,
    int? is_home_club,
    String? club_uuid,
    int? invite_match,
    int? invite_lesson,
    int? invite_openplay,
    int? invite_social,
    int? invite_league,
    int? invite_tournament,
    int? invite_camp,
    double? min_skill_range,
    double? max_skill_range,
  }) =>
      _res;
}

class Input$AddAccountDetailInput {
  factory Input$AddAccountDetailInput({
    String? version,
    String? platform,
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  }) =>
      Input$AddAccountDetailInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (account_holder_name != null)
          r'account_holder_name': account_holder_name,
        if (account_holder_type != null)
          r'account_holder_type': account_holder_type,
        if (routing_number != null) r'routing_number': routing_number,
        if (account_number != null) r'account_number': account_number,
        if (first_name != null) r'first_name': first_name,
        if (last_name != null) r'last_name': last_name,
        if (city != null) r'city': city,
        if (dob != null) r'dob': dob,
        if (ssn_last_4 != null) r'ssn_last_4': ssn_last_4,
        if (country != null) r'country': country,
        if (currency != null) r'currency': currency,
        if (stripe_bank_id != null) r'stripe_bank_id': stripe_bank_id,
        if (stripe_bank_token != null) r'stripe_bank_token': stripe_bank_token,
      });

  Input$AddAccountDetailInput._(this._$data);

  factory Input$AddAccountDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('account_holder_name')) {
      final l$account_holder_name = data['account_holder_name'];
      result$data['account_holder_name'] = (l$account_holder_name as String?);
    }
    if (data.containsKey('account_holder_type')) {
      final l$account_holder_type = data['account_holder_type'];
      result$data['account_holder_type'] = (l$account_holder_type as String?);
    }
    if (data.containsKey('routing_number')) {
      final l$routing_number = data['routing_number'];
      result$data['routing_number'] = (l$routing_number as String?);
    }
    if (data.containsKey('account_number')) {
      final l$account_number = data['account_number'];
      result$data['account_number'] = (l$account_number as String?);
    }
    if (data.containsKey('first_name')) {
      final l$first_name = data['first_name'];
      result$data['first_name'] = (l$first_name as String?);
    }
    if (data.containsKey('last_name')) {
      final l$last_name = data['last_name'];
      result$data['last_name'] = (l$last_name as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('dob')) {
      final l$dob = data['dob'];
      result$data['dob'] = (l$dob as String?);
    }
    if (data.containsKey('ssn_last_4')) {
      final l$ssn_last_4 = data['ssn_last_4'];
      result$data['ssn_last_4'] = (l$ssn_last_4 as String?);
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = (l$currency as String?);
    }
    if (data.containsKey('stripe_bank_id')) {
      final l$stripe_bank_id = data['stripe_bank_id'];
      result$data['stripe_bank_id'] = (l$stripe_bank_id as String?);
    }
    if (data.containsKey('stripe_bank_token')) {
      final l$stripe_bank_token = data['stripe_bank_token'];
      result$data['stripe_bank_token'] = (l$stripe_bank_token as String?);
    }
    return Input$AddAccountDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get account_holder_name => (_$data['account_holder_name'] as String?);

  String? get account_holder_type => (_$data['account_holder_type'] as String?);

  String? get routing_number => (_$data['routing_number'] as String?);

  String? get account_number => (_$data['account_number'] as String?);

  String? get first_name => (_$data['first_name'] as String?);

  String? get last_name => (_$data['last_name'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get dob => (_$data['dob'] as String?);

  String? get ssn_last_4 => (_$data['ssn_last_4'] as String?);

  String? get country => (_$data['country'] as String?);

  String? get currency => (_$data['currency'] as String?);

  String? get stripe_bank_id => (_$data['stripe_bank_id'] as String?);

  String? get stripe_bank_token => (_$data['stripe_bank_token'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('account_holder_name')) {
      final l$account_holder_name = account_holder_name;
      result$data['account_holder_name'] = l$account_holder_name;
    }
    if (_$data.containsKey('account_holder_type')) {
      final l$account_holder_type = account_holder_type;
      result$data['account_holder_type'] = l$account_holder_type;
    }
    if (_$data.containsKey('routing_number')) {
      final l$routing_number = routing_number;
      result$data['routing_number'] = l$routing_number;
    }
    if (_$data.containsKey('account_number')) {
      final l$account_number = account_number;
      result$data['account_number'] = l$account_number;
    }
    if (_$data.containsKey('first_name')) {
      final l$first_name = first_name;
      result$data['first_name'] = l$first_name;
    }
    if (_$data.containsKey('last_name')) {
      final l$last_name = last_name;
      result$data['last_name'] = l$last_name;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('dob')) {
      final l$dob = dob;
      result$data['dob'] = l$dob;
    }
    if (_$data.containsKey('ssn_last_4')) {
      final l$ssn_last_4 = ssn_last_4;
      result$data['ssn_last_4'] = l$ssn_last_4;
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency;
    }
    if (_$data.containsKey('stripe_bank_id')) {
      final l$stripe_bank_id = stripe_bank_id;
      result$data['stripe_bank_id'] = l$stripe_bank_id;
    }
    if (_$data.containsKey('stripe_bank_token')) {
      final l$stripe_bank_token = stripe_bank_token;
      result$data['stripe_bank_token'] = l$stripe_bank_token;
    }
    return result$data;
  }

  CopyWith$Input$AddAccountDetailInput<Input$AddAccountDetailInput>
      get copyWith => CopyWith$Input$AddAccountDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAccountDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$account_holder_name = account_holder_name;
    final lOther$account_holder_name = other.account_holder_name;
    if (_$data.containsKey('account_holder_name') !=
        other._$data.containsKey('account_holder_name')) {
      return false;
    }
    if (l$account_holder_name != lOther$account_holder_name) {
      return false;
    }
    final l$account_holder_type = account_holder_type;
    final lOther$account_holder_type = other.account_holder_type;
    if (_$data.containsKey('account_holder_type') !=
        other._$data.containsKey('account_holder_type')) {
      return false;
    }
    if (l$account_holder_type != lOther$account_holder_type) {
      return false;
    }
    final l$routing_number = routing_number;
    final lOther$routing_number = other.routing_number;
    if (_$data.containsKey('routing_number') !=
        other._$data.containsKey('routing_number')) {
      return false;
    }
    if (l$routing_number != lOther$routing_number) {
      return false;
    }
    final l$account_number = account_number;
    final lOther$account_number = other.account_number;
    if (_$data.containsKey('account_number') !=
        other._$data.containsKey('account_number')) {
      return false;
    }
    if (l$account_number != lOther$account_number) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (_$data.containsKey('first_name') !=
        other._$data.containsKey('first_name')) {
      return false;
    }
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (_$data.containsKey('last_name') !=
        other._$data.containsKey('last_name')) {
      return false;
    }
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$dob = dob;
    final lOther$dob = other.dob;
    if (_$data.containsKey('dob') != other._$data.containsKey('dob')) {
      return false;
    }
    if (l$dob != lOther$dob) {
      return false;
    }
    final l$ssn_last_4 = ssn_last_4;
    final lOther$ssn_last_4 = other.ssn_last_4;
    if (_$data.containsKey('ssn_last_4') !=
        other._$data.containsKey('ssn_last_4')) {
      return false;
    }
    if (l$ssn_last_4 != lOther$ssn_last_4) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$stripe_bank_id = stripe_bank_id;
    final lOther$stripe_bank_id = other.stripe_bank_id;
    if (_$data.containsKey('stripe_bank_id') !=
        other._$data.containsKey('stripe_bank_id')) {
      return false;
    }
    if (l$stripe_bank_id != lOther$stripe_bank_id) {
      return false;
    }
    final l$stripe_bank_token = stripe_bank_token;
    final lOther$stripe_bank_token = other.stripe_bank_token;
    if (_$data.containsKey('stripe_bank_token') !=
        other._$data.containsKey('stripe_bank_token')) {
      return false;
    }
    if (l$stripe_bank_token != lOther$stripe_bank_token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$account_holder_name = account_holder_name;
    final l$account_holder_type = account_holder_type;
    final l$routing_number = routing_number;
    final l$account_number = account_number;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$city = city;
    final l$dob = dob;
    final l$ssn_last_4 = ssn_last_4;
    final l$country = country;
    final l$currency = currency;
    final l$stripe_bank_id = stripe_bank_id;
    final l$stripe_bank_token = stripe_bank_token;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('account_holder_name')
          ? l$account_holder_name
          : const {},
      _$data.containsKey('account_holder_type')
          ? l$account_holder_type
          : const {},
      _$data.containsKey('routing_number') ? l$routing_number : const {},
      _$data.containsKey('account_number') ? l$account_number : const {},
      _$data.containsKey('first_name') ? l$first_name : const {},
      _$data.containsKey('last_name') ? l$last_name : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('dob') ? l$dob : const {},
      _$data.containsKey('ssn_last_4') ? l$ssn_last_4 : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('stripe_bank_id') ? l$stripe_bank_id : const {},
      _$data.containsKey('stripe_bank_token') ? l$stripe_bank_token : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddAccountDetailInput<TRes> {
  factory CopyWith$Input$AddAccountDetailInput(
    Input$AddAccountDetailInput instance,
    TRes Function(Input$AddAccountDetailInput) then,
  ) = _CopyWithImpl$Input$AddAccountDetailInput;

  factory CopyWith$Input$AddAccountDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAccountDetailInput;

  TRes call({
    String? version,
    String? platform,
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  });
}

class _CopyWithImpl$Input$AddAccountDetailInput<TRes>
    implements CopyWith$Input$AddAccountDetailInput<TRes> {
  _CopyWithImpl$Input$AddAccountDetailInput(
    this._instance,
    this._then,
  );

  final Input$AddAccountDetailInput _instance;

  final TRes Function(Input$AddAccountDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? account_holder_name = _undefined,
    Object? account_holder_type = _undefined,
    Object? routing_number = _undefined,
    Object? account_number = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? city = _undefined,
    Object? dob = _undefined,
    Object? ssn_last_4 = _undefined,
    Object? country = _undefined,
    Object? currency = _undefined,
    Object? stripe_bank_id = _undefined,
    Object? stripe_bank_token = _undefined,
  }) =>
      _then(Input$AddAccountDetailInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (account_holder_name != _undefined)
          'account_holder_name': (account_holder_name as String?),
        if (account_holder_type != _undefined)
          'account_holder_type': (account_holder_type as String?),
        if (routing_number != _undefined)
          'routing_number': (routing_number as String?),
        if (account_number != _undefined)
          'account_number': (account_number as String?),
        if (first_name != _undefined) 'first_name': (first_name as String?),
        if (last_name != _undefined) 'last_name': (last_name as String?),
        if (city != _undefined) 'city': (city as String?),
        if (dob != _undefined) 'dob': (dob as String?),
        if (ssn_last_4 != _undefined) 'ssn_last_4': (ssn_last_4 as String?),
        if (country != _undefined) 'country': (country as String?),
        if (currency != _undefined) 'currency': (currency as String?),
        if (stripe_bank_id != _undefined)
          'stripe_bank_id': (stripe_bank_id as String?),
        if (stripe_bank_token != _undefined)
          'stripe_bank_token': (stripe_bank_token as String?),
      }));
}

class _CopyWithStubImpl$Input$AddAccountDetailInput<TRes>
    implements CopyWith$Input$AddAccountDetailInput<TRes> {
  _CopyWithStubImpl$Input$AddAccountDetailInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  }) =>
      _res;
}

class Input$CommentLikeInput {
  factory Input$CommentLikeInput({
    String? comment_uuid,
    bool? is_like,
  }) =>
      Input$CommentLikeInput._({
        if (comment_uuid != null) r'comment_uuid': comment_uuid,
        if (is_like != null) r'is_like': is_like,
      });

  Input$CommentLikeInput._(this._$data);

  factory Input$CommentLikeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('comment_uuid')) {
      final l$comment_uuid = data['comment_uuid'];
      result$data['comment_uuid'] = (l$comment_uuid as String?);
    }
    if (data.containsKey('is_like')) {
      final l$is_like = data['is_like'];
      result$data['is_like'] = (l$is_like as bool?);
    }
    return Input$CommentLikeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get comment_uuid => (_$data['comment_uuid'] as String?);

  bool? get is_like => (_$data['is_like'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('comment_uuid')) {
      final l$comment_uuid = comment_uuid;
      result$data['comment_uuid'] = l$comment_uuid;
    }
    if (_$data.containsKey('is_like')) {
      final l$is_like = is_like;
      result$data['is_like'] = l$is_like;
    }
    return result$data;
  }

  CopyWith$Input$CommentLikeInput<Input$CommentLikeInput> get copyWith =>
      CopyWith$Input$CommentLikeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommentLikeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$comment_uuid = comment_uuid;
    final lOther$comment_uuid = other.comment_uuid;
    if (_$data.containsKey('comment_uuid') !=
        other._$data.containsKey('comment_uuid')) {
      return false;
    }
    if (l$comment_uuid != lOther$comment_uuid) {
      return false;
    }
    final l$is_like = is_like;
    final lOther$is_like = other.is_like;
    if (_$data.containsKey('is_like') != other._$data.containsKey('is_like')) {
      return false;
    }
    if (l$is_like != lOther$is_like) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$comment_uuid = comment_uuid;
    final l$is_like = is_like;
    return Object.hashAll([
      _$data.containsKey('comment_uuid') ? l$comment_uuid : const {},
      _$data.containsKey('is_like') ? l$is_like : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommentLikeInput<TRes> {
  factory CopyWith$Input$CommentLikeInput(
    Input$CommentLikeInput instance,
    TRes Function(Input$CommentLikeInput) then,
  ) = _CopyWithImpl$Input$CommentLikeInput;

  factory CopyWith$Input$CommentLikeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommentLikeInput;

  TRes call({
    String? comment_uuid,
    bool? is_like,
  });
}

class _CopyWithImpl$Input$CommentLikeInput<TRes>
    implements CopyWith$Input$CommentLikeInput<TRes> {
  _CopyWithImpl$Input$CommentLikeInput(
    this._instance,
    this._then,
  );

  final Input$CommentLikeInput _instance;

  final TRes Function(Input$CommentLikeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? comment_uuid = _undefined,
    Object? is_like = _undefined,
  }) =>
      _then(Input$CommentLikeInput._({
        ..._instance._$data,
        if (comment_uuid != _undefined)
          'comment_uuid': (comment_uuid as String?),
        if (is_like != _undefined) 'is_like': (is_like as bool?),
      }));
}

class _CopyWithStubImpl$Input$CommentLikeInput<TRes>
    implements CopyWith$Input$CommentLikeInput<TRes> {
  _CopyWithStubImpl$Input$CommentLikeInput(this._res);

  TRes _res;

  call({
    String? comment_uuid,
    bool? is_like,
  }) =>
      _res;
}

class Input$ViewAccountDetailInput {
  factory Input$ViewAccountDetailInput({required String uuid}) =>
      Input$ViewAccountDetailInput._({
        r'uuid': uuid,
      });

  Input$ViewAccountDetailInput._(this._$data);

  factory Input$ViewAccountDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$ViewAccountDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$ViewAccountDetailInput<Input$ViewAccountDetailInput>
      get copyWith => CopyWith$Input$ViewAccountDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ViewAccountDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$ViewAccountDetailInput<TRes> {
  factory CopyWith$Input$ViewAccountDetailInput(
    Input$ViewAccountDetailInput instance,
    TRes Function(Input$ViewAccountDetailInput) then,
  ) = _CopyWithImpl$Input$ViewAccountDetailInput;

  factory CopyWith$Input$ViewAccountDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ViewAccountDetailInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$ViewAccountDetailInput<TRes>
    implements CopyWith$Input$ViewAccountDetailInput<TRes> {
  _CopyWithImpl$Input$ViewAccountDetailInput(
    this._instance,
    this._then,
  );

  final Input$ViewAccountDetailInput _instance;

  final TRes Function(Input$ViewAccountDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$ViewAccountDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$ViewAccountDetailInput<TRes>
    implements CopyWith$Input$ViewAccountDetailInput<TRes> {
  _CopyWithStubImpl$Input$ViewAccountDetailInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AccountDetailUpdateInput {
  factory Input$AccountDetailUpdateInput({
    required String uuid,
    String? version,
    String? platform,
    String? account_number,
    String? account_holder_name,
    String? account_holder_type,
    String? ssn,
    String? country,
    String? state,
    String? city,
    String? routing_number,
  }) =>
      Input$AccountDetailUpdateInput._({
        r'uuid': uuid,
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (account_number != null) r'account_number': account_number,
        if (account_holder_name != null)
          r'account_holder_name': account_holder_name,
        if (account_holder_type != null)
          r'account_holder_type': account_holder_type,
        if (ssn != null) r'ssn': ssn,
        if (country != null) r'country': country,
        if (state != null) r'state': state,
        if (city != null) r'city': city,
        if (routing_number != null) r'routing_number': routing_number,
      });

  Input$AccountDetailUpdateInput._(this._$data);

  factory Input$AccountDetailUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('account_number')) {
      final l$account_number = data['account_number'];
      result$data['account_number'] = (l$account_number as String?);
    }
    if (data.containsKey('account_holder_name')) {
      final l$account_holder_name = data['account_holder_name'];
      result$data['account_holder_name'] = (l$account_holder_name as String?);
    }
    if (data.containsKey('account_holder_type')) {
      final l$account_holder_type = data['account_holder_type'];
      result$data['account_holder_type'] = (l$account_holder_type as String?);
    }
    if (data.containsKey('ssn')) {
      final l$ssn = data['ssn'];
      result$data['ssn'] = (l$ssn as String?);
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('routing_number')) {
      final l$routing_number = data['routing_number'];
      result$data['routing_number'] = (l$routing_number as String?);
    }
    return Input$AccountDetailUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get account_number => (_$data['account_number'] as String?);

  String? get account_holder_name => (_$data['account_holder_name'] as String?);

  String? get account_holder_type => (_$data['account_holder_type'] as String?);

  String? get ssn => (_$data['ssn'] as String?);

  String? get country => (_$data['country'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get routing_number => (_$data['routing_number'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('account_number')) {
      final l$account_number = account_number;
      result$data['account_number'] = l$account_number;
    }
    if (_$data.containsKey('account_holder_name')) {
      final l$account_holder_name = account_holder_name;
      result$data['account_holder_name'] = l$account_holder_name;
    }
    if (_$data.containsKey('account_holder_type')) {
      final l$account_holder_type = account_holder_type;
      result$data['account_holder_type'] = l$account_holder_type;
    }
    if (_$data.containsKey('ssn')) {
      final l$ssn = ssn;
      result$data['ssn'] = l$ssn;
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('routing_number')) {
      final l$routing_number = routing_number;
      result$data['routing_number'] = l$routing_number;
    }
    return result$data;
  }

  CopyWith$Input$AccountDetailUpdateInput<Input$AccountDetailUpdateInput>
      get copyWith => CopyWith$Input$AccountDetailUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountDetailUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$account_number = account_number;
    final lOther$account_number = other.account_number;
    if (_$data.containsKey('account_number') !=
        other._$data.containsKey('account_number')) {
      return false;
    }
    if (l$account_number != lOther$account_number) {
      return false;
    }
    final l$account_holder_name = account_holder_name;
    final lOther$account_holder_name = other.account_holder_name;
    if (_$data.containsKey('account_holder_name') !=
        other._$data.containsKey('account_holder_name')) {
      return false;
    }
    if (l$account_holder_name != lOther$account_holder_name) {
      return false;
    }
    final l$account_holder_type = account_holder_type;
    final lOther$account_holder_type = other.account_holder_type;
    if (_$data.containsKey('account_holder_type') !=
        other._$data.containsKey('account_holder_type')) {
      return false;
    }
    if (l$account_holder_type != lOther$account_holder_type) {
      return false;
    }
    final l$ssn = ssn;
    final lOther$ssn = other.ssn;
    if (_$data.containsKey('ssn') != other._$data.containsKey('ssn')) {
      return false;
    }
    if (l$ssn != lOther$ssn) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$routing_number = routing_number;
    final lOther$routing_number = other.routing_number;
    if (_$data.containsKey('routing_number') !=
        other._$data.containsKey('routing_number')) {
      return false;
    }
    if (l$routing_number != lOther$routing_number) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$version = version;
    final l$platform = platform;
    final l$account_number = account_number;
    final l$account_holder_name = account_holder_name;
    final l$account_holder_type = account_holder_type;
    final l$ssn = ssn;
    final l$country = country;
    final l$state = state;
    final l$city = city;
    final l$routing_number = routing_number;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('account_number') ? l$account_number : const {},
      _$data.containsKey('account_holder_name')
          ? l$account_holder_name
          : const {},
      _$data.containsKey('account_holder_type')
          ? l$account_holder_type
          : const {},
      _$data.containsKey('ssn') ? l$ssn : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('routing_number') ? l$routing_number : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountDetailUpdateInput<TRes> {
  factory CopyWith$Input$AccountDetailUpdateInput(
    Input$AccountDetailUpdateInput instance,
    TRes Function(Input$AccountDetailUpdateInput) then,
  ) = _CopyWithImpl$Input$AccountDetailUpdateInput;

  factory CopyWith$Input$AccountDetailUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountDetailUpdateInput;

  TRes call({
    String? uuid,
    String? version,
    String? platform,
    String? account_number,
    String? account_holder_name,
    String? account_holder_type,
    String? ssn,
    String? country,
    String? state,
    String? city,
    String? routing_number,
  });
}

class _CopyWithImpl$Input$AccountDetailUpdateInput<TRes>
    implements CopyWith$Input$AccountDetailUpdateInput<TRes> {
  _CopyWithImpl$Input$AccountDetailUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AccountDetailUpdateInput _instance;

  final TRes Function(Input$AccountDetailUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? account_number = _undefined,
    Object? account_holder_name = _undefined,
    Object? account_holder_type = _undefined,
    Object? ssn = _undefined,
    Object? country = _undefined,
    Object? state = _undefined,
    Object? city = _undefined,
    Object? routing_number = _undefined,
  }) =>
      _then(Input$AccountDetailUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (account_number != _undefined)
          'account_number': (account_number as String?),
        if (account_holder_name != _undefined)
          'account_holder_name': (account_holder_name as String?),
        if (account_holder_type != _undefined)
          'account_holder_type': (account_holder_type as String?),
        if (ssn != _undefined) 'ssn': (ssn as String?),
        if (country != _undefined) 'country': (country as String?),
        if (state != _undefined) 'state': (state as String?),
        if (city != _undefined) 'city': (city as String?),
        if (routing_number != _undefined)
          'routing_number': (routing_number as String?),
      }));
}

class _CopyWithStubImpl$Input$AccountDetailUpdateInput<TRes>
    implements CopyWith$Input$AccountDetailUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AccountDetailUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? version,
    String? platform,
    String? account_number,
    String? account_holder_name,
    String? account_holder_type,
    String? ssn,
    String? country,
    String? state,
    String? city,
    String? routing_number,
  }) =>
      _res;
}

class Input$AccountDetailPaginationInput {
  factory Input$AccountDetailPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$AccountDetailPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$AccountDetailPaginationInput._(this._$data);

  factory Input$AccountDetailPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$AccountDetailPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$AccountDetailPaginationInput<
          Input$AccountDetailPaginationInput>
      get copyWith => CopyWith$Input$AccountDetailPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountDetailPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountDetailPaginationInput<TRes> {
  factory CopyWith$Input$AccountDetailPaginationInput(
    Input$AccountDetailPaginationInput instance,
    TRes Function(Input$AccountDetailPaginationInput) then,
  ) = _CopyWithImpl$Input$AccountDetailPaginationInput;

  factory CopyWith$Input$AccountDetailPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountDetailPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$AccountDetailPaginationInput<TRes>
    implements CopyWith$Input$AccountDetailPaginationInput<TRes> {
  _CopyWithImpl$Input$AccountDetailPaginationInput(
    this._instance,
    this._then,
  );

  final Input$AccountDetailPaginationInput _instance;

  final TRes Function(Input$AccountDetailPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$AccountDetailPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$AccountDetailPaginationInput<TRes>
    implements CopyWith$Input$AccountDetailPaginationInput<TRes> {
  _CopyWithStubImpl$Input$AccountDetailPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$AddCardDetailInput {
  factory Input$AddCardDetailInput({
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? card_exp_month,
    String? card_exp_year,
    String? brand,
    String? token_id,
    String? card_id,
    String? country_code,
  }) =>
      Input$AddCardDetailInput._({
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (card_holder_name != null) r'card_holder_name': card_holder_name,
        if (card_number != null) r'card_number': card_number,
        if (cvv != null) r'cvv': cvv,
        if (card_exp_month != null) r'card_exp_month': card_exp_month,
        if (card_exp_year != null) r'card_exp_year': card_exp_year,
        if (brand != null) r'brand': brand,
        if (token_id != null) r'token_id': token_id,
        if (card_id != null) r'card_id': card_id,
        if (country_code != null) r'country_code': country_code,
      });

  Input$AddCardDetailInput._(this._$data);

  factory Input$AddCardDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('card_holder_name')) {
      final l$card_holder_name = data['card_holder_name'];
      result$data['card_holder_name'] = (l$card_holder_name as String?);
    }
    if (data.containsKey('card_number')) {
      final l$card_number = data['card_number'];
      result$data['card_number'] = (l$card_number as String?);
    }
    if (data.containsKey('cvv')) {
      final l$cvv = data['cvv'];
      result$data['cvv'] = (l$cvv as String?);
    }
    if (data.containsKey('card_exp_month')) {
      final l$card_exp_month = data['card_exp_month'];
      result$data['card_exp_month'] = (l$card_exp_month as String?);
    }
    if (data.containsKey('card_exp_year')) {
      final l$card_exp_year = data['card_exp_year'];
      result$data['card_exp_year'] = (l$card_exp_year as String?);
    }
    if (data.containsKey('brand')) {
      final l$brand = data['brand'];
      result$data['brand'] = (l$brand as String?);
    }
    if (data.containsKey('token_id')) {
      final l$token_id = data['token_id'];
      result$data['token_id'] = (l$token_id as String?);
    }
    if (data.containsKey('card_id')) {
      final l$card_id = data['card_id'];
      result$data['card_id'] = (l$card_id as String?);
    }
    if (data.containsKey('country_code')) {
      final l$country_code = data['country_code'];
      result$data['country_code'] = (l$country_code as String?);
    }
    return Input$AddCardDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get card_holder_name => (_$data['card_holder_name'] as String?);

  String? get card_number => (_$data['card_number'] as String?);

  String? get cvv => (_$data['cvv'] as String?);

  String? get card_exp_month => (_$data['card_exp_month'] as String?);

  String? get card_exp_year => (_$data['card_exp_year'] as String?);

  String? get brand => (_$data['brand'] as String?);

  String? get token_id => (_$data['token_id'] as String?);

  String? get card_id => (_$data['card_id'] as String?);

  String? get country_code => (_$data['country_code'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('card_holder_name')) {
      final l$card_holder_name = card_holder_name;
      result$data['card_holder_name'] = l$card_holder_name;
    }
    if (_$data.containsKey('card_number')) {
      final l$card_number = card_number;
      result$data['card_number'] = l$card_number;
    }
    if (_$data.containsKey('cvv')) {
      final l$cvv = cvv;
      result$data['cvv'] = l$cvv;
    }
    if (_$data.containsKey('card_exp_month')) {
      final l$card_exp_month = card_exp_month;
      result$data['card_exp_month'] = l$card_exp_month;
    }
    if (_$data.containsKey('card_exp_year')) {
      final l$card_exp_year = card_exp_year;
      result$data['card_exp_year'] = l$card_exp_year;
    }
    if (_$data.containsKey('brand')) {
      final l$brand = brand;
      result$data['brand'] = l$brand;
    }
    if (_$data.containsKey('token_id')) {
      final l$token_id = token_id;
      result$data['token_id'] = l$token_id;
    }
    if (_$data.containsKey('card_id')) {
      final l$card_id = card_id;
      result$data['card_id'] = l$card_id;
    }
    if (_$data.containsKey('country_code')) {
      final l$country_code = country_code;
      result$data['country_code'] = l$country_code;
    }
    return result$data;
  }

  CopyWith$Input$AddCardDetailInput<Input$AddCardDetailInput> get copyWith =>
      CopyWith$Input$AddCardDetailInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddCardDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$card_holder_name = card_holder_name;
    final lOther$card_holder_name = other.card_holder_name;
    if (_$data.containsKey('card_holder_name') !=
        other._$data.containsKey('card_holder_name')) {
      return false;
    }
    if (l$card_holder_name != lOther$card_holder_name) {
      return false;
    }
    final l$card_number = card_number;
    final lOther$card_number = other.card_number;
    if (_$data.containsKey('card_number') !=
        other._$data.containsKey('card_number')) {
      return false;
    }
    if (l$card_number != lOther$card_number) {
      return false;
    }
    final l$cvv = cvv;
    final lOther$cvv = other.cvv;
    if (_$data.containsKey('cvv') != other._$data.containsKey('cvv')) {
      return false;
    }
    if (l$cvv != lOther$cvv) {
      return false;
    }
    final l$card_exp_month = card_exp_month;
    final lOther$card_exp_month = other.card_exp_month;
    if (_$data.containsKey('card_exp_month') !=
        other._$data.containsKey('card_exp_month')) {
      return false;
    }
    if (l$card_exp_month != lOther$card_exp_month) {
      return false;
    }
    final l$card_exp_year = card_exp_year;
    final lOther$card_exp_year = other.card_exp_year;
    if (_$data.containsKey('card_exp_year') !=
        other._$data.containsKey('card_exp_year')) {
      return false;
    }
    if (l$card_exp_year != lOther$card_exp_year) {
      return false;
    }
    final l$brand = brand;
    final lOther$brand = other.brand;
    if (_$data.containsKey('brand') != other._$data.containsKey('brand')) {
      return false;
    }
    if (l$brand != lOther$brand) {
      return false;
    }
    final l$token_id = token_id;
    final lOther$token_id = other.token_id;
    if (_$data.containsKey('token_id') !=
        other._$data.containsKey('token_id')) {
      return false;
    }
    if (l$token_id != lOther$token_id) {
      return false;
    }
    final l$card_id = card_id;
    final lOther$card_id = other.card_id;
    if (_$data.containsKey('card_id') != other._$data.containsKey('card_id')) {
      return false;
    }
    if (l$card_id != lOther$card_id) {
      return false;
    }
    final l$country_code = country_code;
    final lOther$country_code = other.country_code;
    if (_$data.containsKey('country_code') !=
        other._$data.containsKey('country_code')) {
      return false;
    }
    if (l$country_code != lOther$country_code) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$version = version;
    final l$platform = platform;
    final l$card_holder_name = card_holder_name;
    final l$card_number = card_number;
    final l$cvv = cvv;
    final l$card_exp_month = card_exp_month;
    final l$card_exp_year = card_exp_year;
    final l$brand = brand;
    final l$token_id = token_id;
    final l$card_id = card_id;
    final l$country_code = country_code;
    return Object.hashAll([
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('card_holder_name') ? l$card_holder_name : const {},
      _$data.containsKey('card_number') ? l$card_number : const {},
      _$data.containsKey('cvv') ? l$cvv : const {},
      _$data.containsKey('card_exp_month') ? l$card_exp_month : const {},
      _$data.containsKey('card_exp_year') ? l$card_exp_year : const {},
      _$data.containsKey('brand') ? l$brand : const {},
      _$data.containsKey('token_id') ? l$token_id : const {},
      _$data.containsKey('card_id') ? l$card_id : const {},
      _$data.containsKey('country_code') ? l$country_code : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddCardDetailInput<TRes> {
  factory CopyWith$Input$AddCardDetailInput(
    Input$AddCardDetailInput instance,
    TRes Function(Input$AddCardDetailInput) then,
  ) = _CopyWithImpl$Input$AddCardDetailInput;

  factory CopyWith$Input$AddCardDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCardDetailInput;

  TRes call({
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? card_exp_month,
    String? card_exp_year,
    String? brand,
    String? token_id,
    String? card_id,
    String? country_code,
  });
}

class _CopyWithImpl$Input$AddCardDetailInput<TRes>
    implements CopyWith$Input$AddCardDetailInput<TRes> {
  _CopyWithImpl$Input$AddCardDetailInput(
    this._instance,
    this._then,
  );

  final Input$AddCardDetailInput _instance;

  final TRes Function(Input$AddCardDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? card_holder_name = _undefined,
    Object? card_number = _undefined,
    Object? cvv = _undefined,
    Object? card_exp_month = _undefined,
    Object? card_exp_year = _undefined,
    Object? brand = _undefined,
    Object? token_id = _undefined,
    Object? card_id = _undefined,
    Object? country_code = _undefined,
  }) =>
      _then(Input$AddCardDetailInput._({
        ..._instance._$data,
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (card_holder_name != _undefined)
          'card_holder_name': (card_holder_name as String?),
        if (card_number != _undefined) 'card_number': (card_number as String?),
        if (cvv != _undefined) 'cvv': (cvv as String?),
        if (card_exp_month != _undefined)
          'card_exp_month': (card_exp_month as String?),
        if (card_exp_year != _undefined)
          'card_exp_year': (card_exp_year as String?),
        if (brand != _undefined) 'brand': (brand as String?),
        if (token_id != _undefined) 'token_id': (token_id as String?),
        if (card_id != _undefined) 'card_id': (card_id as String?),
        if (country_code != _undefined)
          'country_code': (country_code as String?),
      }));
}

class _CopyWithStubImpl$Input$AddCardDetailInput<TRes>
    implements CopyWith$Input$AddCardDetailInput<TRes> {
  _CopyWithStubImpl$Input$AddCardDetailInput(this._res);

  TRes _res;

  call({
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? card_exp_month,
    String? card_exp_year,
    String? brand,
    String? token_id,
    String? card_id,
    String? country_code,
  }) =>
      _res;
}

class Input$AccountCardUpdateInput {
  factory Input$AccountCardUpdateInput({
    required String uuid,
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? expiry_date,
  }) =>
      Input$AccountCardUpdateInput._({
        r'uuid': uuid,
        if (version != null) r'version': version,
        if (platform != null) r'platform': platform,
        if (card_holder_name != null) r'card_holder_name': card_holder_name,
        if (card_number != null) r'card_number': card_number,
        if (cvv != null) r'cvv': cvv,
        if (expiry_date != null) r'expiry_date': expiry_date,
      });

  Input$AccountCardUpdateInput._(this._$data);

  factory Input$AccountCardUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('card_holder_name')) {
      final l$card_holder_name = data['card_holder_name'];
      result$data['card_holder_name'] = (l$card_holder_name as String?);
    }
    if (data.containsKey('card_number')) {
      final l$card_number = data['card_number'];
      result$data['card_number'] = (l$card_number as String?);
    }
    if (data.containsKey('cvv')) {
      final l$cvv = data['cvv'];
      result$data['cvv'] = (l$cvv as String?);
    }
    if (data.containsKey('expiry_date')) {
      final l$expiry_date = data['expiry_date'];
      result$data['expiry_date'] = (l$expiry_date as String?);
    }
    return Input$AccountCardUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get version => (_$data['version'] as String?);

  String? get platform => (_$data['platform'] as String?);

  String? get card_holder_name => (_$data['card_holder_name'] as String?);

  String? get card_number => (_$data['card_number'] as String?);

  String? get cvv => (_$data['cvv'] as String?);

  String? get expiry_date => (_$data['expiry_date'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('card_holder_name')) {
      final l$card_holder_name = card_holder_name;
      result$data['card_holder_name'] = l$card_holder_name;
    }
    if (_$data.containsKey('card_number')) {
      final l$card_number = card_number;
      result$data['card_number'] = l$card_number;
    }
    if (_$data.containsKey('cvv')) {
      final l$cvv = cvv;
      result$data['cvv'] = l$cvv;
    }
    if (_$data.containsKey('expiry_date')) {
      final l$expiry_date = expiry_date;
      result$data['expiry_date'] = l$expiry_date;
    }
    return result$data;
  }

  CopyWith$Input$AccountCardUpdateInput<Input$AccountCardUpdateInput>
      get copyWith => CopyWith$Input$AccountCardUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AccountCardUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$card_holder_name = card_holder_name;
    final lOther$card_holder_name = other.card_holder_name;
    if (_$data.containsKey('card_holder_name') !=
        other._$data.containsKey('card_holder_name')) {
      return false;
    }
    if (l$card_holder_name != lOther$card_holder_name) {
      return false;
    }
    final l$card_number = card_number;
    final lOther$card_number = other.card_number;
    if (_$data.containsKey('card_number') !=
        other._$data.containsKey('card_number')) {
      return false;
    }
    if (l$card_number != lOther$card_number) {
      return false;
    }
    final l$cvv = cvv;
    final lOther$cvv = other.cvv;
    if (_$data.containsKey('cvv') != other._$data.containsKey('cvv')) {
      return false;
    }
    if (l$cvv != lOther$cvv) {
      return false;
    }
    final l$expiry_date = expiry_date;
    final lOther$expiry_date = other.expiry_date;
    if (_$data.containsKey('expiry_date') !=
        other._$data.containsKey('expiry_date')) {
      return false;
    }
    if (l$expiry_date != lOther$expiry_date) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$version = version;
    final l$platform = platform;
    final l$card_holder_name = card_holder_name;
    final l$card_number = card_number;
    final l$cvv = cvv;
    final l$expiry_date = expiry_date;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('card_holder_name') ? l$card_holder_name : const {},
      _$data.containsKey('card_number') ? l$card_number : const {},
      _$data.containsKey('cvv') ? l$cvv : const {},
      _$data.containsKey('expiry_date') ? l$expiry_date : const {},
    ]);
  }
}

abstract class CopyWith$Input$AccountCardUpdateInput<TRes> {
  factory CopyWith$Input$AccountCardUpdateInput(
    Input$AccountCardUpdateInput instance,
    TRes Function(Input$AccountCardUpdateInput) then,
  ) = _CopyWithImpl$Input$AccountCardUpdateInput;

  factory CopyWith$Input$AccountCardUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccountCardUpdateInput;

  TRes call({
    String? uuid,
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? expiry_date,
  });
}

class _CopyWithImpl$Input$AccountCardUpdateInput<TRes>
    implements CopyWith$Input$AccountCardUpdateInput<TRes> {
  _CopyWithImpl$Input$AccountCardUpdateInput(
    this._instance,
    this._then,
  );

  final Input$AccountCardUpdateInput _instance;

  final TRes Function(Input$AccountCardUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? version = _undefined,
    Object? platform = _undefined,
    Object? card_holder_name = _undefined,
    Object? card_number = _undefined,
    Object? cvv = _undefined,
    Object? expiry_date = _undefined,
  }) =>
      _then(Input$AccountCardUpdateInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (version != _undefined) 'version': (version as String?),
        if (platform != _undefined) 'platform': (platform as String?),
        if (card_holder_name != _undefined)
          'card_holder_name': (card_holder_name as String?),
        if (card_number != _undefined) 'card_number': (card_number as String?),
        if (cvv != _undefined) 'cvv': (cvv as String?),
        if (expiry_date != _undefined) 'expiry_date': (expiry_date as String?),
      }));
}

class _CopyWithStubImpl$Input$AccountCardUpdateInput<TRes>
    implements CopyWith$Input$AccountCardUpdateInput<TRes> {
  _CopyWithStubImpl$Input$AccountCardUpdateInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? version,
    String? platform,
    String? card_holder_name,
    String? card_number,
    String? cvv,
    String? expiry_date,
  }) =>
      _res;
}

class Input$BannerTypeInput {
  factory Input$BannerTypeInput({String? bannerType}) =>
      Input$BannerTypeInput._({
        if (bannerType != null) r'bannerType': bannerType,
      });

  Input$BannerTypeInput._(this._$data);

  factory Input$BannerTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bannerType')) {
      final l$bannerType = data['bannerType'];
      result$data['bannerType'] = (l$bannerType as String?);
    }
    return Input$BannerTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get bannerType => (_$data['bannerType'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bannerType')) {
      final l$bannerType = bannerType;
      result$data['bannerType'] = l$bannerType;
    }
    return result$data;
  }

  CopyWith$Input$BannerTypeInput<Input$BannerTypeInput> get copyWith =>
      CopyWith$Input$BannerTypeInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BannerTypeInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bannerType = bannerType;
    final lOther$bannerType = other.bannerType;
    if (_$data.containsKey('bannerType') !=
        other._$data.containsKey('bannerType')) {
      return false;
    }
    if (l$bannerType != lOther$bannerType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bannerType = bannerType;
    return Object.hashAll(
        [_$data.containsKey('bannerType') ? l$bannerType : const {}]);
  }
}

abstract class CopyWith$Input$BannerTypeInput<TRes> {
  factory CopyWith$Input$BannerTypeInput(
    Input$BannerTypeInput instance,
    TRes Function(Input$BannerTypeInput) then,
  ) = _CopyWithImpl$Input$BannerTypeInput;

  factory CopyWith$Input$BannerTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BannerTypeInput;

  TRes call({String? bannerType});
}

class _CopyWithImpl$Input$BannerTypeInput<TRes>
    implements CopyWith$Input$BannerTypeInput<TRes> {
  _CopyWithImpl$Input$BannerTypeInput(
    this._instance,
    this._then,
  );

  final Input$BannerTypeInput _instance;

  final TRes Function(Input$BannerTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? bannerType = _undefined}) =>
      _then(Input$BannerTypeInput._({
        ..._instance._$data,
        if (bannerType != _undefined) 'bannerType': (bannerType as String?),
      }));
}

class _CopyWithStubImpl$Input$BannerTypeInput<TRes>
    implements CopyWith$Input$BannerTypeInput<TRes> {
  _CopyWithStubImpl$Input$BannerTypeInput(this._res);

  TRes _res;

  call({String? bannerType}) => _res;
}

class Input$exportUserPaginationInput {
  factory Input$exportUserPaginationInput({
    required int offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
    int? is_export,
  }) =>
      Input$exportUserPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (full_name != null) r'full_name': full_name,
        if (mobile_number != null) r'mobile_number': mobile_number,
        if (status != null) r'status': status,
        if (gender != null) r'gender': gender,
        if (email != null) r'email': email,
        if (rating != null) r'rating': rating,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (club_id != null) r'club_id': club_id,
        if (state != null) r'state': state,
        if (is_coach != null) r'is_coach': is_coach,
        if (is_export != null) r'is_export': is_export,
      });

  Input$exportUserPaginationInput._(this._$data);

  factory Input$exportUserPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('mobile_number')) {
      final l$mobile_number = data['mobile_number'];
      result$data['mobile_number'] = (l$mobile_number as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('club_id')) {
      final l$club_id = data['club_id'];
      result$data['club_id'] = (l$club_id as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = (l$state as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as String?);
    }
    if (data.containsKey('is_export')) {
      final l$is_export = data['is_export'];
      result$data['is_export'] = (l$is_export as int?);
    }
    return Input$exportUserPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get full_name => (_$data['full_name'] as String?);

  String? get mobile_number => (_$data['mobile_number'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get club_id => (_$data['club_id'] as String?);

  String? get state => (_$data['state'] as String?);

  String? get is_coach => (_$data['is_coach'] as String?);

  int? get is_export => (_$data['is_export'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('mobile_number')) {
      final l$mobile_number = mobile_number;
      result$data['mobile_number'] = l$mobile_number;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('club_id')) {
      final l$club_id = club_id;
      result$data['club_id'] = l$club_id;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] = l$state;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    if (_$data.containsKey('is_export')) {
      final l$is_export = is_export;
      result$data['is_export'] = l$is_export;
    }
    return result$data;
  }

  CopyWith$Input$exportUserPaginationInput<Input$exportUserPaginationInput>
      get copyWith => CopyWith$Input$exportUserPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$exportUserPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$mobile_number = mobile_number;
    final lOther$mobile_number = other.mobile_number;
    if (_$data.containsKey('mobile_number') !=
        other._$data.containsKey('mobile_number')) {
      return false;
    }
    if (l$mobile_number != lOther$mobile_number) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$club_id = club_id;
    final lOther$club_id = other.club_id;
    if (_$data.containsKey('club_id') != other._$data.containsKey('club_id')) {
      return false;
    }
    if (l$club_id != lOther$club_id) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    final l$is_export = is_export;
    final lOther$is_export = other.is_export;
    if (_$data.containsKey('is_export') !=
        other._$data.containsKey('is_export')) {
      return false;
    }
    if (l$is_export != lOther$is_export) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$full_name = full_name;
    final l$mobile_number = mobile_number;
    final l$status = status;
    final l$gender = gender;
    final l$email = email;
    final l$rating = rating;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$club_id = club_id;
    final l$state = state;
    final l$is_coach = is_coach;
    final l$is_export = is_export;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('mobile_number') ? l$mobile_number : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('club_id') ? l$club_id : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
      _$data.containsKey('is_export') ? l$is_export : const {},
    ]);
  }
}

abstract class CopyWith$Input$exportUserPaginationInput<TRes> {
  factory CopyWith$Input$exportUserPaginationInput(
    Input$exportUserPaginationInput instance,
    TRes Function(Input$exportUserPaginationInput) then,
  ) = _CopyWithImpl$Input$exportUserPaginationInput;

  factory CopyWith$Input$exportUserPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$exportUserPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
    int? is_export,
  });
}

class _CopyWithImpl$Input$exportUserPaginationInput<TRes>
    implements CopyWith$Input$exportUserPaginationInput<TRes> {
  _CopyWithImpl$Input$exportUserPaginationInput(
    this._instance,
    this._then,
  );

  final Input$exportUserPaginationInput _instance;

  final TRes Function(Input$exportUserPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? full_name = _undefined,
    Object? mobile_number = _undefined,
    Object? status = _undefined,
    Object? gender = _undefined,
    Object? email = _undefined,
    Object? rating = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? club_id = _undefined,
    Object? state = _undefined,
    Object? is_coach = _undefined,
    Object? is_export = _undefined,
  }) =>
      _then(Input$exportUserPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (mobile_number != _undefined)
          'mobile_number': (mobile_number as String?),
        if (status != _undefined) 'status': (status as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (email != _undefined) 'email': (email as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (club_id != _undefined) 'club_id': (club_id as String?),
        if (state != _undefined) 'state': (state as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as String?),
        if (is_export != _undefined) 'is_export': (is_export as int?),
      }));
}

class _CopyWithStubImpl$Input$exportUserPaginationInput<TRes>
    implements CopyWith$Input$exportUserPaginationInput<TRes> {
  _CopyWithStubImpl$Input$exportUserPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? full_name,
    String? mobile_number,
    String? status,
    String? gender,
    String? email,
    String? rating,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    String? club_id,
    String? state,
    String? is_coach,
    int? is_export,
  }) =>
      _res;
}

class Input$ExportTransactionInput {
  factory Input$ExportTransactionInput({
    required int offset,
    int? limit,
    String? ID,
    int? is_export,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$ExportTransactionInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (ID != null) r'ID': ID,
        if (is_export != null) r'is_export': is_export,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$ExportTransactionInput._(this._$data);

  factory Input$ExportTransactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('ID')) {
      final l$ID = data['ID'];
      result$data['ID'] = (l$ID as String?);
    }
    if (data.containsKey('is_export')) {
      final l$is_export = data['is_export'];
      result$data['is_export'] = (l$is_export as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$ExportTransactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get ID => (_$data['ID'] as String?);

  int? get is_export => (_$data['is_export'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('ID')) {
      final l$ID = ID;
      result$data['ID'] = l$ID;
    }
    if (_$data.containsKey('is_export')) {
      final l$is_export = is_export;
      result$data['is_export'] = l$is_export;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$ExportTransactionInput<Input$ExportTransactionInput>
      get copyWith => CopyWith$Input$ExportTransactionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ExportTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$ID = ID;
    final lOther$ID = other.ID;
    if (_$data.containsKey('ID') != other._$data.containsKey('ID')) {
      return false;
    }
    if (l$ID != lOther$ID) {
      return false;
    }
    final l$is_export = is_export;
    final lOther$is_export = other.is_export;
    if (_$data.containsKey('is_export') !=
        other._$data.containsKey('is_export')) {
      return false;
    }
    if (l$is_export != lOther$is_export) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$ID = ID;
    final l$is_export = is_export;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('ID') ? l$ID : const {},
      _$data.containsKey('is_export') ? l$is_export : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$ExportTransactionInput<TRes> {
  factory CopyWith$Input$ExportTransactionInput(
    Input$ExportTransactionInput instance,
    TRes Function(Input$ExportTransactionInput) then,
  ) = _CopyWithImpl$Input$ExportTransactionInput;

  factory CopyWith$Input$ExportTransactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ExportTransactionInput;

  TRes call({
    int? offset,
    int? limit,
    String? ID,
    int? is_export,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$ExportTransactionInput<TRes>
    implements CopyWith$Input$ExportTransactionInput<TRes> {
  _CopyWithImpl$Input$ExportTransactionInput(
    this._instance,
    this._then,
  );

  final Input$ExportTransactionInput _instance;

  final TRes Function(Input$ExportTransactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? ID = _undefined,
    Object? is_export = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$ExportTransactionInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (ID != _undefined) 'ID': (ID as String?),
        if (is_export != _undefined) 'is_export': (is_export as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$ExportTransactionInput<TRes>
    implements CopyWith$Input$ExportTransactionInput<TRes> {
  _CopyWithStubImpl$Input$ExportTransactionInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? ID,
    int? is_export,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$viewMatchParticipateAdminInput {
  factory Input$viewMatchParticipateAdminInput({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$viewMatchParticipateAdminInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (match_id != null) r'match_id': match_id,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$viewMatchParticipateAdminInput._(this._$data);

  factory Input$viewMatchParticipateAdminInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$viewMatchParticipateAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$viewMatchParticipateAdminInput<
          Input$viewMatchParticipateAdminInput>
      get copyWith => CopyWith$Input$viewMatchParticipateAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewMatchParticipateAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$match_id = match_id;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$viewMatchParticipateAdminInput<TRes> {
  factory CopyWith$Input$viewMatchParticipateAdminInput(
    Input$viewMatchParticipateAdminInput instance,
    TRes Function(Input$viewMatchParticipateAdminInput) then,
  ) = _CopyWithImpl$Input$viewMatchParticipateAdminInput;

  factory CopyWith$Input$viewMatchParticipateAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewMatchParticipateAdminInput;

  TRes call({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$viewMatchParticipateAdminInput<TRes>
    implements CopyWith$Input$viewMatchParticipateAdminInput<TRes> {
  _CopyWithImpl$Input$viewMatchParticipateAdminInput(
    this._instance,
    this._then,
  );

  final Input$viewMatchParticipateAdminInput _instance;

  final TRes Function(Input$viewMatchParticipateAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? match_id = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$viewMatchParticipateAdminInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$viewMatchParticipateAdminInput<TRes>
    implements CopyWith$Input$viewMatchParticipateAdminInput<TRes> {
  _CopyWithStubImpl$Input$viewMatchParticipateAdminInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$scheduleReachoutOrdInfoInput {
  factory Input$scheduleReachoutOrdInfoInput({String? match_id}) =>
      Input$scheduleReachoutOrdInfoInput._({
        if (match_id != null) r'match_id': match_id,
      });

  Input$scheduleReachoutOrdInfoInput._(this._$data);

  factory Input$scheduleReachoutOrdInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$scheduleReachoutOrdInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$scheduleReachoutOrdInfoInput<
          Input$scheduleReachoutOrdInfoInput>
      get copyWith => CopyWith$Input$scheduleReachoutOrdInfoInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$scheduleReachoutOrdInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    return Object.hashAll(
        [_$data.containsKey('match_id') ? l$match_id : const {}]);
  }
}

abstract class CopyWith$Input$scheduleReachoutOrdInfoInput<TRes> {
  factory CopyWith$Input$scheduleReachoutOrdInfoInput(
    Input$scheduleReachoutOrdInfoInput instance,
    TRes Function(Input$scheduleReachoutOrdInfoInput) then,
  ) = _CopyWithImpl$Input$scheduleReachoutOrdInfoInput;

  factory CopyWith$Input$scheduleReachoutOrdInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$scheduleReachoutOrdInfoInput;

  TRes call({String? match_id});
}

class _CopyWithImpl$Input$scheduleReachoutOrdInfoInput<TRes>
    implements CopyWith$Input$scheduleReachoutOrdInfoInput<TRes> {
  _CopyWithImpl$Input$scheduleReachoutOrdInfoInput(
    this._instance,
    this._then,
  );

  final Input$scheduleReachoutOrdInfoInput _instance;

  final TRes Function(Input$scheduleReachoutOrdInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? match_id = _undefined}) =>
      _then(Input$scheduleReachoutOrdInfoInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$scheduleReachoutOrdInfoInput<TRes>
    implements CopyWith$Input$scheduleReachoutOrdInfoInput<TRes> {
  _CopyWithStubImpl$Input$scheduleReachoutOrdInfoInput(this._res);

  TRes _res;

  call({String? match_id}) => _res;
}

class Input$deleteAllInput {
  factory Input$deleteAllInput({
    List<String?>? uuid,
    String? section,
  }) =>
      Input$deleteAllInput._({
        if (uuid != null) r'uuid': uuid,
        if (section != null) r'section': section,
      });

  Input$deleteAllInput._(this._$data);

  factory Input$deleteAllInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          (l$uuid as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('section')) {
      final l$section = data['section'];
      result$data['section'] = (l$section as String?);
    }
    return Input$deleteAllInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get uuid => (_$data['uuid'] as List<String?>?);

  String? get section => (_$data['section'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.map((e) => e).toList();
    }
    if (_$data.containsKey('section')) {
      final l$section = section;
      result$data['section'] = l$section;
    }
    return result$data;
  }

  CopyWith$Input$deleteAllInput<Input$deleteAllInput> get copyWith =>
      CopyWith$Input$deleteAllInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteAllInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != null && lOther$uuid != null) {
      if (l$uuid.length != lOther$uuid.length) {
        return false;
      }
      for (int i = 0; i < l$uuid.length; i++) {
        final l$uuid$entry = l$uuid[i];
        final lOther$uuid$entry = lOther$uuid[i];
        if (l$uuid$entry != lOther$uuid$entry) {
          return false;
        }
      }
    } else if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$section = section;
    final lOther$section = other.section;
    if (_$data.containsKey('section') != other._$data.containsKey('section')) {
      return false;
    }
    if (l$section != lOther$section) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$section = section;
    return Object.hashAll([
      _$data.containsKey('uuid')
          ? l$uuid == null
              ? null
              : Object.hashAll(l$uuid.map((v) => v))
          : const {},
      _$data.containsKey('section') ? l$section : const {},
    ]);
  }
}

abstract class CopyWith$Input$deleteAllInput<TRes> {
  factory CopyWith$Input$deleteAllInput(
    Input$deleteAllInput instance,
    TRes Function(Input$deleteAllInput) then,
  ) = _CopyWithImpl$Input$deleteAllInput;

  factory CopyWith$Input$deleteAllInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteAllInput;

  TRes call({
    List<String?>? uuid,
    String? section,
  });
}

class _CopyWithImpl$Input$deleteAllInput<TRes>
    implements CopyWith$Input$deleteAllInput<TRes> {
  _CopyWithImpl$Input$deleteAllInput(
    this._instance,
    this._then,
  );

  final Input$deleteAllInput _instance;

  final TRes Function(Input$deleteAllInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? section = _undefined,
  }) =>
      _then(Input$deleteAllInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as List<String?>?),
        if (section != _undefined) 'section': (section as String?),
      }));
}

class _CopyWithStubImpl$Input$deleteAllInput<TRes>
    implements CopyWith$Input$deleteAllInput<TRes> {
  _CopyWithStubImpl$Input$deleteAllInput(this._res);

  TRes _res;

  call({
    List<String?>? uuid,
    String? section,
  }) =>
      _res;
}

class Input$exploreNetworkInput {
  factory Input$exploreNetworkInput({
    String? name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? is_coach,
    int? offset,
    int? limit,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$exploreNetworkInput._({
        if (name != null) r'name': name,
        if (rating != null) r'rating': rating,
        if (gender != null) r'gender': gender,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (min_age != null) r'min_age': min_age,
        if (max_age != null) r'max_age': max_age,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (clubs != null) r'clubs': clubs,
        if (recommendation != null) r'recommendation': recommendation,
        if (is_coach != null) r'is_coach': is_coach,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (is_friend != null) r'is_friend': is_friend,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$exploreNetworkInput._(this._$data);

  factory Input$exploreNetworkInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('min_age')) {
      final l$min_age = data['min_age'];
      result$data['min_age'] = (l$min_age as int?);
    }
    if (data.containsKey('max_age')) {
      final l$max_age = data['max_age'];
      result$data['max_age'] = (l$max_age as int?);
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = (l$max as int?);
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = (l$min as int?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as int?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('is_friend')) {
      final l$is_friend = data['is_friend'];
      result$data['is_friend'] = (l$is_friend as bool?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$exploreNetworkInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get gender => (_$data['gender'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  int? get min_age => (_$data['min_age'] as int?);

  int? get max_age => (_$data['max_age'] as int?);

  int? get max => (_$data['max'] as int?);

  int? get min => (_$data['min'] as int?);

  String? get clubs => (_$data['clubs'] as String?);

  String? get recommendation => (_$data['recommendation'] as String?);

  int? get is_coach => (_$data['is_coach'] as int?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  bool? get is_friend => (_$data['is_friend'] as bool?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('min_age')) {
      final l$min_age = min_age;
      result$data['min_age'] = l$min_age;
    }
    if (_$data.containsKey('max_age')) {
      final l$max_age = max_age;
      result$data['max_age'] = l$max_age;
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max;
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('is_friend')) {
      final l$is_friend = is_friend;
      result$data['is_friend'] = l$is_friend;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$exploreNetworkInput<Input$exploreNetworkInput> get copyWith =>
      CopyWith$Input$exploreNetworkInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$exploreNetworkInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$min_age = min_age;
    final lOther$min_age = other.min_age;
    if (_$data.containsKey('min_age') != other._$data.containsKey('min_age')) {
      return false;
    }
    if (l$min_age != lOther$min_age) {
      return false;
    }
    final l$max_age = max_age;
    final lOther$max_age = other.max_age;
    if (_$data.containsKey('max_age') != other._$data.containsKey('max_age')) {
      return false;
    }
    if (l$max_age != lOther$max_age) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$is_friend = is_friend;
    final lOther$is_friend = other.is_friend;
    if (_$data.containsKey('is_friend') !=
        other._$data.containsKey('is_friend')) {
      return false;
    }
    if (l$is_friend != lOther$is_friend) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$rating = rating;
    final l$gender = gender;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$min_age = min_age;
    final l$max_age = max_age;
    final l$max = max;
    final l$min = min;
    final l$clubs = clubs;
    final l$recommendation = recommendation;
    final l$is_coach = is_coach;
    final l$offset = offset;
    final l$limit = limit;
    final l$is_friend = is_friend;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('min_age') ? l$min_age : const {},
      _$data.containsKey('max_age') ? l$max_age : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
      _$data.containsKey('recommendation') ? l$recommendation : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('is_friend') ? l$is_friend : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$exploreNetworkInput<TRes> {
  factory CopyWith$Input$exploreNetworkInput(
    Input$exploreNetworkInput instance,
    TRes Function(Input$exploreNetworkInput) then,
  ) = _CopyWithImpl$Input$exploreNetworkInput;

  factory CopyWith$Input$exploreNetworkInput.stub(TRes res) =
      _CopyWithStubImpl$Input$exploreNetworkInput;

  TRes call({
    String? name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? is_coach,
    int? offset,
    int? limit,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$exploreNetworkInput<TRes>
    implements CopyWith$Input$exploreNetworkInput<TRes> {
  _CopyWithImpl$Input$exploreNetworkInput(
    this._instance,
    this._then,
  );

  final Input$exploreNetworkInput _instance;

  final TRes Function(Input$exploreNetworkInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? rating = _undefined,
    Object? gender = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? min_age = _undefined,
    Object? max_age = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? clubs = _undefined,
    Object? recommendation = _undefined,
    Object? is_coach = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? is_friend = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$exploreNetworkInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (min_age != _undefined) 'min_age': (min_age as int?),
        if (max_age != _undefined) 'max_age': (max_age as int?),
        if (max != _undefined) 'max': (max as int?),
        if (min != _undefined) 'min': (min as int?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
        if (recommendation != _undefined)
          'recommendation': (recommendation as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as int?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (is_friend != _undefined) 'is_friend': (is_friend as bool?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$exploreNetworkInput<TRes>
    implements CopyWith$Input$exploreNetworkInput<TRes> {
  _CopyWithStubImpl$Input$exploreNetworkInput(this._res);

  TRes _res;

  call({
    String? name,
    String? rating,
    String? gender,
    double? latitude,
    double? longitude,
    int? radius,
    int? min_age,
    int? max_age,
    int? max,
    int? min,
    String? clubs,
    String? recommendation,
    int? is_coach,
    int? offset,
    int? limit,
    bool? is_friend,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$CommonGroupPaginationInput {
  factory Input$CommonGroupPaginationInput({
    required int offset,
    int? limit,
    String? user_uuid,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$CommonGroupPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (name != null) r'name': name,
        if (status != null) r'status': status,
        if (group_type != null) r'group_type': group_type,
        if (skill != null) r'skill': skill,
        if (club != null) r'club': club,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$CommonGroupPaginationInput._(this._$data);

  factory Input$CommonGroupPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('group_type')) {
      final l$group_type = data['group_type'];
      result$data['group_type'] = (l$group_type as String?);
    }
    if (data.containsKey('skill')) {
      final l$skill = data['skill'];
      result$data['skill'] = (l$skill as String?);
    }
    if (data.containsKey('club')) {
      final l$club = data['club'];
      result$data['club'] = (l$club as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$CommonGroupPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get group_type => (_$data['group_type'] as String?);

  String? get skill => (_$data['skill'] as String?);

  String? get club => (_$data['club'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('group_type')) {
      final l$group_type = group_type;
      result$data['group_type'] = l$group_type;
    }
    if (_$data.containsKey('skill')) {
      final l$skill = skill;
      result$data['skill'] = l$skill;
    }
    if (_$data.containsKey('club')) {
      final l$club = club;
      result$data['club'] = l$club;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$CommonGroupPaginationInput<Input$CommonGroupPaginationInput>
      get copyWith => CopyWith$Input$CommonGroupPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonGroupPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$group_type = group_type;
    final lOther$group_type = other.group_type;
    if (_$data.containsKey('group_type') !=
        other._$data.containsKey('group_type')) {
      return false;
    }
    if (l$group_type != lOther$group_type) {
      return false;
    }
    final l$skill = skill;
    final lOther$skill = other.skill;
    if (_$data.containsKey('skill') != other._$data.containsKey('skill')) {
      return false;
    }
    if (l$skill != lOther$skill) {
      return false;
    }
    final l$club = club;
    final lOther$club = other.club;
    if (_$data.containsKey('club') != other._$data.containsKey('club')) {
      return false;
    }
    if (l$club != lOther$club) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$user_uuid = user_uuid;
    final l$name = name;
    final l$status = status;
    final l$group_type = group_type;
    final l$skill = skill;
    final l$club = club;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('group_type') ? l$group_type : const {},
      _$data.containsKey('skill') ? l$skill : const {},
      _$data.containsKey('club') ? l$club : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonGroupPaginationInput<TRes> {
  factory CopyWith$Input$CommonGroupPaginationInput(
    Input$CommonGroupPaginationInput instance,
    TRes Function(Input$CommonGroupPaginationInput) then,
  ) = _CopyWithImpl$Input$CommonGroupPaginationInput;

  factory CopyWith$Input$CommonGroupPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonGroupPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? user_uuid,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$CommonGroupPaginationInput<TRes>
    implements CopyWith$Input$CommonGroupPaginationInput<TRes> {
  _CopyWithImpl$Input$CommonGroupPaginationInput(
    this._instance,
    this._then,
  );

  final Input$CommonGroupPaginationInput _instance;

  final TRes Function(Input$CommonGroupPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? user_uuid = _undefined,
    Object? name = _undefined,
    Object? status = _undefined,
    Object? group_type = _undefined,
    Object? skill = _undefined,
    Object? club = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$CommonGroupPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (name != _undefined) 'name': (name as String?),
        if (status != _undefined) 'status': (status as String?),
        if (group_type != _undefined) 'group_type': (group_type as String?),
        if (skill != _undefined) 'skill': (skill as String?),
        if (club != _undefined) 'club': (club as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$CommonGroupPaginationInput<TRes>
    implements CopyWith$Input$CommonGroupPaginationInput<TRes> {
  _CopyWithStubImpl$Input$CommonGroupPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? user_uuid,
    String? name,
    String? status,
    String? group_type,
    String? skill,
    String? club,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$CommonCommentInput {
  factory Input$CommonCommentInput({
    String? uuid,
    String? comment,
    String? parent_id,
    String? type,
    List<Input$CustomCommentMention?>? comment_mentions_users,
  }) =>
      Input$CommonCommentInput._({
        if (uuid != null) r'uuid': uuid,
        if (comment != null) r'comment': comment,
        if (parent_id != null) r'parent_id': parent_id,
        if (type != null) r'type': type,
        if (comment_mentions_users != null)
          r'comment_mentions_users': comment_mentions_users,
      });

  Input$CommonCommentInput._(this._$data);

  factory Input$CommonCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('parent_id')) {
      final l$parent_id = data['parent_id'];
      result$data['parent_id'] = (l$parent_id as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('comment_mentions_users')) {
      final l$comment_mentions_users = data['comment_mentions_users'];
      result$data['comment_mentions_users'] =
          (l$comment_mentions_users as List<dynamic>?)
              ?.map((e) => e == null
                  ? null
                  : Input$CustomCommentMention.fromJson(
                      (e as Map<String, dynamic>)))
              .toList();
    }
    return Input$CommonCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get comment => (_$data['comment'] as String?);

  String? get parent_id => (_$data['parent_id'] as String?);

  String? get type => (_$data['type'] as String?);

  List<Input$CustomCommentMention?>? get comment_mentions_users =>
      (_$data['comment_mentions_users'] as List<Input$CustomCommentMention?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('parent_id')) {
      final l$parent_id = parent_id;
      result$data['parent_id'] = l$parent_id;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('comment_mentions_users')) {
      final l$comment_mentions_users = comment_mentions_users;
      result$data['comment_mentions_users'] =
          l$comment_mentions_users?.map((e) => e?.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CommonCommentInput<Input$CommonCommentInput> get copyWith =>
      CopyWith$Input$CommonCommentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$parent_id = parent_id;
    final lOther$parent_id = other.parent_id;
    if (_$data.containsKey('parent_id') !=
        other._$data.containsKey('parent_id')) {
      return false;
    }
    if (l$parent_id != lOther$parent_id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$comment_mentions_users = comment_mentions_users;
    final lOther$comment_mentions_users = other.comment_mentions_users;
    if (_$data.containsKey('comment_mentions_users') !=
        other._$data.containsKey('comment_mentions_users')) {
      return false;
    }
    if (l$comment_mentions_users != null &&
        lOther$comment_mentions_users != null) {
      if (l$comment_mentions_users.length !=
          lOther$comment_mentions_users.length) {
        return false;
      }
      for (int i = 0; i < l$comment_mentions_users.length; i++) {
        final l$comment_mentions_users$entry = l$comment_mentions_users[i];
        final lOther$comment_mentions_users$entry =
            lOther$comment_mentions_users[i];
        if (l$comment_mentions_users$entry !=
            lOther$comment_mentions_users$entry) {
          return false;
        }
      }
    } else if (l$comment_mentions_users != lOther$comment_mentions_users) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$comment = comment;
    final l$parent_id = parent_id;
    final l$type = type;
    final l$comment_mentions_users = comment_mentions_users;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('parent_id') ? l$parent_id : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('comment_mentions_users')
          ? l$comment_mentions_users == null
              ? null
              : Object.hashAll(l$comment_mentions_users.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonCommentInput<TRes> {
  factory CopyWith$Input$CommonCommentInput(
    Input$CommonCommentInput instance,
    TRes Function(Input$CommonCommentInput) then,
  ) = _CopyWithImpl$Input$CommonCommentInput;

  factory CopyWith$Input$CommonCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonCommentInput;

  TRes call({
    String? uuid,
    String? comment,
    String? parent_id,
    String? type,
    List<Input$CustomCommentMention?>? comment_mentions_users,
  });
  TRes comment_mentions_users(
      Iterable<Input$CustomCommentMention?>? Function(
              Iterable<
                  CopyWith$Input$CustomCommentMention<
                      Input$CustomCommentMention>?>?)
          _fn);
}

class _CopyWithImpl$Input$CommonCommentInput<TRes>
    implements CopyWith$Input$CommonCommentInput<TRes> {
  _CopyWithImpl$Input$CommonCommentInput(
    this._instance,
    this._then,
  );

  final Input$CommonCommentInput _instance;

  final TRes Function(Input$CommonCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? comment = _undefined,
    Object? parent_id = _undefined,
    Object? type = _undefined,
    Object? comment_mentions_users = _undefined,
  }) =>
      _then(Input$CommonCommentInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (parent_id != _undefined) 'parent_id': (parent_id as String?),
        if (type != _undefined) 'type': (type as String?),
        if (comment_mentions_users != _undefined)
          'comment_mentions_users':
              (comment_mentions_users as List<Input$CustomCommentMention?>?),
      }));

  TRes comment_mentions_users(
          Iterable<Input$CustomCommentMention?>? Function(
                  Iterable<
                      CopyWith$Input$CustomCommentMention<
                          Input$CustomCommentMention>?>?)
              _fn) =>
      call(
          comment_mentions_users:
              _fn(_instance.comment_mentions_users?.map((e) => e == null
                  ? null
                  : CopyWith$Input$CustomCommentMention(
                      e,
                      (i) => i,
                    )))?.toList());
}

class _CopyWithStubImpl$Input$CommonCommentInput<TRes>
    implements CopyWith$Input$CommonCommentInput<TRes> {
  _CopyWithStubImpl$Input$CommonCommentInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? comment,
    String? parent_id,
    String? type,
    List<Input$CustomCommentMention?>? comment_mentions_users,
  }) =>
      _res;

  comment_mentions_users(_fn) => _res;
}

class Input$CustomCommentMention {
  factory Input$CustomCommentMention({
    String? full_name,
    String? user_uuid,
  }) =>
      Input$CustomCommentMention._({
        if (full_name != null) r'full_name': full_name,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$CustomCommentMention._(this._$data);

  factory Input$CustomCommentMention.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('full_name')) {
      final l$full_name = data['full_name'];
      result$data['full_name'] = (l$full_name as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$CustomCommentMention._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get full_name => (_$data['full_name'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('full_name')) {
      final l$full_name = full_name;
      result$data['full_name'] = l$full_name;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$CustomCommentMention<Input$CustomCommentMention>
      get copyWith => CopyWith$Input$CustomCommentMention(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CustomCommentMention) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$full_name = full_name;
    final lOther$full_name = other.full_name;
    if (_$data.containsKey('full_name') !=
        other._$data.containsKey('full_name')) {
      return false;
    }
    if (l$full_name != lOther$full_name) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$full_name = full_name;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('full_name') ? l$full_name : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$CustomCommentMention<TRes> {
  factory CopyWith$Input$CustomCommentMention(
    Input$CustomCommentMention instance,
    TRes Function(Input$CustomCommentMention) then,
  ) = _CopyWithImpl$Input$CustomCommentMention;

  factory CopyWith$Input$CustomCommentMention.stub(TRes res) =
      _CopyWithStubImpl$Input$CustomCommentMention;

  TRes call({
    String? full_name,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$CustomCommentMention<TRes>
    implements CopyWith$Input$CustomCommentMention<TRes> {
  _CopyWithImpl$Input$CustomCommentMention(
    this._instance,
    this._then,
  );

  final Input$CustomCommentMention _instance;

  final TRes Function(Input$CustomCommentMention) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? full_name = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$CustomCommentMention._({
        ..._instance._$data,
        if (full_name != _undefined) 'full_name': (full_name as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$CustomCommentMention<TRes>
    implements CopyWith$Input$CustomCommentMention<TRes> {
  _CopyWithStubImpl$Input$CustomCommentMention(this._res);

  TRes _res;

  call({
    String? full_name,
    String? user_uuid,
  }) =>
      _res;
}

class Input$CommonCommentDetailInput {
  factory Input$CommonCommentDetailInput({
    String? uuid,
    String? type,
    int? offset,
    int? limit,
  }) =>
      Input$CommonCommentDetailInput._({
        if (uuid != null) r'uuid': uuid,
        if (type != null) r'type': type,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
      });

  Input$CommonCommentDetailInput._(this._$data);

  factory Input$CommonCommentDetailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    return Input$CommonCommentDetailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get type => (_$data['type'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    return result$data;
  }

  CopyWith$Input$CommonCommentDetailInput<Input$CommonCommentDetailInput>
      get copyWith => CopyWith$Input$CommonCommentDetailInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonCommentDetailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$type = type;
    final l$offset = offset;
    final l$limit = limit;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonCommentDetailInput<TRes> {
  factory CopyWith$Input$CommonCommentDetailInput(
    Input$CommonCommentDetailInput instance,
    TRes Function(Input$CommonCommentDetailInput) then,
  ) = _CopyWithImpl$Input$CommonCommentDetailInput;

  factory CopyWith$Input$CommonCommentDetailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonCommentDetailInput;

  TRes call({
    String? uuid,
    String? type,
    int? offset,
    int? limit,
  });
}

class _CopyWithImpl$Input$CommonCommentDetailInput<TRes>
    implements CopyWith$Input$CommonCommentDetailInput<TRes> {
  _CopyWithImpl$Input$CommonCommentDetailInput(
    this._instance,
    this._then,
  );

  final Input$CommonCommentDetailInput _instance;

  final TRes Function(Input$CommonCommentDetailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? type = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
  }) =>
      _then(Input$CommonCommentDetailInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (type != _undefined) 'type': (type as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonCommentDetailInput<TRes>
    implements CopyWith$Input$CommonCommentDetailInput<TRes> {
  _CopyWithStubImpl$Input$CommonCommentDetailInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? type,
    int? offset,
    int? limit,
  }) =>
      _res;
}

class Input$CommonCommentDeleteInput {
  factory Input$CommonCommentDeleteInput({required String comment_id}) =>
      Input$CommonCommentDeleteInput._({
        r'comment_id': comment_id,
      });

  Input$CommonCommentDeleteInput._(this._$data);

  factory Input$CommonCommentDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$comment_id = data['comment_id'];
    result$data['comment_id'] = (l$comment_id as String);
    return Input$CommonCommentDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get comment_id => (_$data['comment_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$comment_id = comment_id;
    result$data['comment_id'] = l$comment_id;
    return result$data;
  }

  CopyWith$Input$CommonCommentDeleteInput<Input$CommonCommentDeleteInput>
      get copyWith => CopyWith$Input$CommonCommentDeleteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonCommentDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$comment_id = comment_id;
    final lOther$comment_id = other.comment_id;
    if (l$comment_id != lOther$comment_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$comment_id = comment_id;
    return Object.hashAll([l$comment_id]);
  }
}

abstract class CopyWith$Input$CommonCommentDeleteInput<TRes> {
  factory CopyWith$Input$CommonCommentDeleteInput(
    Input$CommonCommentDeleteInput instance,
    TRes Function(Input$CommonCommentDeleteInput) then,
  ) = _CopyWithImpl$Input$CommonCommentDeleteInput;

  factory CopyWith$Input$CommonCommentDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonCommentDeleteInput;

  TRes call({String? comment_id});
}

class _CopyWithImpl$Input$CommonCommentDeleteInput<TRes>
    implements CopyWith$Input$CommonCommentDeleteInput<TRes> {
  _CopyWithImpl$Input$CommonCommentDeleteInput(
    this._instance,
    this._then,
  );

  final Input$CommonCommentDeleteInput _instance;

  final TRes Function(Input$CommonCommentDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? comment_id = _undefined}) =>
      _then(Input$CommonCommentDeleteInput._({
        ..._instance._$data,
        if (comment_id != _undefined && comment_id != null)
          'comment_id': (comment_id as String),
      }));
}

class _CopyWithStubImpl$Input$CommonCommentDeleteInput<TRes>
    implements CopyWith$Input$CommonCommentDeleteInput<TRes> {
  _CopyWithStubImpl$Input$CommonCommentDeleteInput(this._res);

  TRes _res;

  call({String? comment_id}) => _res;
}

class Input$MapUserContactcubeInput {
  factory Input$MapUserContactcubeInput({
    String? connectycube_id,
    String? user_id,
  }) =>
      Input$MapUserContactcubeInput._({
        if (connectycube_id != null) r'connectycube_id': connectycube_id,
        if (user_id != null) r'user_id': user_id,
      });

  Input$MapUserContactcubeInput._(this._$data);

  factory Input$MapUserContactcubeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connectycube_id')) {
      final l$connectycube_id = data['connectycube_id'];
      result$data['connectycube_id'] = (l$connectycube_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$MapUserContactcubeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get connectycube_id => (_$data['connectycube_id'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connectycube_id')) {
      final l$connectycube_id = connectycube_id;
      result$data['connectycube_id'] = l$connectycube_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$MapUserContactcubeInput<Input$MapUserContactcubeInput>
      get copyWith => CopyWith$Input$MapUserContactcubeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MapUserContactcubeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connectycube_id = connectycube_id;
    final lOther$connectycube_id = other.connectycube_id;
    if (_$data.containsKey('connectycube_id') !=
        other._$data.containsKey('connectycube_id')) {
      return false;
    }
    if (l$connectycube_id != lOther$connectycube_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connectycube_id = connectycube_id;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('connectycube_id') ? l$connectycube_id : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$MapUserContactcubeInput<TRes> {
  factory CopyWith$Input$MapUserContactcubeInput(
    Input$MapUserContactcubeInput instance,
    TRes Function(Input$MapUserContactcubeInput) then,
  ) = _CopyWithImpl$Input$MapUserContactcubeInput;

  factory CopyWith$Input$MapUserContactcubeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MapUserContactcubeInput;

  TRes call({
    String? connectycube_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$MapUserContactcubeInput<TRes>
    implements CopyWith$Input$MapUserContactcubeInput<TRes> {
  _CopyWithImpl$Input$MapUserContactcubeInput(
    this._instance,
    this._then,
  );

  final Input$MapUserContactcubeInput _instance;

  final TRes Function(Input$MapUserContactcubeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connectycube_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$MapUserContactcubeInput._({
        ..._instance._$data,
        if (connectycube_id != _undefined)
          'connectycube_id': (connectycube_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$MapUserContactcubeInput<TRes>
    implements CopyWith$Input$MapUserContactcubeInput<TRes> {
  _CopyWithStubImpl$Input$MapUserContactcubeInput(this._res);

  TRes _res;

  call({
    String? connectycube_id,
    String? user_id,
  }) =>
      _res;
}

class Input$CreateChatGroupInput {
  factory Input$CreateChatGroupInput({
    String? group_id,
    List<String?>? user_id,
    int? type,
  }) =>
      Input$CreateChatGroupInput._({
        if (group_id != null) r'group_id': group_id,
        if (user_id != null) r'user_id': user_id,
        if (type != null) r'type': type,
      });

  Input$CreateChatGroupInput._(this._$data);

  factory Input$CreateChatGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('group_id')) {
      final l$group_id = data['group_id'];
      result$data['group_id'] = (l$group_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] =
          (l$user_id as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    return Input$CreateChatGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get group_id => (_$data['group_id'] as String?);

  List<String?>? get user_id => (_$data['user_id'] as List<String?>?);

  int? get type => (_$data['type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('group_id')) {
      final l$group_id = group_id;
      result$data['group_id'] = l$group_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    return result$data;
  }

  CopyWith$Input$CreateChatGroupInput<Input$CreateChatGroupInput>
      get copyWith => CopyWith$Input$CreateChatGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateChatGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_id = group_id;
    final lOther$group_id = other.group_id;
    if (_$data.containsKey('group_id') !=
        other._$data.containsKey('group_id')) {
      return false;
    }
    if (l$group_id != lOther$group_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != null && lOther$user_id != null) {
      if (l$user_id.length != lOther$user_id.length) {
        return false;
      }
      for (int i = 0; i < l$user_id.length; i++) {
        final l$user_id$entry = l$user_id[i];
        final lOther$user_id$entry = lOther$user_id[i];
        if (l$user_id$entry != lOther$user_id$entry) {
          return false;
        }
      }
    } else if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_id = group_id;
    final l$user_id = user_id;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('group_id') ? l$group_id : const {},
      _$data.containsKey('user_id')
          ? l$user_id == null
              ? null
              : Object.hashAll(l$user_id.map((v) => v))
          : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateChatGroupInput<TRes> {
  factory CopyWith$Input$CreateChatGroupInput(
    Input$CreateChatGroupInput instance,
    TRes Function(Input$CreateChatGroupInput) then,
  ) = _CopyWithImpl$Input$CreateChatGroupInput;

  factory CopyWith$Input$CreateChatGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateChatGroupInput;

  TRes call({
    String? group_id,
    List<String?>? user_id,
    int? type,
  });
}

class _CopyWithImpl$Input$CreateChatGroupInput<TRes>
    implements CopyWith$Input$CreateChatGroupInput<TRes> {
  _CopyWithImpl$Input$CreateChatGroupInput(
    this._instance,
    this._then,
  );

  final Input$CreateChatGroupInput _instance;

  final TRes Function(Input$CreateChatGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_id = _undefined,
    Object? user_id = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$CreateChatGroupInput._({
        ..._instance._$data,
        if (group_id != _undefined) 'group_id': (group_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as List<String?>?),
        if (type != _undefined) 'type': (type as int?),
      }));
}

class _CopyWithStubImpl$Input$CreateChatGroupInput<TRes>
    implements CopyWith$Input$CreateChatGroupInput<TRes> {
  _CopyWithStubImpl$Input$CreateChatGroupInput(this._res);

  TRes _res;

  call({
    String? group_id,
    List<String?>? user_id,
    int? type,
  }) =>
      _res;
}

class Input$UpdateChatGroupInput {
  factory Input$UpdateChatGroupInput({
    String? group_id,
    List<String?>? user_id,
    int? type,
  }) =>
      Input$UpdateChatGroupInput._({
        if (group_id != null) r'group_id': group_id,
        if (user_id != null) r'user_id': user_id,
        if (type != null) r'type': type,
      });

  Input$UpdateChatGroupInput._(this._$data);

  factory Input$UpdateChatGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('group_id')) {
      final l$group_id = data['group_id'];
      result$data['group_id'] = (l$group_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] =
          (l$user_id as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as int?);
    }
    return Input$UpdateChatGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get group_id => (_$data['group_id'] as String?);

  List<String?>? get user_id => (_$data['user_id'] as List<String?>?);

  int? get type => (_$data['type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('group_id')) {
      final l$group_id = group_id;
      result$data['group_id'] = l$group_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id?.map((e) => e).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    return result$data;
  }

  CopyWith$Input$UpdateChatGroupInput<Input$UpdateChatGroupInput>
      get copyWith => CopyWith$Input$UpdateChatGroupInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateChatGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$group_id = group_id;
    final lOther$group_id = other.group_id;
    if (_$data.containsKey('group_id') !=
        other._$data.containsKey('group_id')) {
      return false;
    }
    if (l$group_id != lOther$group_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != null && lOther$user_id != null) {
      if (l$user_id.length != lOther$user_id.length) {
        return false;
      }
      for (int i = 0; i < l$user_id.length; i++) {
        final l$user_id$entry = l$user_id[i];
        final lOther$user_id$entry = lOther$user_id[i];
        if (l$user_id$entry != lOther$user_id$entry) {
          return false;
        }
      }
    } else if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$group_id = group_id;
    final l$user_id = user_id;
    final l$type = type;
    return Object.hashAll([
      _$data.containsKey('group_id') ? l$group_id : const {},
      _$data.containsKey('user_id')
          ? l$user_id == null
              ? null
              : Object.hashAll(l$user_id.map((v) => v))
          : const {},
      _$data.containsKey('type') ? l$type : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateChatGroupInput<TRes> {
  factory CopyWith$Input$UpdateChatGroupInput(
    Input$UpdateChatGroupInput instance,
    TRes Function(Input$UpdateChatGroupInput) then,
  ) = _CopyWithImpl$Input$UpdateChatGroupInput;

  factory CopyWith$Input$UpdateChatGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateChatGroupInput;

  TRes call({
    String? group_id,
    List<String?>? user_id,
    int? type,
  });
}

class _CopyWithImpl$Input$UpdateChatGroupInput<TRes>
    implements CopyWith$Input$UpdateChatGroupInput<TRes> {
  _CopyWithImpl$Input$UpdateChatGroupInput(
    this._instance,
    this._then,
  );

  final Input$UpdateChatGroupInput _instance;

  final TRes Function(Input$UpdateChatGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? group_id = _undefined,
    Object? user_id = _undefined,
    Object? type = _undefined,
  }) =>
      _then(Input$UpdateChatGroupInput._({
        ..._instance._$data,
        if (group_id != _undefined) 'group_id': (group_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as List<String?>?),
        if (type != _undefined) 'type': (type as int?),
      }));
}

class _CopyWithStubImpl$Input$UpdateChatGroupInput<TRes>
    implements CopyWith$Input$UpdateChatGroupInput<TRes> {
  _CopyWithStubImpl$Input$UpdateChatGroupInput(this._res);

  TRes _res;

  call({
    String? group_id,
    List<String?>? user_id,
    int? type,
  }) =>
      _res;
}

class Input$getChatGroupInput {
  factory Input$getChatGroupInput({List<String?>? user_id}) =>
      Input$getChatGroupInput._({
        if (user_id != null) r'user_id': user_id,
      });

  Input$getChatGroupInput._(this._$data);

  factory Input$getChatGroupInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] =
          (l$user_id as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    return Input$getChatGroupInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get user_id => (_$data['user_id'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$getChatGroupInput<Input$getChatGroupInput> get copyWith =>
      CopyWith$Input$getChatGroupInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$getChatGroupInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != null && lOther$user_id != null) {
      if (l$user_id.length != lOther$user_id.length) {
        return false;
      }
      for (int i = 0; i < l$user_id.length; i++) {
        final l$user_id$entry = l$user_id[i];
        final lOther$user_id$entry = lOther$user_id[i];
        if (l$user_id$entry != lOther$user_id$entry) {
          return false;
        }
      }
    } else if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('user_id')
          ? l$user_id == null
              ? null
              : Object.hashAll(l$user_id.map((v) => v))
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$getChatGroupInput<TRes> {
  factory CopyWith$Input$getChatGroupInput(
    Input$getChatGroupInput instance,
    TRes Function(Input$getChatGroupInput) then,
  ) = _CopyWithImpl$Input$getChatGroupInput;

  factory CopyWith$Input$getChatGroupInput.stub(TRes res) =
      _CopyWithStubImpl$Input$getChatGroupInput;

  TRes call({List<String?>? user_id});
}

class _CopyWithImpl$Input$getChatGroupInput<TRes>
    implements CopyWith$Input$getChatGroupInput<TRes> {
  _CopyWithImpl$Input$getChatGroupInput(
    this._instance,
    this._then,
  );

  final Input$getChatGroupInput _instance;

  final TRes Function(Input$getChatGroupInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? user_id = _undefined}) => _then(Input$getChatGroupInput._({
        ..._instance._$data,
        if (user_id != _undefined) 'user_id': (user_id as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$getChatGroupInput<TRes>
    implements CopyWith$Input$getChatGroupInput<TRes> {
  _CopyWithStubImpl$Input$getChatGroupInput(this._res);

  TRes _res;

  call({List<String?>? user_id}) => _res;
}

class Input$GroupMemberConnectIdInput {
  factory Input$GroupMemberConnectIdInput({String? uuid}) =>
      Input$GroupMemberConnectIdInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$GroupMemberConnectIdInput._(this._$data);

  factory Input$GroupMemberConnectIdInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$GroupMemberConnectIdInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$GroupMemberConnectIdInput<Input$GroupMemberConnectIdInput>
      get copyWith => CopyWith$Input$GroupMemberConnectIdInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GroupMemberConnectIdInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([_$data.containsKey('uuid') ? l$uuid : const {}]);
  }
}

abstract class CopyWith$Input$GroupMemberConnectIdInput<TRes> {
  factory CopyWith$Input$GroupMemberConnectIdInput(
    Input$GroupMemberConnectIdInput instance,
    TRes Function(Input$GroupMemberConnectIdInput) then,
  ) = _CopyWithImpl$Input$GroupMemberConnectIdInput;

  factory CopyWith$Input$GroupMemberConnectIdInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GroupMemberConnectIdInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$GroupMemberConnectIdInput<TRes>
    implements CopyWith$Input$GroupMemberConnectIdInput<TRes> {
  _CopyWithImpl$Input$GroupMemberConnectIdInput(
    this._instance,
    this._then,
  );

  final Input$GroupMemberConnectIdInput _instance;

  final TRes Function(Input$GroupMemberConnectIdInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$GroupMemberConnectIdInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$GroupMemberConnectIdInput<TRes>
    implements CopyWith$Input$GroupMemberConnectIdInput<TRes> {
  _CopyWithStubImpl$Input$GroupMemberConnectIdInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$EditBankAccInput {
  factory Input$EditBankAccInput({
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  }) =>
      Input$EditBankAccInput._({
        if (account_holder_name != null)
          r'account_holder_name': account_holder_name,
        if (account_holder_type != null)
          r'account_holder_type': account_holder_type,
        if (routing_number != null) r'routing_number': routing_number,
        if (account_number != null) r'account_number': account_number,
        if (first_name != null) r'first_name': first_name,
        if (last_name != null) r'last_name': last_name,
        if (city != null) r'city': city,
        if (dob != null) r'dob': dob,
        if (ssn_last_4 != null) r'ssn_last_4': ssn_last_4,
        if (country != null) r'country': country,
        if (currency != null) r'currency': currency,
        if (stripe_bank_id != null) r'stripe_bank_id': stripe_bank_id,
        if (stripe_bank_token != null) r'stripe_bank_token': stripe_bank_token,
      });

  Input$EditBankAccInput._(this._$data);

  factory Input$EditBankAccInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('account_holder_name')) {
      final l$account_holder_name = data['account_holder_name'];
      result$data['account_holder_name'] = (l$account_holder_name as String?);
    }
    if (data.containsKey('account_holder_type')) {
      final l$account_holder_type = data['account_holder_type'];
      result$data['account_holder_type'] = (l$account_holder_type as String?);
    }
    if (data.containsKey('routing_number')) {
      final l$routing_number = data['routing_number'];
      result$data['routing_number'] = (l$routing_number as String?);
    }
    if (data.containsKey('account_number')) {
      final l$account_number = data['account_number'];
      result$data['account_number'] = (l$account_number as String?);
    }
    if (data.containsKey('first_name')) {
      final l$first_name = data['first_name'];
      result$data['first_name'] = (l$first_name as String?);
    }
    if (data.containsKey('last_name')) {
      final l$last_name = data['last_name'];
      result$data['last_name'] = (l$last_name as String?);
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = (l$city as String?);
    }
    if (data.containsKey('dob')) {
      final l$dob = data['dob'];
      result$data['dob'] = (l$dob as String?);
    }
    if (data.containsKey('ssn_last_4')) {
      final l$ssn_last_4 = data['ssn_last_4'];
      result$data['ssn_last_4'] = (l$ssn_last_4 as String?);
    }
    if (data.containsKey('country')) {
      final l$country = data['country'];
      result$data['country'] = (l$country as String?);
    }
    if (data.containsKey('currency')) {
      final l$currency = data['currency'];
      result$data['currency'] = (l$currency as String?);
    }
    if (data.containsKey('stripe_bank_id')) {
      final l$stripe_bank_id = data['stripe_bank_id'];
      result$data['stripe_bank_id'] = (l$stripe_bank_id as String?);
    }
    if (data.containsKey('stripe_bank_token')) {
      final l$stripe_bank_token = data['stripe_bank_token'];
      result$data['stripe_bank_token'] = (l$stripe_bank_token as String?);
    }
    return Input$EditBankAccInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get account_holder_name => (_$data['account_holder_name'] as String?);

  String? get account_holder_type => (_$data['account_holder_type'] as String?);

  String? get routing_number => (_$data['routing_number'] as String?);

  String? get account_number => (_$data['account_number'] as String?);

  String? get first_name => (_$data['first_name'] as String?);

  String? get last_name => (_$data['last_name'] as String?);

  String? get city => (_$data['city'] as String?);

  String? get dob => (_$data['dob'] as String?);

  String? get ssn_last_4 => (_$data['ssn_last_4'] as String?);

  String? get country => (_$data['country'] as String?);

  String? get currency => (_$data['currency'] as String?);

  String? get stripe_bank_id => (_$data['stripe_bank_id'] as String?);

  String? get stripe_bank_token => (_$data['stripe_bank_token'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('account_holder_name')) {
      final l$account_holder_name = account_holder_name;
      result$data['account_holder_name'] = l$account_holder_name;
    }
    if (_$data.containsKey('account_holder_type')) {
      final l$account_holder_type = account_holder_type;
      result$data['account_holder_type'] = l$account_holder_type;
    }
    if (_$data.containsKey('routing_number')) {
      final l$routing_number = routing_number;
      result$data['routing_number'] = l$routing_number;
    }
    if (_$data.containsKey('account_number')) {
      final l$account_number = account_number;
      result$data['account_number'] = l$account_number;
    }
    if (_$data.containsKey('first_name')) {
      final l$first_name = first_name;
      result$data['first_name'] = l$first_name;
    }
    if (_$data.containsKey('last_name')) {
      final l$last_name = last_name;
      result$data['last_name'] = l$last_name;
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city;
    }
    if (_$data.containsKey('dob')) {
      final l$dob = dob;
      result$data['dob'] = l$dob;
    }
    if (_$data.containsKey('ssn_last_4')) {
      final l$ssn_last_4 = ssn_last_4;
      result$data['ssn_last_4'] = l$ssn_last_4;
    }
    if (_$data.containsKey('country')) {
      final l$country = country;
      result$data['country'] = l$country;
    }
    if (_$data.containsKey('currency')) {
      final l$currency = currency;
      result$data['currency'] = l$currency;
    }
    if (_$data.containsKey('stripe_bank_id')) {
      final l$stripe_bank_id = stripe_bank_id;
      result$data['stripe_bank_id'] = l$stripe_bank_id;
    }
    if (_$data.containsKey('stripe_bank_token')) {
      final l$stripe_bank_token = stripe_bank_token;
      result$data['stripe_bank_token'] = l$stripe_bank_token;
    }
    return result$data;
  }

  CopyWith$Input$EditBankAccInput<Input$EditBankAccInput> get copyWith =>
      CopyWith$Input$EditBankAccInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EditBankAccInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$account_holder_name = account_holder_name;
    final lOther$account_holder_name = other.account_holder_name;
    if (_$data.containsKey('account_holder_name') !=
        other._$data.containsKey('account_holder_name')) {
      return false;
    }
    if (l$account_holder_name != lOther$account_holder_name) {
      return false;
    }
    final l$account_holder_type = account_holder_type;
    final lOther$account_holder_type = other.account_holder_type;
    if (_$data.containsKey('account_holder_type') !=
        other._$data.containsKey('account_holder_type')) {
      return false;
    }
    if (l$account_holder_type != lOther$account_holder_type) {
      return false;
    }
    final l$routing_number = routing_number;
    final lOther$routing_number = other.routing_number;
    if (_$data.containsKey('routing_number') !=
        other._$data.containsKey('routing_number')) {
      return false;
    }
    if (l$routing_number != lOther$routing_number) {
      return false;
    }
    final l$account_number = account_number;
    final lOther$account_number = other.account_number;
    if (_$data.containsKey('account_number') !=
        other._$data.containsKey('account_number')) {
      return false;
    }
    if (l$account_number != lOther$account_number) {
      return false;
    }
    final l$first_name = first_name;
    final lOther$first_name = other.first_name;
    if (_$data.containsKey('first_name') !=
        other._$data.containsKey('first_name')) {
      return false;
    }
    if (l$first_name != lOther$first_name) {
      return false;
    }
    final l$last_name = last_name;
    final lOther$last_name = other.last_name;
    if (_$data.containsKey('last_name') !=
        other._$data.containsKey('last_name')) {
      return false;
    }
    if (l$last_name != lOther$last_name) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$dob = dob;
    final lOther$dob = other.dob;
    if (_$data.containsKey('dob') != other._$data.containsKey('dob')) {
      return false;
    }
    if (l$dob != lOther$dob) {
      return false;
    }
    final l$ssn_last_4 = ssn_last_4;
    final lOther$ssn_last_4 = other.ssn_last_4;
    if (_$data.containsKey('ssn_last_4') !=
        other._$data.containsKey('ssn_last_4')) {
      return false;
    }
    if (l$ssn_last_4 != lOther$ssn_last_4) {
      return false;
    }
    final l$country = country;
    final lOther$country = other.country;
    if (_$data.containsKey('country') != other._$data.containsKey('country')) {
      return false;
    }
    if (l$country != lOther$country) {
      return false;
    }
    final l$currency = currency;
    final lOther$currency = other.currency;
    if (_$data.containsKey('currency') !=
        other._$data.containsKey('currency')) {
      return false;
    }
    if (l$currency != lOther$currency) {
      return false;
    }
    final l$stripe_bank_id = stripe_bank_id;
    final lOther$stripe_bank_id = other.stripe_bank_id;
    if (_$data.containsKey('stripe_bank_id') !=
        other._$data.containsKey('stripe_bank_id')) {
      return false;
    }
    if (l$stripe_bank_id != lOther$stripe_bank_id) {
      return false;
    }
    final l$stripe_bank_token = stripe_bank_token;
    final lOther$stripe_bank_token = other.stripe_bank_token;
    if (_$data.containsKey('stripe_bank_token') !=
        other._$data.containsKey('stripe_bank_token')) {
      return false;
    }
    if (l$stripe_bank_token != lOther$stripe_bank_token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$account_holder_name = account_holder_name;
    final l$account_holder_type = account_holder_type;
    final l$routing_number = routing_number;
    final l$account_number = account_number;
    final l$first_name = first_name;
    final l$last_name = last_name;
    final l$city = city;
    final l$dob = dob;
    final l$ssn_last_4 = ssn_last_4;
    final l$country = country;
    final l$currency = currency;
    final l$stripe_bank_id = stripe_bank_id;
    final l$stripe_bank_token = stripe_bank_token;
    return Object.hashAll([
      _$data.containsKey('account_holder_name')
          ? l$account_holder_name
          : const {},
      _$data.containsKey('account_holder_type')
          ? l$account_holder_type
          : const {},
      _$data.containsKey('routing_number') ? l$routing_number : const {},
      _$data.containsKey('account_number') ? l$account_number : const {},
      _$data.containsKey('first_name') ? l$first_name : const {},
      _$data.containsKey('last_name') ? l$last_name : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('dob') ? l$dob : const {},
      _$data.containsKey('ssn_last_4') ? l$ssn_last_4 : const {},
      _$data.containsKey('country') ? l$country : const {},
      _$data.containsKey('currency') ? l$currency : const {},
      _$data.containsKey('stripe_bank_id') ? l$stripe_bank_id : const {},
      _$data.containsKey('stripe_bank_token') ? l$stripe_bank_token : const {},
    ]);
  }
}

abstract class CopyWith$Input$EditBankAccInput<TRes> {
  factory CopyWith$Input$EditBankAccInput(
    Input$EditBankAccInput instance,
    TRes Function(Input$EditBankAccInput) then,
  ) = _CopyWithImpl$Input$EditBankAccInput;

  factory CopyWith$Input$EditBankAccInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EditBankAccInput;

  TRes call({
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  });
}

class _CopyWithImpl$Input$EditBankAccInput<TRes>
    implements CopyWith$Input$EditBankAccInput<TRes> {
  _CopyWithImpl$Input$EditBankAccInput(
    this._instance,
    this._then,
  );

  final Input$EditBankAccInput _instance;

  final TRes Function(Input$EditBankAccInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? account_holder_name = _undefined,
    Object? account_holder_type = _undefined,
    Object? routing_number = _undefined,
    Object? account_number = _undefined,
    Object? first_name = _undefined,
    Object? last_name = _undefined,
    Object? city = _undefined,
    Object? dob = _undefined,
    Object? ssn_last_4 = _undefined,
    Object? country = _undefined,
    Object? currency = _undefined,
    Object? stripe_bank_id = _undefined,
    Object? stripe_bank_token = _undefined,
  }) =>
      _then(Input$EditBankAccInput._({
        ..._instance._$data,
        if (account_holder_name != _undefined)
          'account_holder_name': (account_holder_name as String?),
        if (account_holder_type != _undefined)
          'account_holder_type': (account_holder_type as String?),
        if (routing_number != _undefined)
          'routing_number': (routing_number as String?),
        if (account_number != _undefined)
          'account_number': (account_number as String?),
        if (first_name != _undefined) 'first_name': (first_name as String?),
        if (last_name != _undefined) 'last_name': (last_name as String?),
        if (city != _undefined) 'city': (city as String?),
        if (dob != _undefined) 'dob': (dob as String?),
        if (ssn_last_4 != _undefined) 'ssn_last_4': (ssn_last_4 as String?),
        if (country != _undefined) 'country': (country as String?),
        if (currency != _undefined) 'currency': (currency as String?),
        if (stripe_bank_id != _undefined)
          'stripe_bank_id': (stripe_bank_id as String?),
        if (stripe_bank_token != _undefined)
          'stripe_bank_token': (stripe_bank_token as String?),
      }));
}

class _CopyWithStubImpl$Input$EditBankAccInput<TRes>
    implements CopyWith$Input$EditBankAccInput<TRes> {
  _CopyWithStubImpl$Input$EditBankAccInput(this._res);

  TRes _res;

  call({
    String? account_holder_name,
    String? account_holder_type,
    String? routing_number,
    String? account_number,
    String? first_name,
    String? last_name,
    String? city,
    String? dob,
    String? ssn_last_4,
    String? country,
    String? currency,
    String? stripe_bank_id,
    String? stripe_bank_token,
  }) =>
      _res;
}

class Input$ReportMailInput {
  factory Input$ReportMailInput({
    String? uuid,
    String? email,
    String? message,
  }) =>
      Input$ReportMailInput._({
        if (uuid != null) r'uuid': uuid,
        if (email != null) r'email': email,
        if (message != null) r'message': message,
      });

  Input$ReportMailInput._(this._$data);

  factory Input$ReportMailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    return Input$ReportMailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get email => (_$data['email'] as String?);

  String? get message => (_$data['message'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    return result$data;
  }

  CopyWith$Input$ReportMailInput<Input$ReportMailInput> get copyWith =>
      CopyWith$Input$ReportMailInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReportMailInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$email = email;
    final l$message = message;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('message') ? l$message : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReportMailInput<TRes> {
  factory CopyWith$Input$ReportMailInput(
    Input$ReportMailInput instance,
    TRes Function(Input$ReportMailInput) then,
  ) = _CopyWithImpl$Input$ReportMailInput;

  factory CopyWith$Input$ReportMailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReportMailInput;

  TRes call({
    String? uuid,
    String? email,
    String? message,
  });
}

class _CopyWithImpl$Input$ReportMailInput<TRes>
    implements CopyWith$Input$ReportMailInput<TRes> {
  _CopyWithImpl$Input$ReportMailInput(
    this._instance,
    this._then,
  );

  final Input$ReportMailInput _instance;

  final TRes Function(Input$ReportMailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? email = _undefined,
    Object? message = _undefined,
  }) =>
      _then(Input$ReportMailInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (email != _undefined) 'email': (email as String?),
        if (message != _undefined) 'message': (message as String?),
      }));
}

class _CopyWithStubImpl$Input$ReportMailInput<TRes>
    implements CopyWith$Input$ReportMailInput<TRes> {
  _CopyWithStubImpl$Input$ReportMailInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? email,
    String? message,
  }) =>
      _res;
}

class Input$GetMatchStatusInput {
  factory Input$GetMatchStatusInput({
    String? user_id,
    String? match_id,
  }) =>
      Input$GetMatchStatusInput._({
        if (user_id != null) r'user_id': user_id,
        if (match_id != null) r'match_id': match_id,
      });

  Input$GetMatchStatusInput._(this._$data);

  factory Input$GetMatchStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    return Input$GetMatchStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_id => (_$data['user_id'] as String?);

  String? get match_id => (_$data['match_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    return result$data;
  }

  CopyWith$Input$GetMatchStatusInput<Input$GetMatchStatusInput> get copyWith =>
      CopyWith$Input$GetMatchStatusInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GetMatchStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_id = user_id;
    final l$match_id = match_id;
    return Object.hashAll([
      _$data.containsKey('user_id') ? l$user_id : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$GetMatchStatusInput<TRes> {
  factory CopyWith$Input$GetMatchStatusInput(
    Input$GetMatchStatusInput instance,
    TRes Function(Input$GetMatchStatusInput) then,
  ) = _CopyWithImpl$Input$GetMatchStatusInput;

  factory CopyWith$Input$GetMatchStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GetMatchStatusInput;

  TRes call({
    String? user_id,
    String? match_id,
  });
}

class _CopyWithImpl$Input$GetMatchStatusInput<TRes>
    implements CopyWith$Input$GetMatchStatusInput<TRes> {
  _CopyWithImpl$Input$GetMatchStatusInput(
    this._instance,
    this._then,
  );

  final Input$GetMatchStatusInput _instance;

  final TRes Function(Input$GetMatchStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_id = _undefined,
    Object? match_id = _undefined,
  }) =>
      _then(Input$GetMatchStatusInput._({
        ..._instance._$data,
        if (user_id != _undefined) 'user_id': (user_id as String?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
      }));
}

class _CopyWithStubImpl$Input$GetMatchStatusInput<TRes>
    implements CopyWith$Input$GetMatchStatusInput<TRes> {
  _CopyWithStubImpl$Input$GetMatchStatusInput(this._res);

  TRes _res;

  call({
    String? user_id,
    String? match_id,
  }) =>
      _res;
}

class Input$CommonSettingInput {
  factory Input$CommonSettingInput({
    int? cancel_match_time,
    int? cancel_lesson_time,
    int? cancel_social_time,
    int? cancel_camp_time,
    int? cancel_tournament_time,
    int? cancel_league_time,
  }) =>
      Input$CommonSettingInput._({
        if (cancel_match_time != null) r'cancel_match_time': cancel_match_time,
        if (cancel_lesson_time != null)
          r'cancel_lesson_time': cancel_lesson_time,
        if (cancel_social_time != null)
          r'cancel_social_time': cancel_social_time,
        if (cancel_camp_time != null) r'cancel_camp_time': cancel_camp_time,
        if (cancel_tournament_time != null)
          r'cancel_tournament_time': cancel_tournament_time,
        if (cancel_league_time != null)
          r'cancel_league_time': cancel_league_time,
      });

  Input$CommonSettingInput._(this._$data);

  factory Input$CommonSettingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cancel_match_time')) {
      final l$cancel_match_time = data['cancel_match_time'];
      result$data['cancel_match_time'] = (l$cancel_match_time as int?);
    }
    if (data.containsKey('cancel_lesson_time')) {
      final l$cancel_lesson_time = data['cancel_lesson_time'];
      result$data['cancel_lesson_time'] = (l$cancel_lesson_time as int?);
    }
    if (data.containsKey('cancel_social_time')) {
      final l$cancel_social_time = data['cancel_social_time'];
      result$data['cancel_social_time'] = (l$cancel_social_time as int?);
    }
    if (data.containsKey('cancel_camp_time')) {
      final l$cancel_camp_time = data['cancel_camp_time'];
      result$data['cancel_camp_time'] = (l$cancel_camp_time as int?);
    }
    if (data.containsKey('cancel_tournament_time')) {
      final l$cancel_tournament_time = data['cancel_tournament_time'];
      result$data['cancel_tournament_time'] =
          (l$cancel_tournament_time as int?);
    }
    if (data.containsKey('cancel_league_time')) {
      final l$cancel_league_time = data['cancel_league_time'];
      result$data['cancel_league_time'] = (l$cancel_league_time as int?);
    }
    return Input$CommonSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get cancel_match_time => (_$data['cancel_match_time'] as int?);

  int? get cancel_lesson_time => (_$data['cancel_lesson_time'] as int?);

  int? get cancel_social_time => (_$data['cancel_social_time'] as int?);

  int? get cancel_camp_time => (_$data['cancel_camp_time'] as int?);

  int? get cancel_tournament_time => (_$data['cancel_tournament_time'] as int?);

  int? get cancel_league_time => (_$data['cancel_league_time'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cancel_match_time')) {
      final l$cancel_match_time = cancel_match_time;
      result$data['cancel_match_time'] = l$cancel_match_time;
    }
    if (_$data.containsKey('cancel_lesson_time')) {
      final l$cancel_lesson_time = cancel_lesson_time;
      result$data['cancel_lesson_time'] = l$cancel_lesson_time;
    }
    if (_$data.containsKey('cancel_social_time')) {
      final l$cancel_social_time = cancel_social_time;
      result$data['cancel_social_time'] = l$cancel_social_time;
    }
    if (_$data.containsKey('cancel_camp_time')) {
      final l$cancel_camp_time = cancel_camp_time;
      result$data['cancel_camp_time'] = l$cancel_camp_time;
    }
    if (_$data.containsKey('cancel_tournament_time')) {
      final l$cancel_tournament_time = cancel_tournament_time;
      result$data['cancel_tournament_time'] = l$cancel_tournament_time;
    }
    if (_$data.containsKey('cancel_league_time')) {
      final l$cancel_league_time = cancel_league_time;
      result$data['cancel_league_time'] = l$cancel_league_time;
    }
    return result$data;
  }

  CopyWith$Input$CommonSettingInput<Input$CommonSettingInput> get copyWith =>
      CopyWith$Input$CommonSettingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cancel_match_time = cancel_match_time;
    final lOther$cancel_match_time = other.cancel_match_time;
    if (_$data.containsKey('cancel_match_time') !=
        other._$data.containsKey('cancel_match_time')) {
      return false;
    }
    if (l$cancel_match_time != lOther$cancel_match_time) {
      return false;
    }
    final l$cancel_lesson_time = cancel_lesson_time;
    final lOther$cancel_lesson_time = other.cancel_lesson_time;
    if (_$data.containsKey('cancel_lesson_time') !=
        other._$data.containsKey('cancel_lesson_time')) {
      return false;
    }
    if (l$cancel_lesson_time != lOther$cancel_lesson_time) {
      return false;
    }
    final l$cancel_social_time = cancel_social_time;
    final lOther$cancel_social_time = other.cancel_social_time;
    if (_$data.containsKey('cancel_social_time') !=
        other._$data.containsKey('cancel_social_time')) {
      return false;
    }
    if (l$cancel_social_time != lOther$cancel_social_time) {
      return false;
    }
    final l$cancel_camp_time = cancel_camp_time;
    final lOther$cancel_camp_time = other.cancel_camp_time;
    if (_$data.containsKey('cancel_camp_time') !=
        other._$data.containsKey('cancel_camp_time')) {
      return false;
    }
    if (l$cancel_camp_time != lOther$cancel_camp_time) {
      return false;
    }
    final l$cancel_tournament_time = cancel_tournament_time;
    final lOther$cancel_tournament_time = other.cancel_tournament_time;
    if (_$data.containsKey('cancel_tournament_time') !=
        other._$data.containsKey('cancel_tournament_time')) {
      return false;
    }
    if (l$cancel_tournament_time != lOther$cancel_tournament_time) {
      return false;
    }
    final l$cancel_league_time = cancel_league_time;
    final lOther$cancel_league_time = other.cancel_league_time;
    if (_$data.containsKey('cancel_league_time') !=
        other._$data.containsKey('cancel_league_time')) {
      return false;
    }
    if (l$cancel_league_time != lOther$cancel_league_time) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cancel_match_time = cancel_match_time;
    final l$cancel_lesson_time = cancel_lesson_time;
    final l$cancel_social_time = cancel_social_time;
    final l$cancel_camp_time = cancel_camp_time;
    final l$cancel_tournament_time = cancel_tournament_time;
    final l$cancel_league_time = cancel_league_time;
    return Object.hashAll([
      _$data.containsKey('cancel_match_time') ? l$cancel_match_time : const {},
      _$data.containsKey('cancel_lesson_time')
          ? l$cancel_lesson_time
          : const {},
      _$data.containsKey('cancel_social_time')
          ? l$cancel_social_time
          : const {},
      _$data.containsKey('cancel_camp_time') ? l$cancel_camp_time : const {},
      _$data.containsKey('cancel_tournament_time')
          ? l$cancel_tournament_time
          : const {},
      _$data.containsKey('cancel_league_time')
          ? l$cancel_league_time
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonSettingInput<TRes> {
  factory CopyWith$Input$CommonSettingInput(
    Input$CommonSettingInput instance,
    TRes Function(Input$CommonSettingInput) then,
  ) = _CopyWithImpl$Input$CommonSettingInput;

  factory CopyWith$Input$CommonSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonSettingInput;

  TRes call({
    int? cancel_match_time,
    int? cancel_lesson_time,
    int? cancel_social_time,
    int? cancel_camp_time,
    int? cancel_tournament_time,
    int? cancel_league_time,
  });
}

class _CopyWithImpl$Input$CommonSettingInput<TRes>
    implements CopyWith$Input$CommonSettingInput<TRes> {
  _CopyWithImpl$Input$CommonSettingInput(
    this._instance,
    this._then,
  );

  final Input$CommonSettingInput _instance;

  final TRes Function(Input$CommonSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? cancel_match_time = _undefined,
    Object? cancel_lesson_time = _undefined,
    Object? cancel_social_time = _undefined,
    Object? cancel_camp_time = _undefined,
    Object? cancel_tournament_time = _undefined,
    Object? cancel_league_time = _undefined,
  }) =>
      _then(Input$CommonSettingInput._({
        ..._instance._$data,
        if (cancel_match_time != _undefined)
          'cancel_match_time': (cancel_match_time as int?),
        if (cancel_lesson_time != _undefined)
          'cancel_lesson_time': (cancel_lesson_time as int?),
        if (cancel_social_time != _undefined)
          'cancel_social_time': (cancel_social_time as int?),
        if (cancel_camp_time != _undefined)
          'cancel_camp_time': (cancel_camp_time as int?),
        if (cancel_tournament_time != _undefined)
          'cancel_tournament_time': (cancel_tournament_time as int?),
        if (cancel_league_time != _undefined)
          'cancel_league_time': (cancel_league_time as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonSettingInput<TRes>
    implements CopyWith$Input$CommonSettingInput<TRes> {
  _CopyWithStubImpl$Input$CommonSettingInput(this._res);

  TRes _res;

  call({
    int? cancel_match_time,
    int? cancel_lesson_time,
    int? cancel_social_time,
    int? cancel_camp_time,
    int? cancel_tournament_time,
    int? cancel_league_time,
  }) =>
      _res;
}

class Input$DistanceSettingInput {
  factory Input$DistanceSettingInput({
    int? match_distance,
    int? event_distance,
    int? lesson_distance,
    int? social_distance,
    int? camp_distance,
    int? league_distance,
    int? tournament_distance,
  }) =>
      Input$DistanceSettingInput._({
        if (match_distance != null) r'match_distance': match_distance,
        if (event_distance != null) r'event_distance': event_distance,
        if (lesson_distance != null) r'lesson_distance': lesson_distance,
        if (social_distance != null) r'social_distance': social_distance,
        if (camp_distance != null) r'camp_distance': camp_distance,
        if (league_distance != null) r'league_distance': league_distance,
        if (tournament_distance != null)
          r'tournament_distance': tournament_distance,
      });

  Input$DistanceSettingInput._(this._$data);

  factory Input$DistanceSettingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_distance')) {
      final l$match_distance = data['match_distance'];
      result$data['match_distance'] = (l$match_distance as int?);
    }
    if (data.containsKey('event_distance')) {
      final l$event_distance = data['event_distance'];
      result$data['event_distance'] = (l$event_distance as int?);
    }
    if (data.containsKey('lesson_distance')) {
      final l$lesson_distance = data['lesson_distance'];
      result$data['lesson_distance'] = (l$lesson_distance as int?);
    }
    if (data.containsKey('social_distance')) {
      final l$social_distance = data['social_distance'];
      result$data['social_distance'] = (l$social_distance as int?);
    }
    if (data.containsKey('camp_distance')) {
      final l$camp_distance = data['camp_distance'];
      result$data['camp_distance'] = (l$camp_distance as int?);
    }
    if (data.containsKey('league_distance')) {
      final l$league_distance = data['league_distance'];
      result$data['league_distance'] = (l$league_distance as int?);
    }
    if (data.containsKey('tournament_distance')) {
      final l$tournament_distance = data['tournament_distance'];
      result$data['tournament_distance'] = (l$tournament_distance as int?);
    }
    return Input$DistanceSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get match_distance => (_$data['match_distance'] as int?);

  int? get event_distance => (_$data['event_distance'] as int?);

  int? get lesson_distance => (_$data['lesson_distance'] as int?);

  int? get social_distance => (_$data['social_distance'] as int?);

  int? get camp_distance => (_$data['camp_distance'] as int?);

  int? get league_distance => (_$data['league_distance'] as int?);

  int? get tournament_distance => (_$data['tournament_distance'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_distance')) {
      final l$match_distance = match_distance;
      result$data['match_distance'] = l$match_distance;
    }
    if (_$data.containsKey('event_distance')) {
      final l$event_distance = event_distance;
      result$data['event_distance'] = l$event_distance;
    }
    if (_$data.containsKey('lesson_distance')) {
      final l$lesson_distance = lesson_distance;
      result$data['lesson_distance'] = l$lesson_distance;
    }
    if (_$data.containsKey('social_distance')) {
      final l$social_distance = social_distance;
      result$data['social_distance'] = l$social_distance;
    }
    if (_$data.containsKey('camp_distance')) {
      final l$camp_distance = camp_distance;
      result$data['camp_distance'] = l$camp_distance;
    }
    if (_$data.containsKey('league_distance')) {
      final l$league_distance = league_distance;
      result$data['league_distance'] = l$league_distance;
    }
    if (_$data.containsKey('tournament_distance')) {
      final l$tournament_distance = tournament_distance;
      result$data['tournament_distance'] = l$tournament_distance;
    }
    return result$data;
  }

  CopyWith$Input$DistanceSettingInput<Input$DistanceSettingInput>
      get copyWith => CopyWith$Input$DistanceSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DistanceSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_distance = match_distance;
    final lOther$match_distance = other.match_distance;
    if (_$data.containsKey('match_distance') !=
        other._$data.containsKey('match_distance')) {
      return false;
    }
    if (l$match_distance != lOther$match_distance) {
      return false;
    }
    final l$event_distance = event_distance;
    final lOther$event_distance = other.event_distance;
    if (_$data.containsKey('event_distance') !=
        other._$data.containsKey('event_distance')) {
      return false;
    }
    if (l$event_distance != lOther$event_distance) {
      return false;
    }
    final l$lesson_distance = lesson_distance;
    final lOther$lesson_distance = other.lesson_distance;
    if (_$data.containsKey('lesson_distance') !=
        other._$data.containsKey('lesson_distance')) {
      return false;
    }
    if (l$lesson_distance != lOther$lesson_distance) {
      return false;
    }
    final l$social_distance = social_distance;
    final lOther$social_distance = other.social_distance;
    if (_$data.containsKey('social_distance') !=
        other._$data.containsKey('social_distance')) {
      return false;
    }
    if (l$social_distance != lOther$social_distance) {
      return false;
    }
    final l$camp_distance = camp_distance;
    final lOther$camp_distance = other.camp_distance;
    if (_$data.containsKey('camp_distance') !=
        other._$data.containsKey('camp_distance')) {
      return false;
    }
    if (l$camp_distance != lOther$camp_distance) {
      return false;
    }
    final l$league_distance = league_distance;
    final lOther$league_distance = other.league_distance;
    if (_$data.containsKey('league_distance') !=
        other._$data.containsKey('league_distance')) {
      return false;
    }
    if (l$league_distance != lOther$league_distance) {
      return false;
    }
    final l$tournament_distance = tournament_distance;
    final lOther$tournament_distance = other.tournament_distance;
    if (_$data.containsKey('tournament_distance') !=
        other._$data.containsKey('tournament_distance')) {
      return false;
    }
    if (l$tournament_distance != lOther$tournament_distance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_distance = match_distance;
    final l$event_distance = event_distance;
    final l$lesson_distance = lesson_distance;
    final l$social_distance = social_distance;
    final l$camp_distance = camp_distance;
    final l$league_distance = league_distance;
    final l$tournament_distance = tournament_distance;
    return Object.hashAll([
      _$data.containsKey('match_distance') ? l$match_distance : const {},
      _$data.containsKey('event_distance') ? l$event_distance : const {},
      _$data.containsKey('lesson_distance') ? l$lesson_distance : const {},
      _$data.containsKey('social_distance') ? l$social_distance : const {},
      _$data.containsKey('camp_distance') ? l$camp_distance : const {},
      _$data.containsKey('league_distance') ? l$league_distance : const {},
      _$data.containsKey('tournament_distance')
          ? l$tournament_distance
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DistanceSettingInput<TRes> {
  factory CopyWith$Input$DistanceSettingInput(
    Input$DistanceSettingInput instance,
    TRes Function(Input$DistanceSettingInput) then,
  ) = _CopyWithImpl$Input$DistanceSettingInput;

  factory CopyWith$Input$DistanceSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DistanceSettingInput;

  TRes call({
    int? match_distance,
    int? event_distance,
    int? lesson_distance,
    int? social_distance,
    int? camp_distance,
    int? league_distance,
    int? tournament_distance,
  });
}

class _CopyWithImpl$Input$DistanceSettingInput<TRes>
    implements CopyWith$Input$DistanceSettingInput<TRes> {
  _CopyWithImpl$Input$DistanceSettingInput(
    this._instance,
    this._then,
  );

  final Input$DistanceSettingInput _instance;

  final TRes Function(Input$DistanceSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_distance = _undefined,
    Object? event_distance = _undefined,
    Object? lesson_distance = _undefined,
    Object? social_distance = _undefined,
    Object? camp_distance = _undefined,
    Object? league_distance = _undefined,
    Object? tournament_distance = _undefined,
  }) =>
      _then(Input$DistanceSettingInput._({
        ..._instance._$data,
        if (match_distance != _undefined)
          'match_distance': (match_distance as int?),
        if (event_distance != _undefined)
          'event_distance': (event_distance as int?),
        if (lesson_distance != _undefined)
          'lesson_distance': (lesson_distance as int?),
        if (social_distance != _undefined)
          'social_distance': (social_distance as int?),
        if (camp_distance != _undefined)
          'camp_distance': (camp_distance as int?),
        if (league_distance != _undefined)
          'league_distance': (league_distance as int?),
        if (tournament_distance != _undefined)
          'tournament_distance': (tournament_distance as int?),
      }));
}

class _CopyWithStubImpl$Input$DistanceSettingInput<TRes>
    implements CopyWith$Input$DistanceSettingInput<TRes> {
  _CopyWithStubImpl$Input$DistanceSettingInput(this._res);

  TRes _res;

  call({
    int? match_distance,
    int? event_distance,
    int? lesson_distance,
    int? social_distance,
    int? camp_distance,
    int? league_distance,
    int? tournament_distance,
  }) =>
      _res;
}

class Input$FrontCommonSettingInput {
  factory Input$FrontCommonSettingInput({
    String? platform,
    String? version,
    String? user_id,
  }) =>
      Input$FrontCommonSettingInput._({
        if (platform != null) r'platform': platform,
        if (version != null) r'version': version,
        if (user_id != null) r'user_id': user_id,
      });

  Input$FrontCommonSettingInput._(this._$data);

  factory Input$FrontCommonSettingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('platform')) {
      final l$platform = data['platform'];
      result$data['platform'] = (l$platform as String?);
    }
    if (data.containsKey('version')) {
      final l$version = data['version'];
      result$data['version'] = (l$version as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$FrontCommonSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get platform => (_$data['platform'] as String?);

  String? get version => (_$data['version'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('platform')) {
      final l$platform = platform;
      result$data['platform'] = l$platform;
    }
    if (_$data.containsKey('version')) {
      final l$version = version;
      result$data['version'] = l$version;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$FrontCommonSettingInput<Input$FrontCommonSettingInput>
      get copyWith => CopyWith$Input$FrontCommonSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FrontCommonSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$platform = platform;
    final lOther$platform = other.platform;
    if (_$data.containsKey('platform') !=
        other._$data.containsKey('platform')) {
      return false;
    }
    if (l$platform != lOther$platform) {
      return false;
    }
    final l$version = version;
    final lOther$version = other.version;
    if (_$data.containsKey('version') != other._$data.containsKey('version')) {
      return false;
    }
    if (l$version != lOther$version) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$platform = platform;
    final l$version = version;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('platform') ? l$platform : const {},
      _$data.containsKey('version') ? l$version : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$FrontCommonSettingInput<TRes> {
  factory CopyWith$Input$FrontCommonSettingInput(
    Input$FrontCommonSettingInput instance,
    TRes Function(Input$FrontCommonSettingInput) then,
  ) = _CopyWithImpl$Input$FrontCommonSettingInput;

  factory CopyWith$Input$FrontCommonSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FrontCommonSettingInput;

  TRes call({
    String? platform,
    String? version,
    String? user_id,
  });
}

class _CopyWithImpl$Input$FrontCommonSettingInput<TRes>
    implements CopyWith$Input$FrontCommonSettingInput<TRes> {
  _CopyWithImpl$Input$FrontCommonSettingInput(
    this._instance,
    this._then,
  );

  final Input$FrontCommonSettingInput _instance;

  final TRes Function(Input$FrontCommonSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? platform = _undefined,
    Object? version = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$FrontCommonSettingInput._({
        ..._instance._$data,
        if (platform != _undefined) 'platform': (platform as String?),
        if (version != _undefined) 'version': (version as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$FrontCommonSettingInput<TRes>
    implements CopyWith$Input$FrontCommonSettingInput<TRes> {
  _CopyWithStubImpl$Input$FrontCommonSettingInput(this._res);

  TRes _res;

  call({
    String? platform,
    String? version,
    String? user_id,
  }) =>
      _res;
}

class Input$CreateClubSuggestionInput {
  factory Input$CreateClubSuggestionInput({
    required String user_uuid,
    required String club_id,
    String? image,
    String? file_path,
    String? name,
    String? country_code,
    String? phone_number,
    String? url,
    String? type,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? court_type,
    String? note,
    String? cost,
  }) =>
      Input$CreateClubSuggestionInput._({
        r'user_uuid': user_uuid,
        r'club_id': club_id,
        if (image != null) r'image': image,
        if (file_path != null) r'file_path': file_path,
        if (name != null) r'name': name,
        if (country_code != null) r'country_code': country_code,
        if (phone_number != null) r'phone_number': phone_number,
        if (url != null) r'url': url,
        if (type != null) r'type': type,
        if (number_of_member != null) r'number_of_member': number_of_member,
        if (number_of_courts != null) r'number_of_courts': number_of_courts,
        if (is_membership_requre != null)
          r'is_membership_requre': is_membership_requre,
        if (start_time_mon != null) r'start_time_mon': start_time_mon,
        if (end_time_mon != null) r'end_time_mon': end_time_mon,
        if (start_time_tue != null) r'start_time_tue': start_time_tue,
        if (end_time_tue != null) r'end_time_tue': end_time_tue,
        if (start_time_wed != null) r'start_time_wed': start_time_wed,
        if (end_time_wed != null) r'end_time_wed': end_time_wed,
        if (start_time_thu != null) r'start_time_thu': start_time_thu,
        if (end_time_thu != null) r'end_time_thu': end_time_thu,
        if (start_time_fri != null) r'start_time_fri': start_time_fri,
        if (end_time_fri != null) r'end_time_fri': end_time_fri,
        if (start_time_sat != null) r'start_time_sat': start_time_sat,
        if (end_time_sat != null) r'end_time_sat': end_time_sat,
        if (start_time_sun != null) r'start_time_sun': start_time_sun,
        if (end_time_sun != null) r'end_time_sun': end_time_sun,
        if (is_mon_on != null) r'is_mon_on': is_mon_on,
        if (is_tue_on != null) r'is_tue_on': is_tue_on,
        if (is_wed_on != null) r'is_wed_on': is_wed_on,
        if (is_thu_on != null) r'is_thu_on': is_thu_on,
        if (is_fri_on != null) r'is_fri_on': is_fri_on,
        if (is_sat_on != null) r'is_sat_on': is_sat_on,
        if (is_sun_on != null) r'is_sun_on': is_sun_on,
        if (court_type != null) r'court_type': court_type,
        if (note != null) r'note': note,
        if (cost != null) r'cost': cost,
      });

  Input$CreateClubSuggestionInput._(this._$data);

  factory Input$CreateClubSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$user_uuid = data['user_uuid'];
    result$data['user_uuid'] = (l$user_uuid as String);
    final l$club_id = data['club_id'];
    result$data['club_id'] = (l$club_id as String);
    if (data.containsKey('image')) {
      final l$image = data['image'];
      result$data['image'] = (l$image as String?);
    }
    if (data.containsKey('file_path')) {
      final l$file_path = data['file_path'];
      result$data['file_path'] = (l$file_path as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('country_code')) {
      final l$country_code = data['country_code'];
      result$data['country_code'] = (l$country_code as String?);
    }
    if (data.containsKey('phone_number')) {
      final l$phone_number = data['phone_number'];
      result$data['phone_number'] = (l$phone_number as String?);
    }
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('number_of_member')) {
      final l$number_of_member = data['number_of_member'];
      result$data['number_of_member'] = (l$number_of_member as String?);
    }
    if (data.containsKey('number_of_courts')) {
      final l$number_of_courts = data['number_of_courts'];
      result$data['number_of_courts'] = (l$number_of_courts as String?);
    }
    if (data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = data['is_membership_requre'];
      result$data['is_membership_requre'] = (l$is_membership_requre as String?);
    }
    if (data.containsKey('start_time_mon')) {
      final l$start_time_mon = data['start_time_mon'];
      result$data['start_time_mon'] = (l$start_time_mon as String?);
    }
    if (data.containsKey('end_time_mon')) {
      final l$end_time_mon = data['end_time_mon'];
      result$data['end_time_mon'] = (l$end_time_mon as String?);
    }
    if (data.containsKey('start_time_tue')) {
      final l$start_time_tue = data['start_time_tue'];
      result$data['start_time_tue'] = (l$start_time_tue as String?);
    }
    if (data.containsKey('end_time_tue')) {
      final l$end_time_tue = data['end_time_tue'];
      result$data['end_time_tue'] = (l$end_time_tue as String?);
    }
    if (data.containsKey('start_time_wed')) {
      final l$start_time_wed = data['start_time_wed'];
      result$data['start_time_wed'] = (l$start_time_wed as String?);
    }
    if (data.containsKey('end_time_wed')) {
      final l$end_time_wed = data['end_time_wed'];
      result$data['end_time_wed'] = (l$end_time_wed as String?);
    }
    if (data.containsKey('start_time_thu')) {
      final l$start_time_thu = data['start_time_thu'];
      result$data['start_time_thu'] = (l$start_time_thu as String?);
    }
    if (data.containsKey('end_time_thu')) {
      final l$end_time_thu = data['end_time_thu'];
      result$data['end_time_thu'] = (l$end_time_thu as String?);
    }
    if (data.containsKey('start_time_fri')) {
      final l$start_time_fri = data['start_time_fri'];
      result$data['start_time_fri'] = (l$start_time_fri as String?);
    }
    if (data.containsKey('end_time_fri')) {
      final l$end_time_fri = data['end_time_fri'];
      result$data['end_time_fri'] = (l$end_time_fri as String?);
    }
    if (data.containsKey('start_time_sat')) {
      final l$start_time_sat = data['start_time_sat'];
      result$data['start_time_sat'] = (l$start_time_sat as String?);
    }
    if (data.containsKey('end_time_sat')) {
      final l$end_time_sat = data['end_time_sat'];
      result$data['end_time_sat'] = (l$end_time_sat as String?);
    }
    if (data.containsKey('start_time_sun')) {
      final l$start_time_sun = data['start_time_sun'];
      result$data['start_time_sun'] = (l$start_time_sun as String?);
    }
    if (data.containsKey('end_time_sun')) {
      final l$end_time_sun = data['end_time_sun'];
      result$data['end_time_sun'] = (l$end_time_sun as String?);
    }
    if (data.containsKey('is_mon_on')) {
      final l$is_mon_on = data['is_mon_on'];
      result$data['is_mon_on'] = (l$is_mon_on as bool?);
    }
    if (data.containsKey('is_tue_on')) {
      final l$is_tue_on = data['is_tue_on'];
      result$data['is_tue_on'] = (l$is_tue_on as bool?);
    }
    if (data.containsKey('is_wed_on')) {
      final l$is_wed_on = data['is_wed_on'];
      result$data['is_wed_on'] = (l$is_wed_on as bool?);
    }
    if (data.containsKey('is_thu_on')) {
      final l$is_thu_on = data['is_thu_on'];
      result$data['is_thu_on'] = (l$is_thu_on as bool?);
    }
    if (data.containsKey('is_fri_on')) {
      final l$is_fri_on = data['is_fri_on'];
      result$data['is_fri_on'] = (l$is_fri_on as bool?);
    }
    if (data.containsKey('is_sat_on')) {
      final l$is_sat_on = data['is_sat_on'];
      result$data['is_sat_on'] = (l$is_sat_on as bool?);
    }
    if (data.containsKey('is_sun_on')) {
      final l$is_sun_on = data['is_sun_on'];
      result$data['is_sun_on'] = (l$is_sun_on as bool?);
    }
    if (data.containsKey('court_type')) {
      final l$court_type = data['court_type'];
      result$data['court_type'] = (l$court_type as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('cost')) {
      final l$cost = data['cost'];
      result$data['cost'] = (l$cost as String?);
    }
    return Input$CreateClubSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get user_uuid => (_$data['user_uuid'] as String);

  String get club_id => (_$data['club_id'] as String);

  String? get image => (_$data['image'] as String?);

  String? get file_path => (_$data['file_path'] as String?);

  String? get name => (_$data['name'] as String?);

  String? get country_code => (_$data['country_code'] as String?);

  String? get phone_number => (_$data['phone_number'] as String?);

  String? get url => (_$data['url'] as String?);

  String? get type => (_$data['type'] as String?);

  String? get number_of_member => (_$data['number_of_member'] as String?);

  String? get number_of_courts => (_$data['number_of_courts'] as String?);

  String? get is_membership_requre =>
      (_$data['is_membership_requre'] as String?);

  String? get start_time_mon => (_$data['start_time_mon'] as String?);

  String? get end_time_mon => (_$data['end_time_mon'] as String?);

  String? get start_time_tue => (_$data['start_time_tue'] as String?);

  String? get end_time_tue => (_$data['end_time_tue'] as String?);

  String? get start_time_wed => (_$data['start_time_wed'] as String?);

  String? get end_time_wed => (_$data['end_time_wed'] as String?);

  String? get start_time_thu => (_$data['start_time_thu'] as String?);

  String? get end_time_thu => (_$data['end_time_thu'] as String?);

  String? get start_time_fri => (_$data['start_time_fri'] as String?);

  String? get end_time_fri => (_$data['end_time_fri'] as String?);

  String? get start_time_sat => (_$data['start_time_sat'] as String?);

  String? get end_time_sat => (_$data['end_time_sat'] as String?);

  String? get start_time_sun => (_$data['start_time_sun'] as String?);

  String? get end_time_sun => (_$data['end_time_sun'] as String?);

  bool? get is_mon_on => (_$data['is_mon_on'] as bool?);

  bool? get is_tue_on => (_$data['is_tue_on'] as bool?);

  bool? get is_wed_on => (_$data['is_wed_on'] as bool?);

  bool? get is_thu_on => (_$data['is_thu_on'] as bool?);

  bool? get is_fri_on => (_$data['is_fri_on'] as bool?);

  bool? get is_sat_on => (_$data['is_sat_on'] as bool?);

  bool? get is_sun_on => (_$data['is_sun_on'] as bool?);

  String? get court_type => (_$data['court_type'] as String?);

  String? get note => (_$data['note'] as String?);

  String? get cost => (_$data['cost'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$user_uuid = user_uuid;
    result$data['user_uuid'] = l$user_uuid;
    final l$club_id = club_id;
    result$data['club_id'] = l$club_id;
    if (_$data.containsKey('image')) {
      final l$image = image;
      result$data['image'] = l$image;
    }
    if (_$data.containsKey('file_path')) {
      final l$file_path = file_path;
      result$data['file_path'] = l$file_path;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('country_code')) {
      final l$country_code = country_code;
      result$data['country_code'] = l$country_code;
    }
    if (_$data.containsKey('phone_number')) {
      final l$phone_number = phone_number;
      result$data['phone_number'] = l$phone_number;
    }
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('number_of_member')) {
      final l$number_of_member = number_of_member;
      result$data['number_of_member'] = l$number_of_member;
    }
    if (_$data.containsKey('number_of_courts')) {
      final l$number_of_courts = number_of_courts;
      result$data['number_of_courts'] = l$number_of_courts;
    }
    if (_$data.containsKey('is_membership_requre')) {
      final l$is_membership_requre = is_membership_requre;
      result$data['is_membership_requre'] = l$is_membership_requre;
    }
    if (_$data.containsKey('start_time_mon')) {
      final l$start_time_mon = start_time_mon;
      result$data['start_time_mon'] = l$start_time_mon;
    }
    if (_$data.containsKey('end_time_mon')) {
      final l$end_time_mon = end_time_mon;
      result$data['end_time_mon'] = l$end_time_mon;
    }
    if (_$data.containsKey('start_time_tue')) {
      final l$start_time_tue = start_time_tue;
      result$data['start_time_tue'] = l$start_time_tue;
    }
    if (_$data.containsKey('end_time_tue')) {
      final l$end_time_tue = end_time_tue;
      result$data['end_time_tue'] = l$end_time_tue;
    }
    if (_$data.containsKey('start_time_wed')) {
      final l$start_time_wed = start_time_wed;
      result$data['start_time_wed'] = l$start_time_wed;
    }
    if (_$data.containsKey('end_time_wed')) {
      final l$end_time_wed = end_time_wed;
      result$data['end_time_wed'] = l$end_time_wed;
    }
    if (_$data.containsKey('start_time_thu')) {
      final l$start_time_thu = start_time_thu;
      result$data['start_time_thu'] = l$start_time_thu;
    }
    if (_$data.containsKey('end_time_thu')) {
      final l$end_time_thu = end_time_thu;
      result$data['end_time_thu'] = l$end_time_thu;
    }
    if (_$data.containsKey('start_time_fri')) {
      final l$start_time_fri = start_time_fri;
      result$data['start_time_fri'] = l$start_time_fri;
    }
    if (_$data.containsKey('end_time_fri')) {
      final l$end_time_fri = end_time_fri;
      result$data['end_time_fri'] = l$end_time_fri;
    }
    if (_$data.containsKey('start_time_sat')) {
      final l$start_time_sat = start_time_sat;
      result$data['start_time_sat'] = l$start_time_sat;
    }
    if (_$data.containsKey('end_time_sat')) {
      final l$end_time_sat = end_time_sat;
      result$data['end_time_sat'] = l$end_time_sat;
    }
    if (_$data.containsKey('start_time_sun')) {
      final l$start_time_sun = start_time_sun;
      result$data['start_time_sun'] = l$start_time_sun;
    }
    if (_$data.containsKey('end_time_sun')) {
      final l$end_time_sun = end_time_sun;
      result$data['end_time_sun'] = l$end_time_sun;
    }
    if (_$data.containsKey('is_mon_on')) {
      final l$is_mon_on = is_mon_on;
      result$data['is_mon_on'] = l$is_mon_on;
    }
    if (_$data.containsKey('is_tue_on')) {
      final l$is_tue_on = is_tue_on;
      result$data['is_tue_on'] = l$is_tue_on;
    }
    if (_$data.containsKey('is_wed_on')) {
      final l$is_wed_on = is_wed_on;
      result$data['is_wed_on'] = l$is_wed_on;
    }
    if (_$data.containsKey('is_thu_on')) {
      final l$is_thu_on = is_thu_on;
      result$data['is_thu_on'] = l$is_thu_on;
    }
    if (_$data.containsKey('is_fri_on')) {
      final l$is_fri_on = is_fri_on;
      result$data['is_fri_on'] = l$is_fri_on;
    }
    if (_$data.containsKey('is_sat_on')) {
      final l$is_sat_on = is_sat_on;
      result$data['is_sat_on'] = l$is_sat_on;
    }
    if (_$data.containsKey('is_sun_on')) {
      final l$is_sun_on = is_sun_on;
      result$data['is_sun_on'] = l$is_sun_on;
    }
    if (_$data.containsKey('court_type')) {
      final l$court_type = court_type;
      result$data['court_type'] = l$court_type;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('cost')) {
      final l$cost = cost;
      result$data['cost'] = l$cost;
    }
    return result$data;
  }

  CopyWith$Input$CreateClubSuggestionInput<Input$CreateClubSuggestionInput>
      get copyWith => CopyWith$Input$CreateClubSuggestionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateClubSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$club_id = club_id;
    final lOther$club_id = other.club_id;
    if (l$club_id != lOther$club_id) {
      return false;
    }
    final l$image = image;
    final lOther$image = other.image;
    if (_$data.containsKey('image') != other._$data.containsKey('image')) {
      return false;
    }
    if (l$image != lOther$image) {
      return false;
    }
    final l$file_path = file_path;
    final lOther$file_path = other.file_path;
    if (_$data.containsKey('file_path') !=
        other._$data.containsKey('file_path')) {
      return false;
    }
    if (l$file_path != lOther$file_path) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$country_code = country_code;
    final lOther$country_code = other.country_code;
    if (_$data.containsKey('country_code') !=
        other._$data.containsKey('country_code')) {
      return false;
    }
    if (l$country_code != lOther$country_code) {
      return false;
    }
    final l$phone_number = phone_number;
    final lOther$phone_number = other.phone_number;
    if (_$data.containsKey('phone_number') !=
        other._$data.containsKey('phone_number')) {
      return false;
    }
    if (l$phone_number != lOther$phone_number) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$number_of_member = number_of_member;
    final lOther$number_of_member = other.number_of_member;
    if (_$data.containsKey('number_of_member') !=
        other._$data.containsKey('number_of_member')) {
      return false;
    }
    if (l$number_of_member != lOther$number_of_member) {
      return false;
    }
    final l$number_of_courts = number_of_courts;
    final lOther$number_of_courts = other.number_of_courts;
    if (_$data.containsKey('number_of_courts') !=
        other._$data.containsKey('number_of_courts')) {
      return false;
    }
    if (l$number_of_courts != lOther$number_of_courts) {
      return false;
    }
    final l$is_membership_requre = is_membership_requre;
    final lOther$is_membership_requre = other.is_membership_requre;
    if (_$data.containsKey('is_membership_requre') !=
        other._$data.containsKey('is_membership_requre')) {
      return false;
    }
    if (l$is_membership_requre != lOther$is_membership_requre) {
      return false;
    }
    final l$start_time_mon = start_time_mon;
    final lOther$start_time_mon = other.start_time_mon;
    if (_$data.containsKey('start_time_mon') !=
        other._$data.containsKey('start_time_mon')) {
      return false;
    }
    if (l$start_time_mon != lOther$start_time_mon) {
      return false;
    }
    final l$end_time_mon = end_time_mon;
    final lOther$end_time_mon = other.end_time_mon;
    if (_$data.containsKey('end_time_mon') !=
        other._$data.containsKey('end_time_mon')) {
      return false;
    }
    if (l$end_time_mon != lOther$end_time_mon) {
      return false;
    }
    final l$start_time_tue = start_time_tue;
    final lOther$start_time_tue = other.start_time_tue;
    if (_$data.containsKey('start_time_tue') !=
        other._$data.containsKey('start_time_tue')) {
      return false;
    }
    if (l$start_time_tue != lOther$start_time_tue) {
      return false;
    }
    final l$end_time_tue = end_time_tue;
    final lOther$end_time_tue = other.end_time_tue;
    if (_$data.containsKey('end_time_tue') !=
        other._$data.containsKey('end_time_tue')) {
      return false;
    }
    if (l$end_time_tue != lOther$end_time_tue) {
      return false;
    }
    final l$start_time_wed = start_time_wed;
    final lOther$start_time_wed = other.start_time_wed;
    if (_$data.containsKey('start_time_wed') !=
        other._$data.containsKey('start_time_wed')) {
      return false;
    }
    if (l$start_time_wed != lOther$start_time_wed) {
      return false;
    }
    final l$end_time_wed = end_time_wed;
    final lOther$end_time_wed = other.end_time_wed;
    if (_$data.containsKey('end_time_wed') !=
        other._$data.containsKey('end_time_wed')) {
      return false;
    }
    if (l$end_time_wed != lOther$end_time_wed) {
      return false;
    }
    final l$start_time_thu = start_time_thu;
    final lOther$start_time_thu = other.start_time_thu;
    if (_$data.containsKey('start_time_thu') !=
        other._$data.containsKey('start_time_thu')) {
      return false;
    }
    if (l$start_time_thu != lOther$start_time_thu) {
      return false;
    }
    final l$end_time_thu = end_time_thu;
    final lOther$end_time_thu = other.end_time_thu;
    if (_$data.containsKey('end_time_thu') !=
        other._$data.containsKey('end_time_thu')) {
      return false;
    }
    if (l$end_time_thu != lOther$end_time_thu) {
      return false;
    }
    final l$start_time_fri = start_time_fri;
    final lOther$start_time_fri = other.start_time_fri;
    if (_$data.containsKey('start_time_fri') !=
        other._$data.containsKey('start_time_fri')) {
      return false;
    }
    if (l$start_time_fri != lOther$start_time_fri) {
      return false;
    }
    final l$end_time_fri = end_time_fri;
    final lOther$end_time_fri = other.end_time_fri;
    if (_$data.containsKey('end_time_fri') !=
        other._$data.containsKey('end_time_fri')) {
      return false;
    }
    if (l$end_time_fri != lOther$end_time_fri) {
      return false;
    }
    final l$start_time_sat = start_time_sat;
    final lOther$start_time_sat = other.start_time_sat;
    if (_$data.containsKey('start_time_sat') !=
        other._$data.containsKey('start_time_sat')) {
      return false;
    }
    if (l$start_time_sat != lOther$start_time_sat) {
      return false;
    }
    final l$end_time_sat = end_time_sat;
    final lOther$end_time_sat = other.end_time_sat;
    if (_$data.containsKey('end_time_sat') !=
        other._$data.containsKey('end_time_sat')) {
      return false;
    }
    if (l$end_time_sat != lOther$end_time_sat) {
      return false;
    }
    final l$start_time_sun = start_time_sun;
    final lOther$start_time_sun = other.start_time_sun;
    if (_$data.containsKey('start_time_sun') !=
        other._$data.containsKey('start_time_sun')) {
      return false;
    }
    if (l$start_time_sun != lOther$start_time_sun) {
      return false;
    }
    final l$end_time_sun = end_time_sun;
    final lOther$end_time_sun = other.end_time_sun;
    if (_$data.containsKey('end_time_sun') !=
        other._$data.containsKey('end_time_sun')) {
      return false;
    }
    if (l$end_time_sun != lOther$end_time_sun) {
      return false;
    }
    final l$is_mon_on = is_mon_on;
    final lOther$is_mon_on = other.is_mon_on;
    if (_$data.containsKey('is_mon_on') !=
        other._$data.containsKey('is_mon_on')) {
      return false;
    }
    if (l$is_mon_on != lOther$is_mon_on) {
      return false;
    }
    final l$is_tue_on = is_tue_on;
    final lOther$is_tue_on = other.is_tue_on;
    if (_$data.containsKey('is_tue_on') !=
        other._$data.containsKey('is_tue_on')) {
      return false;
    }
    if (l$is_tue_on != lOther$is_tue_on) {
      return false;
    }
    final l$is_wed_on = is_wed_on;
    final lOther$is_wed_on = other.is_wed_on;
    if (_$data.containsKey('is_wed_on') !=
        other._$data.containsKey('is_wed_on')) {
      return false;
    }
    if (l$is_wed_on != lOther$is_wed_on) {
      return false;
    }
    final l$is_thu_on = is_thu_on;
    final lOther$is_thu_on = other.is_thu_on;
    if (_$data.containsKey('is_thu_on') !=
        other._$data.containsKey('is_thu_on')) {
      return false;
    }
    if (l$is_thu_on != lOther$is_thu_on) {
      return false;
    }
    final l$is_fri_on = is_fri_on;
    final lOther$is_fri_on = other.is_fri_on;
    if (_$data.containsKey('is_fri_on') !=
        other._$data.containsKey('is_fri_on')) {
      return false;
    }
    if (l$is_fri_on != lOther$is_fri_on) {
      return false;
    }
    final l$is_sat_on = is_sat_on;
    final lOther$is_sat_on = other.is_sat_on;
    if (_$data.containsKey('is_sat_on') !=
        other._$data.containsKey('is_sat_on')) {
      return false;
    }
    if (l$is_sat_on != lOther$is_sat_on) {
      return false;
    }
    final l$is_sun_on = is_sun_on;
    final lOther$is_sun_on = other.is_sun_on;
    if (_$data.containsKey('is_sun_on') !=
        other._$data.containsKey('is_sun_on')) {
      return false;
    }
    if (l$is_sun_on != lOther$is_sun_on) {
      return false;
    }
    final l$court_type = court_type;
    final lOther$court_type = other.court_type;
    if (_$data.containsKey('court_type') !=
        other._$data.containsKey('court_type')) {
      return false;
    }
    if (l$court_type != lOther$court_type) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$cost = cost;
    final lOther$cost = other.cost;
    if (_$data.containsKey('cost') != other._$data.containsKey('cost')) {
      return false;
    }
    if (l$cost != lOther$cost) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_uuid = user_uuid;
    final l$club_id = club_id;
    final l$image = image;
    final l$file_path = file_path;
    final l$name = name;
    final l$country_code = country_code;
    final l$phone_number = phone_number;
    final l$url = url;
    final l$type = type;
    final l$number_of_member = number_of_member;
    final l$number_of_courts = number_of_courts;
    final l$is_membership_requre = is_membership_requre;
    final l$start_time_mon = start_time_mon;
    final l$end_time_mon = end_time_mon;
    final l$start_time_tue = start_time_tue;
    final l$end_time_tue = end_time_tue;
    final l$start_time_wed = start_time_wed;
    final l$end_time_wed = end_time_wed;
    final l$start_time_thu = start_time_thu;
    final l$end_time_thu = end_time_thu;
    final l$start_time_fri = start_time_fri;
    final l$end_time_fri = end_time_fri;
    final l$start_time_sat = start_time_sat;
    final l$end_time_sat = end_time_sat;
    final l$start_time_sun = start_time_sun;
    final l$end_time_sun = end_time_sun;
    final l$is_mon_on = is_mon_on;
    final l$is_tue_on = is_tue_on;
    final l$is_wed_on = is_wed_on;
    final l$is_thu_on = is_thu_on;
    final l$is_fri_on = is_fri_on;
    final l$is_sat_on = is_sat_on;
    final l$is_sun_on = is_sun_on;
    final l$court_type = court_type;
    final l$note = note;
    final l$cost = cost;
    return Object.hashAll([
      l$user_uuid,
      l$club_id,
      _$data.containsKey('image') ? l$image : const {},
      _$data.containsKey('file_path') ? l$file_path : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('country_code') ? l$country_code : const {},
      _$data.containsKey('phone_number') ? l$phone_number : const {},
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('number_of_member') ? l$number_of_member : const {},
      _$data.containsKey('number_of_courts') ? l$number_of_courts : const {},
      _$data.containsKey('is_membership_requre')
          ? l$is_membership_requre
          : const {},
      _$data.containsKey('start_time_mon') ? l$start_time_mon : const {},
      _$data.containsKey('end_time_mon') ? l$end_time_mon : const {},
      _$data.containsKey('start_time_tue') ? l$start_time_tue : const {},
      _$data.containsKey('end_time_tue') ? l$end_time_tue : const {},
      _$data.containsKey('start_time_wed') ? l$start_time_wed : const {},
      _$data.containsKey('end_time_wed') ? l$end_time_wed : const {},
      _$data.containsKey('start_time_thu') ? l$start_time_thu : const {},
      _$data.containsKey('end_time_thu') ? l$end_time_thu : const {},
      _$data.containsKey('start_time_fri') ? l$start_time_fri : const {},
      _$data.containsKey('end_time_fri') ? l$end_time_fri : const {},
      _$data.containsKey('start_time_sat') ? l$start_time_sat : const {},
      _$data.containsKey('end_time_sat') ? l$end_time_sat : const {},
      _$data.containsKey('start_time_sun') ? l$start_time_sun : const {},
      _$data.containsKey('end_time_sun') ? l$end_time_sun : const {},
      _$data.containsKey('is_mon_on') ? l$is_mon_on : const {},
      _$data.containsKey('is_tue_on') ? l$is_tue_on : const {},
      _$data.containsKey('is_wed_on') ? l$is_wed_on : const {},
      _$data.containsKey('is_thu_on') ? l$is_thu_on : const {},
      _$data.containsKey('is_fri_on') ? l$is_fri_on : const {},
      _$data.containsKey('is_sat_on') ? l$is_sat_on : const {},
      _$data.containsKey('is_sun_on') ? l$is_sun_on : const {},
      _$data.containsKey('court_type') ? l$court_type : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('cost') ? l$cost : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateClubSuggestionInput<TRes> {
  factory CopyWith$Input$CreateClubSuggestionInput(
    Input$CreateClubSuggestionInput instance,
    TRes Function(Input$CreateClubSuggestionInput) then,
  ) = _CopyWithImpl$Input$CreateClubSuggestionInput;

  factory CopyWith$Input$CreateClubSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateClubSuggestionInput;

  TRes call({
    String? user_uuid,
    String? club_id,
    String? image,
    String? file_path,
    String? name,
    String? country_code,
    String? phone_number,
    String? url,
    String? type,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? court_type,
    String? note,
    String? cost,
  });
}

class _CopyWithImpl$Input$CreateClubSuggestionInput<TRes>
    implements CopyWith$Input$CreateClubSuggestionInput<TRes> {
  _CopyWithImpl$Input$CreateClubSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$CreateClubSuggestionInput _instance;

  final TRes Function(Input$CreateClubSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_uuid = _undefined,
    Object? club_id = _undefined,
    Object? image = _undefined,
    Object? file_path = _undefined,
    Object? name = _undefined,
    Object? country_code = _undefined,
    Object? phone_number = _undefined,
    Object? url = _undefined,
    Object? type = _undefined,
    Object? number_of_member = _undefined,
    Object? number_of_courts = _undefined,
    Object? is_membership_requre = _undefined,
    Object? start_time_mon = _undefined,
    Object? end_time_mon = _undefined,
    Object? start_time_tue = _undefined,
    Object? end_time_tue = _undefined,
    Object? start_time_wed = _undefined,
    Object? end_time_wed = _undefined,
    Object? start_time_thu = _undefined,
    Object? end_time_thu = _undefined,
    Object? start_time_fri = _undefined,
    Object? end_time_fri = _undefined,
    Object? start_time_sat = _undefined,
    Object? end_time_sat = _undefined,
    Object? start_time_sun = _undefined,
    Object? end_time_sun = _undefined,
    Object? is_mon_on = _undefined,
    Object? is_tue_on = _undefined,
    Object? is_wed_on = _undefined,
    Object? is_thu_on = _undefined,
    Object? is_fri_on = _undefined,
    Object? is_sat_on = _undefined,
    Object? is_sun_on = _undefined,
    Object? court_type = _undefined,
    Object? note = _undefined,
    Object? cost = _undefined,
  }) =>
      _then(Input$CreateClubSuggestionInput._({
        ..._instance._$data,
        if (user_uuid != _undefined && user_uuid != null)
          'user_uuid': (user_uuid as String),
        if (club_id != _undefined && club_id != null)
          'club_id': (club_id as String),
        if (image != _undefined) 'image': (image as String?),
        if (file_path != _undefined) 'file_path': (file_path as String?),
        if (name != _undefined) 'name': (name as String?),
        if (country_code != _undefined)
          'country_code': (country_code as String?),
        if (phone_number != _undefined)
          'phone_number': (phone_number as String?),
        if (url != _undefined) 'url': (url as String?),
        if (type != _undefined) 'type': (type as String?),
        if (number_of_member != _undefined)
          'number_of_member': (number_of_member as String?),
        if (number_of_courts != _undefined)
          'number_of_courts': (number_of_courts as String?),
        if (is_membership_requre != _undefined)
          'is_membership_requre': (is_membership_requre as String?),
        if (start_time_mon != _undefined)
          'start_time_mon': (start_time_mon as String?),
        if (end_time_mon != _undefined)
          'end_time_mon': (end_time_mon as String?),
        if (start_time_tue != _undefined)
          'start_time_tue': (start_time_tue as String?),
        if (end_time_tue != _undefined)
          'end_time_tue': (end_time_tue as String?),
        if (start_time_wed != _undefined)
          'start_time_wed': (start_time_wed as String?),
        if (end_time_wed != _undefined)
          'end_time_wed': (end_time_wed as String?),
        if (start_time_thu != _undefined)
          'start_time_thu': (start_time_thu as String?),
        if (end_time_thu != _undefined)
          'end_time_thu': (end_time_thu as String?),
        if (start_time_fri != _undefined)
          'start_time_fri': (start_time_fri as String?),
        if (end_time_fri != _undefined)
          'end_time_fri': (end_time_fri as String?),
        if (start_time_sat != _undefined)
          'start_time_sat': (start_time_sat as String?),
        if (end_time_sat != _undefined)
          'end_time_sat': (end_time_sat as String?),
        if (start_time_sun != _undefined)
          'start_time_sun': (start_time_sun as String?),
        if (end_time_sun != _undefined)
          'end_time_sun': (end_time_sun as String?),
        if (is_mon_on != _undefined) 'is_mon_on': (is_mon_on as bool?),
        if (is_tue_on != _undefined) 'is_tue_on': (is_tue_on as bool?),
        if (is_wed_on != _undefined) 'is_wed_on': (is_wed_on as bool?),
        if (is_thu_on != _undefined) 'is_thu_on': (is_thu_on as bool?),
        if (is_fri_on != _undefined) 'is_fri_on': (is_fri_on as bool?),
        if (is_sat_on != _undefined) 'is_sat_on': (is_sat_on as bool?),
        if (is_sun_on != _undefined) 'is_sun_on': (is_sun_on as bool?),
        if (court_type != _undefined) 'court_type': (court_type as String?),
        if (note != _undefined) 'note': (note as String?),
        if (cost != _undefined) 'cost': (cost as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateClubSuggestionInput<TRes>
    implements CopyWith$Input$CreateClubSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$CreateClubSuggestionInput(this._res);

  TRes _res;

  call({
    String? user_uuid,
    String? club_id,
    String? image,
    String? file_path,
    String? name,
    String? country_code,
    String? phone_number,
    String? url,
    String? type,
    String? number_of_member,
    String? number_of_courts,
    String? is_membership_requre,
    String? start_time_mon,
    String? end_time_mon,
    String? start_time_tue,
    String? end_time_tue,
    String? start_time_wed,
    String? end_time_wed,
    String? start_time_thu,
    String? end_time_thu,
    String? start_time_fri,
    String? end_time_fri,
    String? start_time_sat,
    String? end_time_sat,
    String? start_time_sun,
    String? end_time_sun,
    bool? is_mon_on,
    bool? is_tue_on,
    bool? is_wed_on,
    bool? is_thu_on,
    bool? is_fri_on,
    bool? is_sat_on,
    bool? is_sun_on,
    String? court_type,
    String? note,
    String? cost,
  }) =>
      _res;
}

class Input$LessonPaginationInput {
  factory Input$LessonPaginationInput({
    required int offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? lesson_creator,
  }) =>
      Input$LessonPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (club_name != null) r'club_name': club_name,
        if (skill_level != null) r'skill_level': skill_level,
        if (status != null) r'status': status,
        if (locations != null) r'locations': locations,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (is_event != null) r'is_event': is_event,
        if (lesson_creator != null) r'lesson_creator': lesson_creator,
      });

  Input$LessonPaginationInput._(this._$data);

  factory Input$LessonPaginationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('lesson_creator')) {
      final l$lesson_creator = data['lesson_creator'];
      result$data['lesson_creator'] = (l$lesson_creator as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    return Input$LessonPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get radius => (_$data['radius'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  List<String?>? get lesson_creator =>
      (_$data['lesson_creator'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('lesson_creator')) {
      final l$lesson_creator = lesson_creator;
      result$data['lesson_creator'] = l$lesson_creator?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$LessonPaginationInput<Input$LessonPaginationInput>
      get copyWith => CopyWith$Input$LessonPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LessonPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$lesson_creator = lesson_creator;
    final lOther$lesson_creator = other.lesson_creator;
    if (_$data.containsKey('lesson_creator') !=
        other._$data.containsKey('lesson_creator')) {
      return false;
    }
    if (l$lesson_creator != null && lOther$lesson_creator != null) {
      if (l$lesson_creator.length != lOther$lesson_creator.length) {
        return false;
      }
      for (int i = 0; i < l$lesson_creator.length; i++) {
        final l$lesson_creator$entry = l$lesson_creator[i];
        final lOther$lesson_creator$entry = lOther$lesson_creator[i];
        if (l$lesson_creator$entry != lOther$lesson_creator$entry) {
          return false;
        }
      }
    } else if (l$lesson_creator != lOther$lesson_creator) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$club_name = club_name;
    final l$skill_level = skill_level;
    final l$status = status;
    final l$locations = locations;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$is_event = is_event;
    final l$lesson_creator = lesson_creator;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('lesson_creator')
          ? l$lesson_creator == null
              ? null
              : Object.hashAll(l$lesson_creator.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$LessonPaginationInput<TRes> {
  factory CopyWith$Input$LessonPaginationInput(
    Input$LessonPaginationInput instance,
    TRes Function(Input$LessonPaginationInput) then,
  ) = _CopyWithImpl$Input$LessonPaginationInput;

  factory CopyWith$Input$LessonPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LessonPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? lesson_creator,
  });
}

class _CopyWithImpl$Input$LessonPaginationInput<TRes>
    implements CopyWith$Input$LessonPaginationInput<TRes> {
  _CopyWithImpl$Input$LessonPaginationInput(
    this._instance,
    this._then,
  );

  final Input$LessonPaginationInput _instance;

  final TRes Function(Input$LessonPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? club_name = _undefined,
    Object? skill_level = _undefined,
    Object? status = _undefined,
    Object? locations = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? is_event = _undefined,
    Object? lesson_creator = _undefined,
  }) =>
      _then(Input$LessonPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (status != _undefined) 'status': (status as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (radius != _undefined) 'radius': (radius as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (lesson_creator != _undefined)
          'lesson_creator': (lesson_creator as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$LessonPaginationInput<TRes>
    implements CopyWith$Input$LessonPaginationInput<TRes> {
  _CopyWithStubImpl$Input$LessonPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    int? is_event,
    List<String?>? lesson_creator,
  }) =>
      _res;
}

class Input$viewLessonInput {
  factory Input$viewLessonInput({required String uuid}) =>
      Input$viewLessonInput._({
        r'uuid': uuid,
      });

  Input$viewLessonInput._(this._$data);

  factory Input$viewLessonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewLessonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewLessonInput<Input$viewLessonInput> get copyWith =>
      CopyWith$Input$viewLessonInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewLessonInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewLessonInput<TRes> {
  factory CopyWith$Input$viewLessonInput(
    Input$viewLessonInput instance,
    TRes Function(Input$viewLessonInput) then,
  ) = _CopyWithImpl$Input$viewLessonInput;

  factory CopyWith$Input$viewLessonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewLessonInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewLessonInput<TRes>
    implements CopyWith$Input$viewLessonInput<TRes> {
  _CopyWithImpl$Input$viewLessonInput(
    this._instance,
    this._then,
  );

  final Input$viewLessonInput _instance;

  final TRes Function(Input$viewLessonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewLessonInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewLessonInput<TRes>
    implements CopyWith$Input$viewLessonInput<TRes> {
  _CopyWithStubImpl$Input$viewLessonInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$GetCoachInput {
  factory Input$GetCoachInput({
    String? uuid,
    String? logged_in_user,
  }) =>
      Input$GetCoachInput._({
        if (uuid != null) r'uuid': uuid,
        if (logged_in_user != null) r'logged_in_user': logged_in_user,
      });

  Input$GetCoachInput._(this._$data);

  factory Input$GetCoachInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('logged_in_user')) {
      final l$logged_in_user = data['logged_in_user'];
      result$data['logged_in_user'] = (l$logged_in_user as String?);
    }
    return Input$GetCoachInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  String? get logged_in_user => (_$data['logged_in_user'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('logged_in_user')) {
      final l$logged_in_user = logged_in_user;
      result$data['logged_in_user'] = l$logged_in_user;
    }
    return result$data;
  }

  CopyWith$Input$GetCoachInput<Input$GetCoachInput> get copyWith =>
      CopyWith$Input$GetCoachInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GetCoachInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$logged_in_user = logged_in_user;
    final lOther$logged_in_user = other.logged_in_user;
    if (_$data.containsKey('logged_in_user') !=
        other._$data.containsKey('logged_in_user')) {
      return false;
    }
    if (l$logged_in_user != lOther$logged_in_user) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$logged_in_user = logged_in_user;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('logged_in_user') ? l$logged_in_user : const {},
    ]);
  }
}

abstract class CopyWith$Input$GetCoachInput<TRes> {
  factory CopyWith$Input$GetCoachInput(
    Input$GetCoachInput instance,
    TRes Function(Input$GetCoachInput) then,
  ) = _CopyWithImpl$Input$GetCoachInput;

  factory CopyWith$Input$GetCoachInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GetCoachInput;

  TRes call({
    String? uuid,
    String? logged_in_user,
  });
}

class _CopyWithImpl$Input$GetCoachInput<TRes>
    implements CopyWith$Input$GetCoachInput<TRes> {
  _CopyWithImpl$Input$GetCoachInput(
    this._instance,
    this._then,
  );

  final Input$GetCoachInput _instance;

  final TRes Function(Input$GetCoachInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? logged_in_user = _undefined,
  }) =>
      _then(Input$GetCoachInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (logged_in_user != _undefined)
          'logged_in_user': (logged_in_user as String?),
      }));
}

class _CopyWithStubImpl$Input$GetCoachInput<TRes>
    implements CopyWith$Input$GetCoachInput<TRes> {
  _CopyWithStubImpl$Input$GetCoachInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? logged_in_user,
  }) =>
      _res;
}

class Input$RecommendationInput {
  factory Input$RecommendationInput({int? recommendation}) =>
      Input$RecommendationInput._({
        if (recommendation != null) r'recommendation': recommendation,
      });

  Input$RecommendationInput._(this._$data);

  factory Input$RecommendationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('recommendation')) {
      final l$recommendation = data['recommendation'];
      result$data['recommendation'] = (l$recommendation as int?);
    }
    return Input$RecommendationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get recommendation => (_$data['recommendation'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('recommendation')) {
      final l$recommendation = recommendation;
      result$data['recommendation'] = l$recommendation;
    }
    return result$data;
  }

  CopyWith$Input$RecommendationInput<Input$RecommendationInput> get copyWith =>
      CopyWith$Input$RecommendationInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RecommendationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$recommendation = recommendation;
    final lOther$recommendation = other.recommendation;
    if (_$data.containsKey('recommendation') !=
        other._$data.containsKey('recommendation')) {
      return false;
    }
    if (l$recommendation != lOther$recommendation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$recommendation = recommendation;
    return Object.hashAll(
        [_$data.containsKey('recommendation') ? l$recommendation : const {}]);
  }
}

abstract class CopyWith$Input$RecommendationInput<TRes> {
  factory CopyWith$Input$RecommendationInput(
    Input$RecommendationInput instance,
    TRes Function(Input$RecommendationInput) then,
  ) = _CopyWithImpl$Input$RecommendationInput;

  factory CopyWith$Input$RecommendationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RecommendationInput;

  TRes call({int? recommendation});
}

class _CopyWithImpl$Input$RecommendationInput<TRes>
    implements CopyWith$Input$RecommendationInput<TRes> {
  _CopyWithImpl$Input$RecommendationInput(
    this._instance,
    this._then,
  );

  final Input$RecommendationInput _instance;

  final TRes Function(Input$RecommendationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? recommendation = _undefined}) =>
      _then(Input$RecommendationInput._({
        ..._instance._$data,
        if (recommendation != _undefined)
          'recommendation': (recommendation as int?),
      }));
}

class _CopyWithStubImpl$Input$RecommendationInput<TRes>
    implements CopyWith$Input$RecommendationInput<TRes> {
  _CopyWithStubImpl$Input$RecommendationInput(this._res);

  TRes _res;

  call({int? recommendation}) => _res;
}

class Input$OpenLessonInput {
  factory Input$OpenLessonInput({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
  }) =>
      Input$OpenLessonInput._({
        if (user_name != null) r'user_name': user_name,
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
        if (timezone != null) r'timezone': timezone,
      });

  Input$OpenLessonInput._(this._$data);

  factory Input$OpenLessonInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_name')) {
      final l$user_name = data['user_name'];
      result$data['user_name'] = (l$user_name as String?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$OpenLessonInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_name => (_$data['user_name'] as String?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_name')) {
      final l$user_name = user_name;
      result$data['user_name'] = l$user_name;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$OpenLessonInput<Input$OpenLessonInput> get copyWith =>
      CopyWith$Input$OpenLessonInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpenLessonInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_name = user_name;
    final lOther$user_name = other.user_name;
    if (_$data.containsKey('user_name') !=
        other._$data.containsKey('user_name')) {
      return false;
    }
    if (l$user_name != lOther$user_name) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_name = user_name;
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    final l$timezone = timezone;
    return Object.hashAll([
      _$data.containsKey('user_name') ? l$user_name : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpenLessonInput<TRes> {
  factory CopyWith$Input$OpenLessonInput(
    Input$OpenLessonInput instance,
    TRes Function(Input$OpenLessonInput) then,
  ) = _CopyWithImpl$Input$OpenLessonInput;

  factory CopyWith$Input$OpenLessonInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OpenLessonInput;

  TRes call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OpenLessonInput<TRes>
    implements CopyWith$Input$OpenLessonInput<TRes> {
  _CopyWithImpl$Input$OpenLessonInput(
    this._instance,
    this._then,
  );

  final Input$OpenLessonInput _instance;

  final TRes Function(Input$OpenLessonInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_name = _undefined,
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OpenLessonInput._({
        ..._instance._$data,
        if (user_name != _undefined) 'user_name': (user_name as String?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$OpenLessonInput<TRes>
    implements CopyWith$Input$OpenLessonInput<TRes> {
  _CopyWithStubImpl$Input$OpenLessonInput(this._res);

  TRes _res;

  call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
  }) =>
      _res;
}

class Input$ScheduleLessonListFrontPaginationInput {
  factory Input$ScheduleLessonListFrontPaginationInput({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      Input$ScheduleLessonListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schedual_type != null) r'schedual_type': schedual_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
        if (timezone != null) r'timezone': timezone,
      });

  Input$ScheduleLessonListFrontPaginationInput._(this._$data);

  factory Input$ScheduleLessonListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schedual_type')) {
      final l$schedual_type = data['schedual_type'];
      result$data['schedual_type'] = (l$schedual_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$ScheduleLessonListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schedual_type => (_$data['schedual_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schedual_type')) {
      final l$schedual_type = schedual_type;
      result$data['schedual_type'] = l$schedual_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$ScheduleLessonListFrontPaginationInput<
          Input$ScheduleLessonListFrontPaginationInput>
      get copyWith => CopyWith$Input$ScheduleLessonListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ScheduleLessonListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schedual_type = schedual_type;
    final lOther$schedual_type = other.schedual_type;
    if (_$data.containsKey('schedual_type') !=
        other._$data.containsKey('schedual_type')) {
      return false;
    }
    if (l$schedual_type != lOther$schedual_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schedual_type = schedual_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$schdeuled_type = schdeuled_type;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    final l$timezone = timezone;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schedual_type') ? l$schedual_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$ScheduleLessonListFrontPaginationInput<TRes> {
  factory CopyWith$Input$ScheduleLessonListFrontPaginationInput(
    Input$ScheduleLessonListFrontPaginationInput instance,
    TRes Function(Input$ScheduleLessonListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$ScheduleLessonListFrontPaginationInput;

  factory CopyWith$Input$ScheduleLessonListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ScheduleLessonListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  });
}

class _CopyWithImpl$Input$ScheduleLessonListFrontPaginationInput<TRes>
    implements CopyWith$Input$ScheduleLessonListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$ScheduleLessonListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$ScheduleLessonListFrontPaginationInput _instance;

  final TRes Function(Input$ScheduleLessonListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schedual_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? schdeuled_type = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$ScheduleLessonListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schedual_type != _undefined)
          'schedual_type': (schedual_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$ScheduleLessonListFrontPaginationInput<TRes>
    implements CopyWith$Input$ScheduleLessonListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$ScheduleLessonListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schedual_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      _res;
}

class Input$PastLessonListFrontPaginationInput {
  factory Input$PastLessonListFrontPaginationInput({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
    String? timezone,
  }) =>
      Input$PastLessonListFrontPaginationInput._({
        if (match_title != null) r'match_title': match_title,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (organized_by != null) r'organized_by': organized_by,
        if (matchlevel != null) r'matchlevel': matchlevel,
        if (matchlevel_label != null) r'matchlevel_label': matchlevel_label,
        if (total_players != null) r'total_players': total_players,
        if (is_booked_court != null) r'is_booked_court': is_booked_court,
        if (timezone != null) r'timezone': timezone,
      });

  Input$PastLessonListFrontPaginationInput._(this._$data);

  factory Input$PastLessonListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('matchlevel')) {
      final l$matchlevel = data['matchlevel'];
      result$data['matchlevel'] = (l$matchlevel as String?);
    }
    if (data.containsKey('matchlevel_label')) {
      final l$matchlevel_label = data['matchlevel_label'];
      result$data['matchlevel_label'] = (l$matchlevel_label as String?);
    }
    if (data.containsKey('total_players')) {
      final l$total_players = data['total_players'];
      result$data['total_players'] = (l$total_players as int?);
    }
    if (data.containsKey('is_booked_court')) {
      final l$is_booked_court = data['is_booked_court'];
      result$data['is_booked_court'] = (l$is_booked_court as int?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$PastLessonListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_title => (_$data['match_title'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get matchlevel => (_$data['matchlevel'] as String?);

  String? get matchlevel_label => (_$data['matchlevel_label'] as String?);

  int? get total_players => (_$data['total_players'] as int?);

  int? get is_booked_court => (_$data['is_booked_court'] as int?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('matchlevel')) {
      final l$matchlevel = matchlevel;
      result$data['matchlevel'] = l$matchlevel;
    }
    if (_$data.containsKey('matchlevel_label')) {
      final l$matchlevel_label = matchlevel_label;
      result$data['matchlevel_label'] = l$matchlevel_label;
    }
    if (_$data.containsKey('total_players')) {
      final l$total_players = total_players;
      result$data['total_players'] = l$total_players;
    }
    if (_$data.containsKey('is_booked_court')) {
      final l$is_booked_court = is_booked_court;
      result$data['is_booked_court'] = l$is_booked_court;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$PastLessonListFrontPaginationInput<
          Input$PastLessonListFrontPaginationInput>
      get copyWith => CopyWith$Input$PastLessonListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PastLessonListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$matchlevel = matchlevel;
    final lOther$matchlevel = other.matchlevel;
    if (_$data.containsKey('matchlevel') !=
        other._$data.containsKey('matchlevel')) {
      return false;
    }
    if (l$matchlevel != lOther$matchlevel) {
      return false;
    }
    final l$matchlevel_label = matchlevel_label;
    final lOther$matchlevel_label = other.matchlevel_label;
    if (_$data.containsKey('matchlevel_label') !=
        other._$data.containsKey('matchlevel_label')) {
      return false;
    }
    if (l$matchlevel_label != lOther$matchlevel_label) {
      return false;
    }
    final l$total_players = total_players;
    final lOther$total_players = other.total_players;
    if (_$data.containsKey('total_players') !=
        other._$data.containsKey('total_players')) {
      return false;
    }
    if (l$total_players != lOther$total_players) {
      return false;
    }
    final l$is_booked_court = is_booked_court;
    final lOther$is_booked_court = other.is_booked_court;
    if (_$data.containsKey('is_booked_court') !=
        other._$data.containsKey('is_booked_court')) {
      return false;
    }
    if (l$is_booked_court != lOther$is_booked_court) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_title = match_title;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$organized_by = organized_by;
    final l$matchlevel = matchlevel;
    final l$matchlevel_label = matchlevel_label;
    final l$total_players = total_players;
    final l$is_booked_court = is_booked_court;
    final l$timezone = timezone;
    return Object.hashAll([
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('matchlevel') ? l$matchlevel : const {},
      _$data.containsKey('matchlevel_label') ? l$matchlevel_label : const {},
      _$data.containsKey('total_players') ? l$total_players : const {},
      _$data.containsKey('is_booked_court') ? l$is_booked_court : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$PastLessonListFrontPaginationInput<TRes> {
  factory CopyWith$Input$PastLessonListFrontPaginationInput(
    Input$PastLessonListFrontPaginationInput instance,
    TRes Function(Input$PastLessonListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$PastLessonListFrontPaginationInput;

  factory CopyWith$Input$PastLessonListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PastLessonListFrontPaginationInput;

  TRes call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
    String? timezone,
  });
}

class _CopyWithImpl$Input$PastLessonListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastLessonListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$PastLessonListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$PastLessonListFrontPaginationInput _instance;

  final TRes Function(Input$PastLessonListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_title = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? organized_by = _undefined,
    Object? matchlevel = _undefined,
    Object? matchlevel_label = _undefined,
    Object? total_players = _undefined,
    Object? is_booked_court = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$PastLessonListFrontPaginationInput._({
        ..._instance._$data,
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (matchlevel != _undefined) 'matchlevel': (matchlevel as String?),
        if (matchlevel_label != _undefined)
          'matchlevel_label': (matchlevel_label as String?),
        if (total_players != _undefined)
          'total_players': (total_players as int?),
        if (is_booked_court != _undefined)
          'is_booked_court': (is_booked_court as int?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$PastLessonListFrontPaginationInput<TRes>
    implements CopyWith$Input$PastLessonListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$PastLessonListFrontPaginationInput(this._res);

  TRes _res;

  call({
    String? match_title,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? radius,
    double? latitude,
    double? longitude,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    String? invitation_status,
    String? schdeuled_type,
    List<String?>? organized_by,
    String? matchlevel,
    String? matchlevel_label,
    int? total_players,
    int? is_booked_court,
    String? timezone,
  }) =>
      _res;
}

class Input$deleteCoachInput {
  factory Input$deleteCoachInput({required String uuid}) =>
      Input$deleteCoachInput._({
        r'uuid': uuid,
      });

  Input$deleteCoachInput._(this._$data);

  factory Input$deleteCoachInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleteCoachInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleteCoachInput<Input$deleteCoachInput> get copyWith =>
      CopyWith$Input$deleteCoachInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteCoachInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleteCoachInput<TRes> {
  factory CopyWith$Input$deleteCoachInput(
    Input$deleteCoachInput instance,
    TRes Function(Input$deleteCoachInput) then,
  ) = _CopyWithImpl$Input$deleteCoachInput;

  factory CopyWith$Input$deleteCoachInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteCoachInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleteCoachInput<TRes>
    implements CopyWith$Input$deleteCoachInput<TRes> {
  _CopyWithImpl$Input$deleteCoachInput(
    this._instance,
    this._then,
  );

  final Input$deleteCoachInput _instance;

  final TRes Function(Input$deleteCoachInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteCoachInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleteCoachInput<TRes>
    implements CopyWith$Input$deleteCoachInput<TRes> {
  _CopyWithStubImpl$Input$deleteCoachInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$deleUserCoachInput {
  factory Input$deleUserCoachInput({required String uuid}) =>
      Input$deleUserCoachInput._({
        r'uuid': uuid,
      });

  Input$deleUserCoachInput._(this._$data);

  factory Input$deleUserCoachInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$deleUserCoachInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$deleUserCoachInput<Input$deleUserCoachInput> get copyWith =>
      CopyWith$Input$deleUserCoachInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleUserCoachInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$deleUserCoachInput<TRes> {
  factory CopyWith$Input$deleUserCoachInput(
    Input$deleUserCoachInput instance,
    TRes Function(Input$deleUserCoachInput) then,
  ) = _CopyWithImpl$Input$deleUserCoachInput;

  factory CopyWith$Input$deleUserCoachInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleUserCoachInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$deleUserCoachInput<TRes>
    implements CopyWith$Input$deleUserCoachInput<TRes> {
  _CopyWithImpl$Input$deleUserCoachInput(
    this._instance,
    this._then,
  );

  final Input$deleUserCoachInput _instance;

  final TRes Function(Input$deleUserCoachInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleUserCoachInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$deleUserCoachInput<TRes>
    implements CopyWith$Input$deleUserCoachInput<TRes> {
  _CopyWithStubImpl$Input$deleUserCoachInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$deleteAlInput {
  factory Input$deleteAlInput({List<String?>? uuid}) => Input$deleteAlInput._({
        if (uuid != null) r'uuid': uuid,
      });

  Input$deleteAlInput._(this._$data);

  factory Input$deleteAlInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          (l$uuid as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    return Input$deleteAlInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String?>? get uuid => (_$data['uuid'] as List<String?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$deleteAlInput<Input$deleteAlInput> get copyWith =>
      CopyWith$Input$deleteAlInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$deleteAlInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != null && lOther$uuid != null) {
      if (l$uuid.length != lOther$uuid.length) {
        return false;
      }
      for (int i = 0; i < l$uuid.length; i++) {
        final l$uuid$entry = l$uuid[i];
        final lOther$uuid$entry = lOther$uuid[i];
        if (l$uuid$entry != lOther$uuid$entry) {
          return false;
        }
      }
    } else if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('uuid')
          ? l$uuid == null
              ? null
              : Object.hashAll(l$uuid.map((v) => v))
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$deleteAlInput<TRes> {
  factory CopyWith$Input$deleteAlInput(
    Input$deleteAlInput instance,
    TRes Function(Input$deleteAlInput) then,
  ) = _CopyWithImpl$Input$deleteAlInput;

  factory CopyWith$Input$deleteAlInput.stub(TRes res) =
      _CopyWithStubImpl$Input$deleteAlInput;

  TRes call({List<String?>? uuid});
}

class _CopyWithImpl$Input$deleteAlInput<TRes>
    implements CopyWith$Input$deleteAlInput<TRes> {
  _CopyWithImpl$Input$deleteAlInput(
    this._instance,
    this._then,
  );

  final Input$deleteAlInput _instance;

  final TRes Function(Input$deleteAlInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$deleteAlInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as List<String?>?),
      }));
}

class _CopyWithStubImpl$Input$deleteAlInput<TRes>
    implements CopyWith$Input$deleteAlInput<TRes> {
  _CopyWithStubImpl$Input$deleteAlInput(this._res);

  TRes _res;

  call({List<String?>? uuid}) => _res;
}

class Input$OpenPlayListFrontPaginationInput {
  factory Input$OpenPlayListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? open_club_name,
    String? open_club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? timezone,
  }) =>
      Input$OpenPlayListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (open_club_name != null) r'open_club_name': open_club_name,
        if (open_club_type != null) r'open_club_type': open_club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (organized_by != null) r'organized_by': organized_by,
        if (timezone != null) r'timezone': timezone,
      });

  Input$OpenPlayListFrontPaginationInput._(this._$data);

  factory Input$OpenPlayListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('open_club_name')) {
      final l$open_club_name = data['open_club_name'];
      result$data['open_club_name'] = (l$open_club_name as String?);
    }
    if (data.containsKey('open_club_type')) {
      final l$open_club_type = data['open_club_type'];
      result$data['open_club_type'] = (l$open_club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$OpenPlayListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get open_club_name => (_$data['open_club_name'] as String?);

  String? get open_club_type => (_$data['open_club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('open_club_name')) {
      final l$open_club_name = open_club_name;
      result$data['open_club_name'] = l$open_club_name;
    }
    if (_$data.containsKey('open_club_type')) {
      final l$open_club_type = open_club_type;
      result$data['open_club_type'] = l$open_club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$OpenPlayListFrontPaginationInput<
          Input$OpenPlayListFrontPaginationInput>
      get copyWith => CopyWith$Input$OpenPlayListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpenPlayListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$open_club_name = open_club_name;
    final lOther$open_club_name = other.open_club_name;
    if (_$data.containsKey('open_club_name') !=
        other._$data.containsKey('open_club_name')) {
      return false;
    }
    if (l$open_club_name != lOther$open_club_name) {
      return false;
    }
    final l$open_club_type = open_club_type;
    final lOther$open_club_type = other.open_club_type;
    if (_$data.containsKey('open_club_type') !=
        other._$data.containsKey('open_club_type')) {
      return false;
    }
    if (l$open_club_type != lOther$open_club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$open_club_name = open_club_name;
    final l$open_club_type = open_club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$organized_by = organized_by;
    final l$timezone = timezone;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('open_club_name') ? l$open_club_name : const {},
      _$data.containsKey('open_club_type') ? l$open_club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpenPlayListFrontPaginationInput<TRes> {
  factory CopyWith$Input$OpenPlayListFrontPaginationInput(
    Input$OpenPlayListFrontPaginationInput instance,
    TRes Function(Input$OpenPlayListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$OpenPlayListFrontPaginationInput;

  factory CopyWith$Input$OpenPlayListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OpenPlayListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? open_club_name,
    String? open_club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OpenPlayListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$OpenPlayListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$OpenPlayListFrontPaginationInput _instance;

  final TRes Function(Input$OpenPlayListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? open_club_name = _undefined,
    Object? open_club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? organized_by = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OpenPlayListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (open_club_name != _undefined)
          'open_club_name': (open_club_name as String?),
        if (open_club_type != _undefined)
          'open_club_type': (open_club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$OpenPlayListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$OpenPlayListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? open_club_name,
    String? open_club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? timezone,
  }) =>
      _res;
}

class Input$OpenPlayScheduleListFrontPaginationInput {
  factory Input$OpenPlayScheduleListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      Input$OpenPlayScheduleListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
        if (timezone != null) r'timezone': timezone,
      });

  Input$OpenPlayScheduleListFrontPaginationInput._(this._$data);

  factory Input$OpenPlayScheduleListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$OpenPlayScheduleListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$OpenPlayScheduleListFrontPaginationInput<
          Input$OpenPlayScheduleListFrontPaginationInput>
      get copyWith => CopyWith$Input$OpenPlayScheduleListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpenPlayScheduleListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    final l$timezone = timezone;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpenPlayScheduleListFrontPaginationInput<TRes> {
  factory CopyWith$Input$OpenPlayScheduleListFrontPaginationInput(
    Input$OpenPlayScheduleListFrontPaginationInput instance,
    TRes Function(Input$OpenPlayScheduleListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$OpenPlayScheduleListFrontPaginationInput;

  factory CopyWith$Input$OpenPlayScheduleListFrontPaginationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$OpenPlayScheduleListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OpenPlayScheduleListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayScheduleListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$OpenPlayScheduleListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$OpenPlayScheduleListFrontPaginationInput _instance;

  final TRes Function(Input$OpenPlayScheduleListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OpenPlayScheduleListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$OpenPlayScheduleListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayScheduleListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$OpenPlayScheduleListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      _res;
}

class Input$OpenPlayPastListFrontPaginationInput {
  factory Input$OpenPlayPastListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      Input$OpenPlayPastListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
        if (timezone != null) r'timezone': timezone,
      });

  Input$OpenPlayPastListFrontPaginationInput._(this._$data);

  factory Input$OpenPlayPastListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    return Input$OpenPlayPastListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  String? get timezone => (_$data['timezone'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    return result$data;
  }

  CopyWith$Input$OpenPlayPastListFrontPaginationInput<
          Input$OpenPlayPastListFrontPaginationInput>
      get copyWith => CopyWith$Input$OpenPlayPastListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OpenPlayPastListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    final l$timezone = timezone;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
    ]);
  }
}

abstract class CopyWith$Input$OpenPlayPastListFrontPaginationInput<TRes> {
  factory CopyWith$Input$OpenPlayPastListFrontPaginationInput(
    Input$OpenPlayPastListFrontPaginationInput instance,
    TRes Function(Input$OpenPlayPastListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$OpenPlayPastListFrontPaginationInput;

  factory CopyWith$Input$OpenPlayPastListFrontPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$OpenPlayPastListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  });
}

class _CopyWithImpl$Input$OpenPlayPastListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayPastListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$OpenPlayPastListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$OpenPlayPastListFrontPaginationInput _instance;

  final TRes Function(Input$OpenPlayPastListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
    Object? timezone = _undefined,
  }) =>
      _then(Input$OpenPlayPastListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
      }));
}

class _CopyWithStubImpl$Input$OpenPlayPastListFrontPaginationInput<TRes>
    implements CopyWith$Input$OpenPlayPastListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$OpenPlayPastListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
  }) =>
      _res;
}

class Input$viewOpenPlayInput {
  factory Input$viewOpenPlayInput({required String uuid}) =>
      Input$viewOpenPlayInput._({
        r'uuid': uuid,
      });

  Input$viewOpenPlayInput._(this._$data);

  factory Input$viewOpenPlayInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewOpenPlayInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewOpenPlayInput<Input$viewOpenPlayInput> get copyWith =>
      CopyWith$Input$viewOpenPlayInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewOpenPlayInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewOpenPlayInput<TRes> {
  factory CopyWith$Input$viewOpenPlayInput(
    Input$viewOpenPlayInput instance,
    TRes Function(Input$viewOpenPlayInput) then,
  ) = _CopyWithImpl$Input$viewOpenPlayInput;

  factory CopyWith$Input$viewOpenPlayInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewOpenPlayInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewOpenPlayInput<TRes>
    implements CopyWith$Input$viewOpenPlayInput<TRes> {
  _CopyWithImpl$Input$viewOpenPlayInput(
    this._instance,
    this._then,
  );

  final Input$viewOpenPlayInput _instance;

  final TRes Function(Input$viewOpenPlayInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewOpenPlayInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewOpenPlayInput<TRes>
    implements CopyWith$Input$viewOpenPlayInput<TRes> {
  _CopyWithStubImpl$Input$viewOpenPlayInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$joinOpenPlayInput {
  factory Input$joinOpenPlayInput({
    String? uuid,
    int? request_type,
  }) =>
      Input$joinOpenPlayInput._({
        if (uuid != null) r'uuid': uuid,
        if (request_type != null) r'request_type': request_type,
      });

  Input$joinOpenPlayInput._(this._$data);

  factory Input$joinOpenPlayInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('request_type')) {
      final l$request_type = data['request_type'];
      result$data['request_type'] = (l$request_type as int?);
    }
    return Input$joinOpenPlayInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get request_type => (_$data['request_type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('request_type')) {
      final l$request_type = request_type;
      result$data['request_type'] = l$request_type;
    }
    return result$data;
  }

  CopyWith$Input$joinOpenPlayInput<Input$joinOpenPlayInput> get copyWith =>
      CopyWith$Input$joinOpenPlayInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$joinOpenPlayInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$request_type = request_type;
    final lOther$request_type = other.request_type;
    if (_$data.containsKey('request_type') !=
        other._$data.containsKey('request_type')) {
      return false;
    }
    if (l$request_type != lOther$request_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$request_type = request_type;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('request_type') ? l$request_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$joinOpenPlayInput<TRes> {
  factory CopyWith$Input$joinOpenPlayInput(
    Input$joinOpenPlayInput instance,
    TRes Function(Input$joinOpenPlayInput) then,
  ) = _CopyWithImpl$Input$joinOpenPlayInput;

  factory CopyWith$Input$joinOpenPlayInput.stub(TRes res) =
      _CopyWithStubImpl$Input$joinOpenPlayInput;

  TRes call({
    String? uuid,
    int? request_type,
  });
}

class _CopyWithImpl$Input$joinOpenPlayInput<TRes>
    implements CopyWith$Input$joinOpenPlayInput<TRes> {
  _CopyWithImpl$Input$joinOpenPlayInput(
    this._instance,
    this._then,
  );

  final Input$joinOpenPlayInput _instance;

  final TRes Function(Input$joinOpenPlayInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? request_type = _undefined,
  }) =>
      _then(Input$joinOpenPlayInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (request_type != _undefined) 'request_type': (request_type as int?),
      }));
}

class _CopyWithStubImpl$Input$joinOpenPlayInput<TRes>
    implements CopyWith$Input$joinOpenPlayInput<TRes> {
  _CopyWithStubImpl$Input$joinOpenPlayInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? request_type,
  }) =>
      _res;
}

class Input$openPlayBoardInput {
  factory Input$openPlayBoardInput({
    int? radius,
    double? latitude,
    double? longitude,
  }) =>
      Input$openPlayBoardInput._({
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
      });

  Input$openPlayBoardInput._(this._$data);

  factory Input$openPlayBoardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    return Input$openPlayBoardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    return result$data;
  }

  CopyWith$Input$openPlayBoardInput<Input$openPlayBoardInput> get copyWith =>
      CopyWith$Input$openPlayBoardInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$openPlayBoardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    return Object.hashAll([
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
    ]);
  }
}

abstract class CopyWith$Input$openPlayBoardInput<TRes> {
  factory CopyWith$Input$openPlayBoardInput(
    Input$openPlayBoardInput instance,
    TRes Function(Input$openPlayBoardInput) then,
  ) = _CopyWithImpl$Input$openPlayBoardInput;

  factory CopyWith$Input$openPlayBoardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$openPlayBoardInput;

  TRes call({
    int? radius,
    double? latitude,
    double? longitude,
  });
}

class _CopyWithImpl$Input$openPlayBoardInput<TRes>
    implements CopyWith$Input$openPlayBoardInput<TRes> {
  _CopyWithImpl$Input$openPlayBoardInput(
    this._instance,
    this._then,
  );

  final Input$openPlayBoardInput _instance;

  final TRes Function(Input$openPlayBoardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
  }) =>
      _then(Input$openPlayBoardInput._({
        ..._instance._$data,
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
      }));
}

class _CopyWithStubImpl$Input$openPlayBoardInput<TRes>
    implements CopyWith$Input$openPlayBoardInput<TRes> {
  _CopyWithStubImpl$Input$openPlayBoardInput(this._res);

  TRes _res;

  call({
    int? radius,
    double? latitude,
    double? longitude,
  }) =>
      _res;
}

class Input$openPlayDeleteInput {
  factory Input$openPlayDeleteInput({int? user_id}) =>
      Input$openPlayDeleteInput._({
        if (user_id != null) r'user_id': user_id,
      });

  Input$openPlayDeleteInput._(this._$data);

  factory Input$openPlayDeleteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as int?);
    }
    return Input$openPlayDeleteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get user_id => (_$data['user_id'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$openPlayDeleteInput<Input$openPlayDeleteInput> get copyWith =>
      CopyWith$Input$openPlayDeleteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$openPlayDeleteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_id = user_id;
    return Object.hashAll(
        [_$data.containsKey('user_id') ? l$user_id : const {}]);
  }
}

abstract class CopyWith$Input$openPlayDeleteInput<TRes> {
  factory CopyWith$Input$openPlayDeleteInput(
    Input$openPlayDeleteInput instance,
    TRes Function(Input$openPlayDeleteInput) then,
  ) = _CopyWithImpl$Input$openPlayDeleteInput;

  factory CopyWith$Input$openPlayDeleteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$openPlayDeleteInput;

  TRes call({int? user_id});
}

class _CopyWithImpl$Input$openPlayDeleteInput<TRes>
    implements CopyWith$Input$openPlayDeleteInput<TRes> {
  _CopyWithImpl$Input$openPlayDeleteInput(
    this._instance,
    this._then,
  );

  final Input$openPlayDeleteInput _instance;

  final TRes Function(Input$openPlayDeleteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? user_id = _undefined}) =>
      _then(Input$openPlayDeleteInput._({
        ..._instance._$data,
        if (user_id != _undefined) 'user_id': (user_id as int?),
      }));
}

class _CopyWithStubImpl$Input$openPlayDeleteInput<TRes>
    implements CopyWith$Input$openPlayDeleteInput<TRes> {
  _CopyWithStubImpl$Input$openPlayDeleteInput(this._res);

  TRes _res;

  call({int? user_id}) => _res;
}

class Input$viewLessonViewInput {
  factory Input$viewLessonViewInput({required String uuid}) =>
      Input$viewLessonViewInput._({
        r'uuid': uuid,
      });

  Input$viewLessonViewInput._(this._$data);

  factory Input$viewLessonViewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewLessonViewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewLessonViewInput<Input$viewLessonViewInput> get copyWith =>
      CopyWith$Input$viewLessonViewInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewLessonViewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewLessonViewInput<TRes> {
  factory CopyWith$Input$viewLessonViewInput(
    Input$viewLessonViewInput instance,
    TRes Function(Input$viewLessonViewInput) then,
  ) = _CopyWithImpl$Input$viewLessonViewInput;

  factory CopyWith$Input$viewLessonViewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewLessonViewInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewLessonViewInput<TRes>
    implements CopyWith$Input$viewLessonViewInput<TRes> {
  _CopyWithImpl$Input$viewLessonViewInput(
    this._instance,
    this._then,
  );

  final Input$viewLessonViewInput _instance;

  final TRes Function(Input$viewLessonViewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewLessonViewInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewLessonViewInput<TRes>
    implements CopyWith$Input$viewLessonViewInput<TRes> {
  _CopyWithStubImpl$Input$viewLessonViewInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AddRequestPlayInputLsn {
  factory Input$AddRequestPlayInputLsn({
    required String match_id,
    required String user_id,
  }) =>
      Input$AddRequestPlayInputLsn._({
        r'match_id': match_id,
        r'user_id': user_id,
      });

  Input$AddRequestPlayInputLsn._(this._$data);

  factory Input$AddRequestPlayInputLsn.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    return Input$AddRequestPlayInputLsn._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    return result$data;
  }

  CopyWith$Input$AddRequestPlayInputLsn<Input$AddRequestPlayInputLsn>
      get copyWith => CopyWith$Input$AddRequestPlayInputLsn(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddRequestPlayInputLsn) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    return Object.hashAll([
      l$match_id,
      l$user_id,
    ]);
  }
}

abstract class CopyWith$Input$AddRequestPlayInputLsn<TRes> {
  factory CopyWith$Input$AddRequestPlayInputLsn(
    Input$AddRequestPlayInputLsn instance,
    TRes Function(Input$AddRequestPlayInputLsn) then,
  ) = _CopyWithImpl$Input$AddRequestPlayInputLsn;

  factory CopyWith$Input$AddRequestPlayInputLsn.stub(TRes res) =
      _CopyWithStubImpl$Input$AddRequestPlayInputLsn;

  TRes call({
    String? match_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$AddRequestPlayInputLsn<TRes>
    implements CopyWith$Input$AddRequestPlayInputLsn<TRes> {
  _CopyWithImpl$Input$AddRequestPlayInputLsn(
    this._instance,
    this._then,
  );

  final Input$AddRequestPlayInputLsn _instance;

  final TRes Function(Input$AddRequestPlayInputLsn) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$AddRequestPlayInputLsn._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
      }));
}

class _CopyWithStubImpl$Input$AddRequestPlayInputLsn<TRes>
    implements CopyWith$Input$AddRequestPlayInputLsn<TRes> {
  _CopyWithStubImpl$Input$AddRequestPlayInputLsn(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
  }) =>
      _res;
}

class Input$addPaymentInputLsn {
  factory Input$addPaymentInputLsn({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
  }) =>
      Input$addPaymentInputLsn._({
        if (match_id != null) r'match_id': match_id,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (transaction_fee != null) r'transaction_fee': transaction_fee,
        if (admin_fee != null) r'admin_fee': admin_fee,
        if (total != null) r'total': total,
      });

  Input$addPaymentInputLsn._(this._$data);

  factory Input$addPaymentInputLsn.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('transaction_fee')) {
      final l$transaction_fee = data['transaction_fee'];
      result$data['transaction_fee'] = (l$transaction_fee as String?);
    }
    if (data.containsKey('admin_fee')) {
      final l$admin_fee = data['admin_fee'];
      result$data['admin_fee'] = (l$admin_fee as String?);
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] = (l$total as String?);
    }
    return Input$addPaymentInputLsn._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get transaction_fee => (_$data['transaction_fee'] as String?);

  String? get admin_fee => (_$data['admin_fee'] as String?);

  String? get total => (_$data['total'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('transaction_fee')) {
      final l$transaction_fee = transaction_fee;
      result$data['transaction_fee'] = l$transaction_fee;
    }
    if (_$data.containsKey('admin_fee')) {
      final l$admin_fee = admin_fee;
      result$data['admin_fee'] = l$admin_fee;
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] = l$total;
    }
    return result$data;
  }

  CopyWith$Input$addPaymentInputLsn<Input$addPaymentInputLsn> get copyWith =>
      CopyWith$Input$addPaymentInputLsn(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addPaymentInputLsn) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$transaction_fee = transaction_fee;
    final lOther$transaction_fee = other.transaction_fee;
    if (_$data.containsKey('transaction_fee') !=
        other._$data.containsKey('transaction_fee')) {
      return false;
    }
    if (l$transaction_fee != lOther$transaction_fee) {
      return false;
    }
    final l$admin_fee = admin_fee;
    final lOther$admin_fee = other.admin_fee;
    if (_$data.containsKey('admin_fee') !=
        other._$data.containsKey('admin_fee')) {
      return false;
    }
    if (l$admin_fee != lOther$admin_fee) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$cost_per_player = cost_per_player;
    final l$transaction_fee = transaction_fee;
    final l$admin_fee = admin_fee;
    final l$total = total;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('transaction_fee') ? l$transaction_fee : const {},
      _$data.containsKey('admin_fee') ? l$admin_fee : const {},
      _$data.containsKey('total') ? l$total : const {},
    ]);
  }
}

abstract class CopyWith$Input$addPaymentInputLsn<TRes> {
  factory CopyWith$Input$addPaymentInputLsn(
    Input$addPaymentInputLsn instance,
    TRes Function(Input$addPaymentInputLsn) then,
  ) = _CopyWithImpl$Input$addPaymentInputLsn;

  factory CopyWith$Input$addPaymentInputLsn.stub(TRes res) =
      _CopyWithStubImpl$Input$addPaymentInputLsn;

  TRes call({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
  });
}

class _CopyWithImpl$Input$addPaymentInputLsn<TRes>
    implements CopyWith$Input$addPaymentInputLsn<TRes> {
  _CopyWithImpl$Input$addPaymentInputLsn(
    this._instance,
    this._then,
  );

  final Input$addPaymentInputLsn _instance;

  final TRes Function(Input$addPaymentInputLsn) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? cost_per_player = _undefined,
    Object? transaction_fee = _undefined,
    Object? admin_fee = _undefined,
    Object? total = _undefined,
  }) =>
      _then(Input$addPaymentInputLsn._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (transaction_fee != _undefined)
          'transaction_fee': (transaction_fee as String?),
        if (admin_fee != _undefined) 'admin_fee': (admin_fee as String?),
        if (total != _undefined) 'total': (total as String?),
      }));
}

class _CopyWithStubImpl$Input$addPaymentInputLsn<TRes>
    implements CopyWith$Input$addPaymentInputLsn<TRes> {
  _CopyWithStubImpl$Input$addPaymentInputLsn(this._res);

  TRes _res;

  call({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
  }) =>
      _res;
}

class Input$LsnReqAcceptInput {
  factory Input$LsnReqAcceptInput({
    required String match_id,
    required String user_id,
  }) =>
      Input$LsnReqAcceptInput._({
        r'match_id': match_id,
        r'user_id': user_id,
      });

  Input$LsnReqAcceptInput._(this._$data);

  factory Input$LsnReqAcceptInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    return Input$LsnReqAcceptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    return result$data;
  }

  CopyWith$Input$LsnReqAcceptInput<Input$LsnReqAcceptInput> get copyWith =>
      CopyWith$Input$LsnReqAcceptInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LsnReqAcceptInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    return Object.hashAll([
      l$match_id,
      l$user_id,
    ]);
  }
}

abstract class CopyWith$Input$LsnReqAcceptInput<TRes> {
  factory CopyWith$Input$LsnReqAcceptInput(
    Input$LsnReqAcceptInput instance,
    TRes Function(Input$LsnReqAcceptInput) then,
  ) = _CopyWithImpl$Input$LsnReqAcceptInput;

  factory CopyWith$Input$LsnReqAcceptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LsnReqAcceptInput;

  TRes call({
    String? match_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$LsnReqAcceptInput<TRes>
    implements CopyWith$Input$LsnReqAcceptInput<TRes> {
  _CopyWithImpl$Input$LsnReqAcceptInput(
    this._instance,
    this._then,
  );

  final Input$LsnReqAcceptInput _instance;

  final TRes Function(Input$LsnReqAcceptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$LsnReqAcceptInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
      }));
}

class _CopyWithStubImpl$Input$LsnReqAcceptInput<TRes>
    implements CopyWith$Input$LsnReqAcceptInput<TRes> {
  _CopyWithStubImpl$Input$LsnReqAcceptInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
  }) =>
      _res;
}

class Input$LessonReqRejectInput {
  factory Input$LessonReqRejectInput({
    required String match_id,
    required String user_id,
    bool? is_host_reject,
  }) =>
      Input$LessonReqRejectInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        if (is_host_reject != null) r'is_host_reject': is_host_reject,
      });

  Input$LessonReqRejectInput._(this._$data);

  factory Input$LessonReqRejectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    if (data.containsKey('is_host_reject')) {
      final l$is_host_reject = data['is_host_reject'];
      result$data['is_host_reject'] = (l$is_host_reject as bool?);
    }
    return Input$LessonReqRejectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  bool? get is_host_reject => (_$data['is_host_reject'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    if (_$data.containsKey('is_host_reject')) {
      final l$is_host_reject = is_host_reject;
      result$data['is_host_reject'] = l$is_host_reject;
    }
    return result$data;
  }

  CopyWith$Input$LessonReqRejectInput<Input$LessonReqRejectInput>
      get copyWith => CopyWith$Input$LessonReqRejectInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LessonReqRejectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_host_reject = is_host_reject;
    final lOther$is_host_reject = other.is_host_reject;
    if (_$data.containsKey('is_host_reject') !=
        other._$data.containsKey('is_host_reject')) {
      return false;
    }
    if (l$is_host_reject != lOther$is_host_reject) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_host_reject = is_host_reject;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      _$data.containsKey('is_host_reject') ? l$is_host_reject : const {},
    ]);
  }
}

abstract class CopyWith$Input$LessonReqRejectInput<TRes> {
  factory CopyWith$Input$LessonReqRejectInput(
    Input$LessonReqRejectInput instance,
    TRes Function(Input$LessonReqRejectInput) then,
  ) = _CopyWithImpl$Input$LessonReqRejectInput;

  factory CopyWith$Input$LessonReqRejectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LessonReqRejectInput;

  TRes call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
  });
}

class _CopyWithImpl$Input$LessonReqRejectInput<TRes>
    implements CopyWith$Input$LessonReqRejectInput<TRes> {
  _CopyWithImpl$Input$LessonReqRejectInput(
    this._instance,
    this._then,
  );

  final Input$LessonReqRejectInput _instance;

  final TRes Function(Input$LessonReqRejectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_host_reject = _undefined,
  }) =>
      _then(Input$LessonReqRejectInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_host_reject != _undefined)
          'is_host_reject': (is_host_reject as bool?),
      }));
}

class _CopyWithStubImpl$Input$LessonReqRejectInput<TRes>
    implements CopyWith$Input$LessonReqRejectInput<TRes> {
  _CopyWithStubImpl$Input$LessonReqRejectInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
  }) =>
      _res;
}

class Input$LessonCancelInput {
  factory Input$LessonCancelInput({
    String? match_id,
    int? cancel_all,
  }) =>
      Input$LessonCancelInput._({
        if (match_id != null) r'match_id': match_id,
        if (cancel_all != null) r'cancel_all': cancel_all,
      });

  Input$LessonCancelInput._(this._$data);

  factory Input$LessonCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('cancel_all')) {
      final l$cancel_all = data['cancel_all'];
      result$data['cancel_all'] = (l$cancel_all as int?);
    }
    return Input$LessonCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  int? get cancel_all => (_$data['cancel_all'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('cancel_all')) {
      final l$cancel_all = cancel_all;
      result$data['cancel_all'] = l$cancel_all;
    }
    return result$data;
  }

  CopyWith$Input$LessonCancelInput<Input$LessonCancelInput> get copyWith =>
      CopyWith$Input$LessonCancelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LessonCancelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$cancel_all = cancel_all;
    final lOther$cancel_all = other.cancel_all;
    if (_$data.containsKey('cancel_all') !=
        other._$data.containsKey('cancel_all')) {
      return false;
    }
    if (l$cancel_all != lOther$cancel_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$cancel_all = cancel_all;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('cancel_all') ? l$cancel_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$LessonCancelInput<TRes> {
  factory CopyWith$Input$LessonCancelInput(
    Input$LessonCancelInput instance,
    TRes Function(Input$LessonCancelInput) then,
  ) = _CopyWithImpl$Input$LessonCancelInput;

  factory CopyWith$Input$LessonCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LessonCancelInput;

  TRes call({
    String? match_id,
    int? cancel_all,
  });
}

class _CopyWithImpl$Input$LessonCancelInput<TRes>
    implements CopyWith$Input$LessonCancelInput<TRes> {
  _CopyWithImpl$Input$LessonCancelInput(
    this._instance,
    this._then,
  );

  final Input$LessonCancelInput _instance;

  final TRes Function(Input$LessonCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? cancel_all = _undefined,
  }) =>
      _then(Input$LessonCancelInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (cancel_all != _undefined) 'cancel_all': (cancel_all as int?),
      }));
}

class _CopyWithStubImpl$Input$LessonCancelInput<TRes>
    implements CopyWith$Input$LessonCancelInput<TRes> {
  _CopyWithStubImpl$Input$LessonCancelInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? cancel_all,
  }) =>
      _res;
}

class Input$LessonUserInput {
  factory Input$LessonUserInput({
    required String match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$LessonUserInput._({
        r'match_id': match_id,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$LessonUserInput._(this._$data);

  factory Input$LessonUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$LessonUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$LessonUserInput<Input$LessonUserInput> get copyWith =>
      CopyWith$Input$LessonUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LessonUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$match_id,
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$LessonUserInput<TRes> {
  factory CopyWith$Input$LessonUserInput(
    Input$LessonUserInput instance,
    TRes Function(Input$LessonUserInput) then,
  ) = _CopyWithImpl$Input$LessonUserInput;

  factory CopyWith$Input$LessonUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LessonUserInput;

  TRes call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$LessonUserInput<TRes>
    implements CopyWith$Input$LessonUserInput<TRes> {
  _CopyWithImpl$Input$LessonUserInput(
    this._instance,
    this._then,
  );

  final Input$LessonUserInput _instance;

  final TRes Function(Input$LessonUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$LessonUserInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$LessonUserInput<TRes>
    implements CopyWith$Input$LessonUserInput<TRes> {
  _CopyWithStubImpl$Input$LessonUserInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$InvitedLessonMemberInput {
  factory Input$InvitedLessonMemberInput({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$InvitedLessonMemberInput._({
        if (name != null) r'name': name,
        if (uuid != null) r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$InvitedLessonMemberInput._(this._$data);

  factory Input$InvitedLessonMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$InvitedLessonMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$InvitedLessonMemberInput<Input$InvitedLessonMemberInput>
      get copyWith => CopyWith$Input$InvitedLessonMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitedLessonMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitedLessonMemberInput<TRes> {
  factory CopyWith$Input$InvitedLessonMemberInput(
    Input$InvitedLessonMemberInput instance,
    TRes Function(Input$InvitedLessonMemberInput) then,
  ) = _CopyWithImpl$Input$InvitedLessonMemberInput;

  factory CopyWith$Input$InvitedLessonMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitedLessonMemberInput;

  TRes call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$InvitedLessonMemberInput<TRes>
    implements CopyWith$Input$InvitedLessonMemberInput<TRes> {
  _CopyWithImpl$Input$InvitedLessonMemberInput(
    this._instance,
    this._then,
  );

  final Input$InvitedLessonMemberInput _instance;

  final TRes Function(Input$InvitedLessonMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$InvitedLessonMemberInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$InvitedLessonMemberInput<TRes>
    implements CopyWith$Input$InvitedLessonMemberInput<TRes> {
  _CopyWithStubImpl$Input$InvitedLessonMemberInput(this._res);

  TRes _res;

  call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$ClubSuggestionPaginationInput {
  factory Input$ClubSuggestionPaginationInput({
    required int offset,
    required int limit,
    String? keyword,
    String? start_date,
    String? end_date,
    String? club_id,
    String? organizer_id,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$ClubSuggestionPaginationInput._({
        r'offset': offset,
        r'limit': limit,
        if (keyword != null) r'keyword': keyword,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (club_id != null) r'club_id': club_id,
        if (organizer_id != null) r'organizer_id': organizer_id,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$ClubSuggestionPaginationInput._(this._$data);

  factory Input$ClubSuggestionPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    final l$limit = data['limit'];
    result$data['limit'] = (l$limit as int);
    if (data.containsKey('keyword')) {
      final l$keyword = data['keyword'];
      result$data['keyword'] = (l$keyword as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('club_id')) {
      final l$club_id = data['club_id'];
      result$data['club_id'] = (l$club_id as String?);
    }
    if (data.containsKey('organizer_id')) {
      final l$organizer_id = data['organizer_id'];
      result$data['organizer_id'] = (l$organizer_id as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$ClubSuggestionPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int get limit => (_$data['limit'] as int);

  String? get keyword => (_$data['keyword'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get club_id => (_$data['club_id'] as String?);

  String? get organizer_id => (_$data['organizer_id'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    final l$limit = limit;
    result$data['limit'] = l$limit;
    if (_$data.containsKey('keyword')) {
      final l$keyword = keyword;
      result$data['keyword'] = l$keyword;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('club_id')) {
      final l$club_id = club_id;
      result$data['club_id'] = l$club_id;
    }
    if (_$data.containsKey('organizer_id')) {
      final l$organizer_id = organizer_id;
      result$data['organizer_id'] = l$organizer_id;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$ClubSuggestionPaginationInput<
          Input$ClubSuggestionPaginationInput>
      get copyWith => CopyWith$Input$ClubSuggestionPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClubSuggestionPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$keyword = keyword;
    final lOther$keyword = other.keyword;
    if (_$data.containsKey('keyword') != other._$data.containsKey('keyword')) {
      return false;
    }
    if (l$keyword != lOther$keyword) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$club_id = club_id;
    final lOther$club_id = other.club_id;
    if (_$data.containsKey('club_id') != other._$data.containsKey('club_id')) {
      return false;
    }
    if (l$club_id != lOther$club_id) {
      return false;
    }
    final l$organizer_id = organizer_id;
    final lOther$organizer_id = other.organizer_id;
    if (_$data.containsKey('organizer_id') !=
        other._$data.containsKey('organizer_id')) {
      return false;
    }
    if (l$organizer_id != lOther$organizer_id) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$keyword = keyword;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$club_id = club_id;
    final l$organizer_id = organizer_id;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$offset,
      l$limit,
      _$data.containsKey('keyword') ? l$keyword : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('club_id') ? l$club_id : const {},
      _$data.containsKey('organizer_id') ? l$organizer_id : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClubSuggestionPaginationInput<TRes> {
  factory CopyWith$Input$ClubSuggestionPaginationInput(
    Input$ClubSuggestionPaginationInput instance,
    TRes Function(Input$ClubSuggestionPaginationInput) then,
  ) = _CopyWithImpl$Input$ClubSuggestionPaginationInput;

  factory CopyWith$Input$ClubSuggestionPaginationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClubSuggestionPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? keyword,
    String? start_date,
    String? end_date,
    String? club_id,
    String? organizer_id,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$ClubSuggestionPaginationInput<TRes>
    implements CopyWith$Input$ClubSuggestionPaginationInput<TRes> {
  _CopyWithImpl$Input$ClubSuggestionPaginationInput(
    this._instance,
    this._then,
  );

  final Input$ClubSuggestionPaginationInput _instance;

  final TRes Function(Input$ClubSuggestionPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? keyword = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? club_id = _undefined,
    Object? organizer_id = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$ClubSuggestionPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined && limit != null) 'limit': (limit as int),
        if (keyword != _undefined) 'keyword': (keyword as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (club_id != _undefined) 'club_id': (club_id as String?),
        if (organizer_id != _undefined)
          'organizer_id': (organizer_id as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$ClubSuggestionPaginationInput<TRes>
    implements CopyWith$Input$ClubSuggestionPaginationInput<TRes> {
  _CopyWithStubImpl$Input$ClubSuggestionPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? keyword,
    String? start_date,
    String? end_date,
    String? club_id,
    String? organizer_id,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$remaingRatingUsersInput {
  factory Input$remaingRatingUsersInput({
    int? offset,
    int? limit,
    String? name,
    int? is_coach,
  }) =>
      Input$remaingRatingUsersInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (is_coach != null) r'is_coach': is_coach,
      });

  Input$remaingRatingUsersInput._(this._$data);

  factory Input$remaingRatingUsersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('is_coach')) {
      final l$is_coach = data['is_coach'];
      result$data['is_coach'] = (l$is_coach as int?);
    }
    return Input$remaingRatingUsersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  int? get is_coach => (_$data['is_coach'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('is_coach')) {
      final l$is_coach = is_coach;
      result$data['is_coach'] = l$is_coach;
    }
    return result$data;
  }

  CopyWith$Input$remaingRatingUsersInput<Input$remaingRatingUsersInput>
      get copyWith => CopyWith$Input$remaingRatingUsersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$remaingRatingUsersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$is_coach = is_coach;
    final lOther$is_coach = other.is_coach;
    if (_$data.containsKey('is_coach') !=
        other._$data.containsKey('is_coach')) {
      return false;
    }
    if (l$is_coach != lOther$is_coach) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$is_coach = is_coach;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('is_coach') ? l$is_coach : const {},
    ]);
  }
}

abstract class CopyWith$Input$remaingRatingUsersInput<TRes> {
  factory CopyWith$Input$remaingRatingUsersInput(
    Input$remaingRatingUsersInput instance,
    TRes Function(Input$remaingRatingUsersInput) then,
  ) = _CopyWithImpl$Input$remaingRatingUsersInput;

  factory CopyWith$Input$remaingRatingUsersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$remaingRatingUsersInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    int? is_coach,
  });
}

class _CopyWithImpl$Input$remaingRatingUsersInput<TRes>
    implements CopyWith$Input$remaingRatingUsersInput<TRes> {
  _CopyWithImpl$Input$remaingRatingUsersInput(
    this._instance,
    this._then,
  );

  final Input$remaingRatingUsersInput _instance;

  final TRes Function(Input$remaingRatingUsersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? is_coach = _undefined,
  }) =>
      _then(Input$remaingRatingUsersInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (is_coach != _undefined) 'is_coach': (is_coach as int?),
      }));
}

class _CopyWithStubImpl$Input$remaingRatingUsersInput<TRes>
    implements CopyWith$Input$remaingRatingUsersInput<TRes> {
  _CopyWithStubImpl$Input$remaingRatingUsersInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    int? is_coach,
  }) =>
      _res;
}

class Input$ViewClubSuggestionInput {
  factory Input$ViewClubSuggestionInput({required String uuid}) =>
      Input$ViewClubSuggestionInput._({
        r'uuid': uuid,
      });

  Input$ViewClubSuggestionInput._(this._$data);

  factory Input$ViewClubSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$ViewClubSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$ViewClubSuggestionInput<Input$ViewClubSuggestionInput>
      get copyWith => CopyWith$Input$ViewClubSuggestionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ViewClubSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$ViewClubSuggestionInput<TRes> {
  factory CopyWith$Input$ViewClubSuggestionInput(
    Input$ViewClubSuggestionInput instance,
    TRes Function(Input$ViewClubSuggestionInput) then,
  ) = _CopyWithImpl$Input$ViewClubSuggestionInput;

  factory CopyWith$Input$ViewClubSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ViewClubSuggestionInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$ViewClubSuggestionInput<TRes>
    implements CopyWith$Input$ViewClubSuggestionInput<TRes> {
  _CopyWithImpl$Input$ViewClubSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$ViewClubSuggestionInput _instance;

  final TRes Function(Input$ViewClubSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$ViewClubSuggestionInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$ViewClubSuggestionInput<TRes>
    implements CopyWith$Input$ViewClubSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$ViewClubSuggestionInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$ConnectycubeidInput {
  factory Input$ConnectycubeidInput({
    required String uuid,
    String? ccgroup,
  }) =>
      Input$ConnectycubeidInput._({
        r'uuid': uuid,
        if (ccgroup != null) r'ccgroup': ccgroup,
      });

  Input$ConnectycubeidInput._(this._$data);

  factory Input$ConnectycubeidInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('ccgroup')) {
      final l$ccgroup = data['ccgroup'];
      result$data['ccgroup'] = (l$ccgroup as String?);
    }
    return Input$ConnectycubeidInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get ccgroup => (_$data['ccgroup'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('ccgroup')) {
      final l$ccgroup = ccgroup;
      result$data['ccgroup'] = l$ccgroup;
    }
    return result$data;
  }

  CopyWith$Input$ConnectycubeidInput<Input$ConnectycubeidInput> get copyWith =>
      CopyWith$Input$ConnectycubeidInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConnectycubeidInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$ccgroup = ccgroup;
    final lOther$ccgroup = other.ccgroup;
    if (_$data.containsKey('ccgroup') != other._$data.containsKey('ccgroup')) {
      return false;
    }
    if (l$ccgroup != lOther$ccgroup) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$ccgroup = ccgroup;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('ccgroup') ? l$ccgroup : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConnectycubeidInput<TRes> {
  factory CopyWith$Input$ConnectycubeidInput(
    Input$ConnectycubeidInput instance,
    TRes Function(Input$ConnectycubeidInput) then,
  ) = _CopyWithImpl$Input$ConnectycubeidInput;

  factory CopyWith$Input$ConnectycubeidInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConnectycubeidInput;

  TRes call({
    String? uuid,
    String? ccgroup,
  });
}

class _CopyWithImpl$Input$ConnectycubeidInput<TRes>
    implements CopyWith$Input$ConnectycubeidInput<TRes> {
  _CopyWithImpl$Input$ConnectycubeidInput(
    this._instance,
    this._then,
  );

  final Input$ConnectycubeidInput _instance;

  final TRes Function(Input$ConnectycubeidInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? ccgroup = _undefined,
  }) =>
      _then(Input$ConnectycubeidInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (ccgroup != _undefined) 'ccgroup': (ccgroup as String?),
      }));
}

class _CopyWithStubImpl$Input$ConnectycubeidInput<TRes>
    implements CopyWith$Input$ConnectycubeidInput<TRes> {
  _CopyWithStubImpl$Input$ConnectycubeidInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? ccgroup,
  }) =>
      _res;
}

class Input$inActiveCoachInput {
  factory Input$inActiveCoachInput({required String uuid}) =>
      Input$inActiveCoachInput._({
        r'uuid': uuid,
      });

  Input$inActiveCoachInput._(this._$data);

  factory Input$inActiveCoachInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$inActiveCoachInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$inActiveCoachInput<Input$inActiveCoachInput> get copyWith =>
      CopyWith$Input$inActiveCoachInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$inActiveCoachInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$inActiveCoachInput<TRes> {
  factory CopyWith$Input$inActiveCoachInput(
    Input$inActiveCoachInput instance,
    TRes Function(Input$inActiveCoachInput) then,
  ) = _CopyWithImpl$Input$inActiveCoachInput;

  factory CopyWith$Input$inActiveCoachInput.stub(TRes res) =
      _CopyWithStubImpl$Input$inActiveCoachInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$inActiveCoachInput<TRes>
    implements CopyWith$Input$inActiveCoachInput<TRes> {
  _CopyWithImpl$Input$inActiveCoachInput(
    this._instance,
    this._then,
  );

  final Input$inActiveCoachInput _instance;

  final TRes Function(Input$inActiveCoachInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$inActiveCoachInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$inActiveCoachInput<TRes>
    implements CopyWith$Input$inActiveCoachInput<TRes> {
  _CopyWithStubImpl$Input$inActiveCoachInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$approveClubSuggestionInput {
  factory Input$approveClubSuggestionInput({
    required String uuid,
    int? image_approve,
    int? name_approve,
    int? phone_number_approve,
    int? url_approve,
    int? type_approve,
    int? no_courts_approve,
    int? court_type_approve,
    int? is_membership_requre_approve,
    int? mon_approve,
    int? tue_approve,
    int? wed_approve,
    int? thu_approve,
    int? fri_approve,
    int? sat_approve,
    int? sun_approve,
    int? note_approve,
    int? cost_approve,
  }) =>
      Input$approveClubSuggestionInput._({
        r'uuid': uuid,
        if (image_approve != null) r'image_approve': image_approve,
        if (name_approve != null) r'name_approve': name_approve,
        if (phone_number_approve != null)
          r'phone_number_approve': phone_number_approve,
        if (url_approve != null) r'url_approve': url_approve,
        if (type_approve != null) r'type_approve': type_approve,
        if (no_courts_approve != null) r'no_courts_approve': no_courts_approve,
        if (court_type_approve != null)
          r'court_type_approve': court_type_approve,
        if (is_membership_requre_approve != null)
          r'is_membership_requre_approve': is_membership_requre_approve,
        if (mon_approve != null) r'mon_approve': mon_approve,
        if (tue_approve != null) r'tue_approve': tue_approve,
        if (wed_approve != null) r'wed_approve': wed_approve,
        if (thu_approve != null) r'thu_approve': thu_approve,
        if (fri_approve != null) r'fri_approve': fri_approve,
        if (sat_approve != null) r'sat_approve': sat_approve,
        if (sun_approve != null) r'sun_approve': sun_approve,
        if (note_approve != null) r'note_approve': note_approve,
        if (cost_approve != null) r'cost_approve': cost_approve,
      });

  Input$approveClubSuggestionInput._(this._$data);

  factory Input$approveClubSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('image_approve')) {
      final l$image_approve = data['image_approve'];
      result$data['image_approve'] = (l$image_approve as int?);
    }
    if (data.containsKey('name_approve')) {
      final l$name_approve = data['name_approve'];
      result$data['name_approve'] = (l$name_approve as int?);
    }
    if (data.containsKey('phone_number_approve')) {
      final l$phone_number_approve = data['phone_number_approve'];
      result$data['phone_number_approve'] = (l$phone_number_approve as int?);
    }
    if (data.containsKey('url_approve')) {
      final l$url_approve = data['url_approve'];
      result$data['url_approve'] = (l$url_approve as int?);
    }
    if (data.containsKey('type_approve')) {
      final l$type_approve = data['type_approve'];
      result$data['type_approve'] = (l$type_approve as int?);
    }
    if (data.containsKey('no_courts_approve')) {
      final l$no_courts_approve = data['no_courts_approve'];
      result$data['no_courts_approve'] = (l$no_courts_approve as int?);
    }
    if (data.containsKey('court_type_approve')) {
      final l$court_type_approve = data['court_type_approve'];
      result$data['court_type_approve'] = (l$court_type_approve as int?);
    }
    if (data.containsKey('is_membership_requre_approve')) {
      final l$is_membership_requre_approve =
          data['is_membership_requre_approve'];
      result$data['is_membership_requre_approve'] =
          (l$is_membership_requre_approve as int?);
    }
    if (data.containsKey('mon_approve')) {
      final l$mon_approve = data['mon_approve'];
      result$data['mon_approve'] = (l$mon_approve as int?);
    }
    if (data.containsKey('tue_approve')) {
      final l$tue_approve = data['tue_approve'];
      result$data['tue_approve'] = (l$tue_approve as int?);
    }
    if (data.containsKey('wed_approve')) {
      final l$wed_approve = data['wed_approve'];
      result$data['wed_approve'] = (l$wed_approve as int?);
    }
    if (data.containsKey('thu_approve')) {
      final l$thu_approve = data['thu_approve'];
      result$data['thu_approve'] = (l$thu_approve as int?);
    }
    if (data.containsKey('fri_approve')) {
      final l$fri_approve = data['fri_approve'];
      result$data['fri_approve'] = (l$fri_approve as int?);
    }
    if (data.containsKey('sat_approve')) {
      final l$sat_approve = data['sat_approve'];
      result$data['sat_approve'] = (l$sat_approve as int?);
    }
    if (data.containsKey('sun_approve')) {
      final l$sun_approve = data['sun_approve'];
      result$data['sun_approve'] = (l$sun_approve as int?);
    }
    if (data.containsKey('note_approve')) {
      final l$note_approve = data['note_approve'];
      result$data['note_approve'] = (l$note_approve as int?);
    }
    if (data.containsKey('cost_approve')) {
      final l$cost_approve = data['cost_approve'];
      result$data['cost_approve'] = (l$cost_approve as int?);
    }
    return Input$approveClubSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  int? get image_approve => (_$data['image_approve'] as int?);

  int? get name_approve => (_$data['name_approve'] as int?);

  int? get phone_number_approve => (_$data['phone_number_approve'] as int?);

  int? get url_approve => (_$data['url_approve'] as int?);

  int? get type_approve => (_$data['type_approve'] as int?);

  int? get no_courts_approve => (_$data['no_courts_approve'] as int?);

  int? get court_type_approve => (_$data['court_type_approve'] as int?);

  int? get is_membership_requre_approve =>
      (_$data['is_membership_requre_approve'] as int?);

  int? get mon_approve => (_$data['mon_approve'] as int?);

  int? get tue_approve => (_$data['tue_approve'] as int?);

  int? get wed_approve => (_$data['wed_approve'] as int?);

  int? get thu_approve => (_$data['thu_approve'] as int?);

  int? get fri_approve => (_$data['fri_approve'] as int?);

  int? get sat_approve => (_$data['sat_approve'] as int?);

  int? get sun_approve => (_$data['sun_approve'] as int?);

  int? get note_approve => (_$data['note_approve'] as int?);

  int? get cost_approve => (_$data['cost_approve'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('image_approve')) {
      final l$image_approve = image_approve;
      result$data['image_approve'] = l$image_approve;
    }
    if (_$data.containsKey('name_approve')) {
      final l$name_approve = name_approve;
      result$data['name_approve'] = l$name_approve;
    }
    if (_$data.containsKey('phone_number_approve')) {
      final l$phone_number_approve = phone_number_approve;
      result$data['phone_number_approve'] = l$phone_number_approve;
    }
    if (_$data.containsKey('url_approve')) {
      final l$url_approve = url_approve;
      result$data['url_approve'] = l$url_approve;
    }
    if (_$data.containsKey('type_approve')) {
      final l$type_approve = type_approve;
      result$data['type_approve'] = l$type_approve;
    }
    if (_$data.containsKey('no_courts_approve')) {
      final l$no_courts_approve = no_courts_approve;
      result$data['no_courts_approve'] = l$no_courts_approve;
    }
    if (_$data.containsKey('court_type_approve')) {
      final l$court_type_approve = court_type_approve;
      result$data['court_type_approve'] = l$court_type_approve;
    }
    if (_$data.containsKey('is_membership_requre_approve')) {
      final l$is_membership_requre_approve = is_membership_requre_approve;
      result$data['is_membership_requre_approve'] =
          l$is_membership_requre_approve;
    }
    if (_$data.containsKey('mon_approve')) {
      final l$mon_approve = mon_approve;
      result$data['mon_approve'] = l$mon_approve;
    }
    if (_$data.containsKey('tue_approve')) {
      final l$tue_approve = tue_approve;
      result$data['tue_approve'] = l$tue_approve;
    }
    if (_$data.containsKey('wed_approve')) {
      final l$wed_approve = wed_approve;
      result$data['wed_approve'] = l$wed_approve;
    }
    if (_$data.containsKey('thu_approve')) {
      final l$thu_approve = thu_approve;
      result$data['thu_approve'] = l$thu_approve;
    }
    if (_$data.containsKey('fri_approve')) {
      final l$fri_approve = fri_approve;
      result$data['fri_approve'] = l$fri_approve;
    }
    if (_$data.containsKey('sat_approve')) {
      final l$sat_approve = sat_approve;
      result$data['sat_approve'] = l$sat_approve;
    }
    if (_$data.containsKey('sun_approve')) {
      final l$sun_approve = sun_approve;
      result$data['sun_approve'] = l$sun_approve;
    }
    if (_$data.containsKey('note_approve')) {
      final l$note_approve = note_approve;
      result$data['note_approve'] = l$note_approve;
    }
    if (_$data.containsKey('cost_approve')) {
      final l$cost_approve = cost_approve;
      result$data['cost_approve'] = l$cost_approve;
    }
    return result$data;
  }

  CopyWith$Input$approveClubSuggestionInput<Input$approveClubSuggestionInput>
      get copyWith => CopyWith$Input$approveClubSuggestionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$approveClubSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$image_approve = image_approve;
    final lOther$image_approve = other.image_approve;
    if (_$data.containsKey('image_approve') !=
        other._$data.containsKey('image_approve')) {
      return false;
    }
    if (l$image_approve != lOther$image_approve) {
      return false;
    }
    final l$name_approve = name_approve;
    final lOther$name_approve = other.name_approve;
    if (_$data.containsKey('name_approve') !=
        other._$data.containsKey('name_approve')) {
      return false;
    }
    if (l$name_approve != lOther$name_approve) {
      return false;
    }
    final l$phone_number_approve = phone_number_approve;
    final lOther$phone_number_approve = other.phone_number_approve;
    if (_$data.containsKey('phone_number_approve') !=
        other._$data.containsKey('phone_number_approve')) {
      return false;
    }
    if (l$phone_number_approve != lOther$phone_number_approve) {
      return false;
    }
    final l$url_approve = url_approve;
    final lOther$url_approve = other.url_approve;
    if (_$data.containsKey('url_approve') !=
        other._$data.containsKey('url_approve')) {
      return false;
    }
    if (l$url_approve != lOther$url_approve) {
      return false;
    }
    final l$type_approve = type_approve;
    final lOther$type_approve = other.type_approve;
    if (_$data.containsKey('type_approve') !=
        other._$data.containsKey('type_approve')) {
      return false;
    }
    if (l$type_approve != lOther$type_approve) {
      return false;
    }
    final l$no_courts_approve = no_courts_approve;
    final lOther$no_courts_approve = other.no_courts_approve;
    if (_$data.containsKey('no_courts_approve') !=
        other._$data.containsKey('no_courts_approve')) {
      return false;
    }
    if (l$no_courts_approve != lOther$no_courts_approve) {
      return false;
    }
    final l$court_type_approve = court_type_approve;
    final lOther$court_type_approve = other.court_type_approve;
    if (_$data.containsKey('court_type_approve') !=
        other._$data.containsKey('court_type_approve')) {
      return false;
    }
    if (l$court_type_approve != lOther$court_type_approve) {
      return false;
    }
    final l$is_membership_requre_approve = is_membership_requre_approve;
    final lOther$is_membership_requre_approve =
        other.is_membership_requre_approve;
    if (_$data.containsKey('is_membership_requre_approve') !=
        other._$data.containsKey('is_membership_requre_approve')) {
      return false;
    }
    if (l$is_membership_requre_approve != lOther$is_membership_requre_approve) {
      return false;
    }
    final l$mon_approve = mon_approve;
    final lOther$mon_approve = other.mon_approve;
    if (_$data.containsKey('mon_approve') !=
        other._$data.containsKey('mon_approve')) {
      return false;
    }
    if (l$mon_approve != lOther$mon_approve) {
      return false;
    }
    final l$tue_approve = tue_approve;
    final lOther$tue_approve = other.tue_approve;
    if (_$data.containsKey('tue_approve') !=
        other._$data.containsKey('tue_approve')) {
      return false;
    }
    if (l$tue_approve != lOther$tue_approve) {
      return false;
    }
    final l$wed_approve = wed_approve;
    final lOther$wed_approve = other.wed_approve;
    if (_$data.containsKey('wed_approve') !=
        other._$data.containsKey('wed_approve')) {
      return false;
    }
    if (l$wed_approve != lOther$wed_approve) {
      return false;
    }
    final l$thu_approve = thu_approve;
    final lOther$thu_approve = other.thu_approve;
    if (_$data.containsKey('thu_approve') !=
        other._$data.containsKey('thu_approve')) {
      return false;
    }
    if (l$thu_approve != lOther$thu_approve) {
      return false;
    }
    final l$fri_approve = fri_approve;
    final lOther$fri_approve = other.fri_approve;
    if (_$data.containsKey('fri_approve') !=
        other._$data.containsKey('fri_approve')) {
      return false;
    }
    if (l$fri_approve != lOther$fri_approve) {
      return false;
    }
    final l$sat_approve = sat_approve;
    final lOther$sat_approve = other.sat_approve;
    if (_$data.containsKey('sat_approve') !=
        other._$data.containsKey('sat_approve')) {
      return false;
    }
    if (l$sat_approve != lOther$sat_approve) {
      return false;
    }
    final l$sun_approve = sun_approve;
    final lOther$sun_approve = other.sun_approve;
    if (_$data.containsKey('sun_approve') !=
        other._$data.containsKey('sun_approve')) {
      return false;
    }
    if (l$sun_approve != lOther$sun_approve) {
      return false;
    }
    final l$note_approve = note_approve;
    final lOther$note_approve = other.note_approve;
    if (_$data.containsKey('note_approve') !=
        other._$data.containsKey('note_approve')) {
      return false;
    }
    if (l$note_approve != lOther$note_approve) {
      return false;
    }
    final l$cost_approve = cost_approve;
    final lOther$cost_approve = other.cost_approve;
    if (_$data.containsKey('cost_approve') !=
        other._$data.containsKey('cost_approve')) {
      return false;
    }
    if (l$cost_approve != lOther$cost_approve) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$image_approve = image_approve;
    final l$name_approve = name_approve;
    final l$phone_number_approve = phone_number_approve;
    final l$url_approve = url_approve;
    final l$type_approve = type_approve;
    final l$no_courts_approve = no_courts_approve;
    final l$court_type_approve = court_type_approve;
    final l$is_membership_requre_approve = is_membership_requre_approve;
    final l$mon_approve = mon_approve;
    final l$tue_approve = tue_approve;
    final l$wed_approve = wed_approve;
    final l$thu_approve = thu_approve;
    final l$fri_approve = fri_approve;
    final l$sat_approve = sat_approve;
    final l$sun_approve = sun_approve;
    final l$note_approve = note_approve;
    final l$cost_approve = cost_approve;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('image_approve') ? l$image_approve : const {},
      _$data.containsKey('name_approve') ? l$name_approve : const {},
      _$data.containsKey('phone_number_approve')
          ? l$phone_number_approve
          : const {},
      _$data.containsKey('url_approve') ? l$url_approve : const {},
      _$data.containsKey('type_approve') ? l$type_approve : const {},
      _$data.containsKey('no_courts_approve') ? l$no_courts_approve : const {},
      _$data.containsKey('court_type_approve')
          ? l$court_type_approve
          : const {},
      _$data.containsKey('is_membership_requre_approve')
          ? l$is_membership_requre_approve
          : const {},
      _$data.containsKey('mon_approve') ? l$mon_approve : const {},
      _$data.containsKey('tue_approve') ? l$tue_approve : const {},
      _$data.containsKey('wed_approve') ? l$wed_approve : const {},
      _$data.containsKey('thu_approve') ? l$thu_approve : const {},
      _$data.containsKey('fri_approve') ? l$fri_approve : const {},
      _$data.containsKey('sat_approve') ? l$sat_approve : const {},
      _$data.containsKey('sun_approve') ? l$sun_approve : const {},
      _$data.containsKey('note_approve') ? l$note_approve : const {},
      _$data.containsKey('cost_approve') ? l$cost_approve : const {},
    ]);
  }
}

abstract class CopyWith$Input$approveClubSuggestionInput<TRes> {
  factory CopyWith$Input$approveClubSuggestionInput(
    Input$approveClubSuggestionInput instance,
    TRes Function(Input$approveClubSuggestionInput) then,
  ) = _CopyWithImpl$Input$approveClubSuggestionInput;

  factory CopyWith$Input$approveClubSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$approveClubSuggestionInput;

  TRes call({
    String? uuid,
    int? image_approve,
    int? name_approve,
    int? phone_number_approve,
    int? url_approve,
    int? type_approve,
    int? no_courts_approve,
    int? court_type_approve,
    int? is_membership_requre_approve,
    int? mon_approve,
    int? tue_approve,
    int? wed_approve,
    int? thu_approve,
    int? fri_approve,
    int? sat_approve,
    int? sun_approve,
    int? note_approve,
    int? cost_approve,
  });
}

class _CopyWithImpl$Input$approveClubSuggestionInput<TRes>
    implements CopyWith$Input$approveClubSuggestionInput<TRes> {
  _CopyWithImpl$Input$approveClubSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$approveClubSuggestionInput _instance;

  final TRes Function(Input$approveClubSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? image_approve = _undefined,
    Object? name_approve = _undefined,
    Object? phone_number_approve = _undefined,
    Object? url_approve = _undefined,
    Object? type_approve = _undefined,
    Object? no_courts_approve = _undefined,
    Object? court_type_approve = _undefined,
    Object? is_membership_requre_approve = _undefined,
    Object? mon_approve = _undefined,
    Object? tue_approve = _undefined,
    Object? wed_approve = _undefined,
    Object? thu_approve = _undefined,
    Object? fri_approve = _undefined,
    Object? sat_approve = _undefined,
    Object? sun_approve = _undefined,
    Object? note_approve = _undefined,
    Object? cost_approve = _undefined,
  }) =>
      _then(Input$approveClubSuggestionInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (image_approve != _undefined)
          'image_approve': (image_approve as int?),
        if (name_approve != _undefined) 'name_approve': (name_approve as int?),
        if (phone_number_approve != _undefined)
          'phone_number_approve': (phone_number_approve as int?),
        if (url_approve != _undefined) 'url_approve': (url_approve as int?),
        if (type_approve != _undefined) 'type_approve': (type_approve as int?),
        if (no_courts_approve != _undefined)
          'no_courts_approve': (no_courts_approve as int?),
        if (court_type_approve != _undefined)
          'court_type_approve': (court_type_approve as int?),
        if (is_membership_requre_approve != _undefined)
          'is_membership_requre_approve':
              (is_membership_requre_approve as int?),
        if (mon_approve != _undefined) 'mon_approve': (mon_approve as int?),
        if (tue_approve != _undefined) 'tue_approve': (tue_approve as int?),
        if (wed_approve != _undefined) 'wed_approve': (wed_approve as int?),
        if (thu_approve != _undefined) 'thu_approve': (thu_approve as int?),
        if (fri_approve != _undefined) 'fri_approve': (fri_approve as int?),
        if (sat_approve != _undefined) 'sat_approve': (sat_approve as int?),
        if (sun_approve != _undefined) 'sun_approve': (sun_approve as int?),
        if (note_approve != _undefined) 'note_approve': (note_approve as int?),
        if (cost_approve != _undefined) 'cost_approve': (cost_approve as int?),
      }));
}

class _CopyWithStubImpl$Input$approveClubSuggestionInput<TRes>
    implements CopyWith$Input$approveClubSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$approveClubSuggestionInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? image_approve,
    int? name_approve,
    int? phone_number_approve,
    int? url_approve,
    int? type_approve,
    int? no_courts_approve,
    int? court_type_approve,
    int? is_membership_requre_approve,
    int? mon_approve,
    int? tue_approve,
    int? wed_approve,
    int? thu_approve,
    int? fri_approve,
    int? sat_approve,
    int? sun_approve,
    int? note_approve,
    int? cost_approve,
  }) =>
      _res;
}

class Input$GetLatestEventInput {
  factory Input$GetLatestEventInput({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
    String? user_id,
  }) =>
      Input$GetLatestEventInput._({
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (rating != null) r'rating': rating,
        if (user_id != null) r'user_id': user_id,
      });

  Input$GetLatestEventInput._(this._$data);

  factory Input$GetLatestEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$GetLatestEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get rating => (_$data['rating'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$GetLatestEventInput<Input$GetLatestEventInput> get copyWith =>
      CopyWith$Input$GetLatestEventInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GetLatestEventInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$rating = rating;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$GetLatestEventInput<TRes> {
  factory CopyWith$Input$GetLatestEventInput(
    Input$GetLatestEventInput instance,
    TRes Function(Input$GetLatestEventInput) then,
  ) = _CopyWithImpl$Input$GetLatestEventInput;

  factory CopyWith$Input$GetLatestEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GetLatestEventInput;

  TRes call({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
    String? user_id,
  });
}

class _CopyWithImpl$Input$GetLatestEventInput<TRes>
    implements CopyWith$Input$GetLatestEventInput<TRes> {
  _CopyWithImpl$Input$GetLatestEventInput(
    this._instance,
    this._then,
  );

  final Input$GetLatestEventInput _instance;

  final TRes Function(Input$GetLatestEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? rating = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$GetLatestEventInput._({
        ..._instance._$data,
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$GetLatestEventInput<TRes>
    implements CopyWith$Input$GetLatestEventInput<TRes> {
  _CopyWithStubImpl$Input$GetLatestEventInput(this._res);

  TRes _res;

  call({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
    String? user_id,
  }) =>
      _res;
}

class Input$MyEventScheduleListFrontPaginationInput {
  factory Input$MyEventScheduleListFrontPaginationInput({
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      Input$MyEventScheduleListFrontPaginationInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
      });

  Input$MyEventScheduleListFrontPaginationInput._(this._$data);

  factory Input$MyEventScheduleListFrontPaginationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    return Input$MyEventScheduleListFrontPaginationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    return result$data;
  }

  CopyWith$Input$MyEventScheduleListFrontPaginationInput<
          Input$MyEventScheduleListFrontPaginationInput>
      get copyWith => CopyWith$Input$MyEventScheduleListFrontPaginationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MyEventScheduleListFrontPaginationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
    ]);
  }
}

abstract class CopyWith$Input$MyEventScheduleListFrontPaginationInput<TRes> {
  factory CopyWith$Input$MyEventScheduleListFrontPaginationInput(
    Input$MyEventScheduleListFrontPaginationInput instance,
    TRes Function(Input$MyEventScheduleListFrontPaginationInput) then,
  ) = _CopyWithImpl$Input$MyEventScheduleListFrontPaginationInput;

  factory CopyWith$Input$MyEventScheduleListFrontPaginationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$MyEventScheduleListFrontPaginationInput;

  TRes call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  });
}

class _CopyWithImpl$Input$MyEventScheduleListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyEventScheduleListFrontPaginationInput<TRes> {
  _CopyWithImpl$Input$MyEventScheduleListFrontPaginationInput(
    this._instance,
    this._then,
  );

  final Input$MyEventScheduleListFrontPaginationInput _instance;

  final TRes Function(Input$MyEventScheduleListFrontPaginationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
  }) =>
      _then(Input$MyEventScheduleListFrontPaginationInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
      }));
}

class _CopyWithStubImpl$Input$MyEventScheduleListFrontPaginationInput<TRes>
    implements CopyWith$Input$MyEventScheduleListFrontPaginationInput<TRes> {
  _CopyWithStubImpl$Input$MyEventScheduleListFrontPaginationInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    int? radius,
    double? latitude,
    double? longitude,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    List<String?>? organized_by,
    String? open_slot_filt,
  }) =>
      _res;
}

class Input$EventsOpenInput {
  factory Input$EventsOpenInput({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? is_event,
    int? is_my_events,
    String? event_list_type,
    String? timezone,
    String? open_slot_filt,
  }) =>
      Input$EventsOpenInput._({
        if (user_name != null) r'user_name': user_name,
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
        if (is_event != null) r'is_event': is_event,
        if (is_my_events != null) r'is_my_events': is_my_events,
        if (event_list_type != null) r'event_list_type': event_list_type,
        if (timezone != null) r'timezone': timezone,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
      });

  Input$EventsOpenInput._(this._$data);

  factory Input$EventsOpenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_name')) {
      final l$user_name = data['user_name'];
      result$data['user_name'] = (l$user_name as String?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as String?);
    }
    if (data.containsKey('is_my_events')) {
      final l$is_my_events = data['is_my_events'];
      result$data['is_my_events'] = (l$is_my_events as int?);
    }
    if (data.containsKey('event_list_type')) {
      final l$event_list_type = data['event_list_type'];
      result$data['event_list_type'] = (l$event_list_type as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    return Input$EventsOpenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_name => (_$data['user_name'] as String?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get is_event => (_$data['is_event'] as String?);

  int? get is_my_events => (_$data['is_my_events'] as int?);

  String? get event_list_type => (_$data['event_list_type'] as String?);

  String? get timezone => (_$data['timezone'] as String?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_name')) {
      final l$user_name = user_name;
      result$data['user_name'] = l$user_name;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('is_my_events')) {
      final l$is_my_events = is_my_events;
      result$data['is_my_events'] = l$is_my_events;
    }
    if (_$data.containsKey('event_list_type')) {
      final l$event_list_type = event_list_type;
      result$data['event_list_type'] = l$event_list_type;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    return result$data;
  }

  CopyWith$Input$EventsOpenInput<Input$EventsOpenInput> get copyWith =>
      CopyWith$Input$EventsOpenInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventsOpenInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_name = user_name;
    final lOther$user_name = other.user_name;
    if (_$data.containsKey('user_name') !=
        other._$data.containsKey('user_name')) {
      return false;
    }
    if (l$user_name != lOther$user_name) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$is_my_events = is_my_events;
    final lOther$is_my_events = other.is_my_events;
    if (_$data.containsKey('is_my_events') !=
        other._$data.containsKey('is_my_events')) {
      return false;
    }
    if (l$is_my_events != lOther$is_my_events) {
      return false;
    }
    final l$event_list_type = event_list_type;
    final lOther$event_list_type = other.event_list_type;
    if (_$data.containsKey('event_list_type') !=
        other._$data.containsKey('event_list_type')) {
      return false;
    }
    if (l$event_list_type != lOther$event_list_type) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_name = user_name;
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    final l$is_event = is_event;
    final l$is_my_events = is_my_events;
    final l$event_list_type = event_list_type;
    final l$timezone = timezone;
    final l$open_slot_filt = open_slot_filt;
    return Object.hashAll([
      _$data.containsKey('user_name') ? l$user_name : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('is_my_events') ? l$is_my_events : const {},
      _$data.containsKey('event_list_type') ? l$event_list_type : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventsOpenInput<TRes> {
  factory CopyWith$Input$EventsOpenInput(
    Input$EventsOpenInput instance,
    TRes Function(Input$EventsOpenInput) then,
  ) = _CopyWithImpl$Input$EventsOpenInput;

  factory CopyWith$Input$EventsOpenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventsOpenInput;

  TRes call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? is_event,
    int? is_my_events,
    String? event_list_type,
    String? timezone,
    String? open_slot_filt,
  });
}

class _CopyWithImpl$Input$EventsOpenInput<TRes>
    implements CopyWith$Input$EventsOpenInput<TRes> {
  _CopyWithImpl$Input$EventsOpenInput(
    this._instance,
    this._then,
  );

  final Input$EventsOpenInput _instance;

  final TRes Function(Input$EventsOpenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_name = _undefined,
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
    Object? is_event = _undefined,
    Object? is_my_events = _undefined,
    Object? event_list_type = _undefined,
    Object? timezone = _undefined,
    Object? open_slot_filt = _undefined,
  }) =>
      _then(Input$EventsOpenInput._({
        ..._instance._$data,
        if (user_name != _undefined) 'user_name': (user_name as String?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (is_event != _undefined) 'is_event': (is_event as String?),
        if (is_my_events != _undefined) 'is_my_events': (is_my_events as int?),
        if (event_list_type != _undefined)
          'event_list_type': (event_list_type as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
      }));
}

class _CopyWithStubImpl$Input$EventsOpenInput<TRes>
    implements CopyWith$Input$EventsOpenInput<TRes> {
  _CopyWithStubImpl$Input$EventsOpenInput(this._res);

  TRes _res;

  call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? is_event,
    int? is_my_events,
    String? event_list_type,
    String? timezone,
    String? open_slot_filt,
  }) =>
      _res;
}

class Input$removePlayerInput {
  factory Input$removePlayerInput({
    int? match_type,
    String? match_uuid,
    String? user_uuid,
  }) =>
      Input$removePlayerInput._({
        if (match_type != null) r'match_type': match_type,
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$removePlayerInput._(this._$data);

  factory Input$removePlayerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as int?);
    }
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$removePlayerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get match_type => (_$data['match_type'] as int?);

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$removePlayerInput<Input$removePlayerInput> get copyWith =>
      CopyWith$Input$removePlayerInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$removePlayerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_type = match_type;
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$removePlayerInput<TRes> {
  factory CopyWith$Input$removePlayerInput(
    Input$removePlayerInput instance,
    TRes Function(Input$removePlayerInput) then,
  ) = _CopyWithImpl$Input$removePlayerInput;

  factory CopyWith$Input$removePlayerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$removePlayerInput;

  TRes call({
    int? match_type,
    String? match_uuid,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$removePlayerInput<TRes>
    implements CopyWith$Input$removePlayerInput<TRes> {
  _CopyWithImpl$Input$removePlayerInput(
    this._instance,
    this._then,
  );

  final Input$removePlayerInput _instance;

  final TRes Function(Input$removePlayerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_type = _undefined,
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$removePlayerInput._({
        ..._instance._$data,
        if (match_type != _undefined) 'match_type': (match_type as int?),
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$removePlayerInput<TRes>
    implements CopyWith$Input$removePlayerInput<TRes> {
  _CopyWithStubImpl$Input$removePlayerInput(this._res);

  TRes _res;

  call({
    int? match_type,
    String? match_uuid,
    String? user_uuid,
  }) =>
      _res;
}

class Input$joinMatchInput {
  factory Input$joinMatchInput({
    String? uuid,
    int? request_type,
  }) =>
      Input$joinMatchInput._({
        if (uuid != null) r'uuid': uuid,
        if (request_type != null) r'request_type': request_type,
      });

  Input$joinMatchInput._(this._$data);

  factory Input$joinMatchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('request_type')) {
      final l$request_type = data['request_type'];
      result$data['request_type'] = (l$request_type as int?);
    }
    return Input$joinMatchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get uuid => (_$data['uuid'] as String?);

  int? get request_type => (_$data['request_type'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('request_type')) {
      final l$request_type = request_type;
      result$data['request_type'] = l$request_type;
    }
    return result$data;
  }

  CopyWith$Input$joinMatchInput<Input$joinMatchInput> get copyWith =>
      CopyWith$Input$joinMatchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$joinMatchInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$request_type = request_type;
    final lOther$request_type = other.request_type;
    if (_$data.containsKey('request_type') !=
        other._$data.containsKey('request_type')) {
      return false;
    }
    if (l$request_type != lOther$request_type) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$request_type = request_type;
    return Object.hashAll([
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('request_type') ? l$request_type : const {},
    ]);
  }
}

abstract class CopyWith$Input$joinMatchInput<TRes> {
  factory CopyWith$Input$joinMatchInput(
    Input$joinMatchInput instance,
    TRes Function(Input$joinMatchInput) then,
  ) = _CopyWithImpl$Input$joinMatchInput;

  factory CopyWith$Input$joinMatchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$joinMatchInput;

  TRes call({
    String? uuid,
    int? request_type,
  });
}

class _CopyWithImpl$Input$joinMatchInput<TRes>
    implements CopyWith$Input$joinMatchInput<TRes> {
  _CopyWithImpl$Input$joinMatchInput(
    this._instance,
    this._then,
  );

  final Input$joinMatchInput _instance;

  final TRes Function(Input$joinMatchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? request_type = _undefined,
  }) =>
      _then(Input$joinMatchInput._({
        ..._instance._$data,
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (request_type != _undefined) 'request_type': (request_type as int?),
      }));
}

class _CopyWithStubImpl$Input$joinMatchInput<TRes>
    implements CopyWith$Input$joinMatchInput<TRes> {
  _CopyWithStubImpl$Input$joinMatchInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? request_type,
  }) =>
      _res;
}

class Input$CommonOpenEventsInput {
  factory Input$CommonOpenEventsInput({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
    int? gender,
  }) =>
      Input$CommonOpenEventsInput._({
        if (user_name != null) r'user_name': user_name,
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
        if (timezone != null) r'timezone': timezone,
        if (is_event != null) r'is_event': is_event,
        if (gender != null) r'gender': gender,
      });

  Input$CommonOpenEventsInput._(this._$data);

  factory Input$CommonOpenEventsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_name')) {
      final l$user_name = data['user_name'];
      result$data['user_name'] = (l$user_name as String?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    return Input$CommonOpenEventsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_name => (_$data['user_name'] as String?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get timezone => (_$data['timezone'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  int? get gender => (_$data['gender'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_name')) {
      final l$user_name = user_name;
      result$data['user_name'] = l$user_name;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    return result$data;
  }

  CopyWith$Input$CommonOpenEventsInput<Input$CommonOpenEventsInput>
      get copyWith => CopyWith$Input$CommonOpenEventsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonOpenEventsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_name = user_name;
    final lOther$user_name = other.user_name;
    if (_$data.containsKey('user_name') !=
        other._$data.containsKey('user_name')) {
      return false;
    }
    if (l$user_name != lOther$user_name) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_name = user_name;
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    final l$timezone = timezone;
    final l$is_event = is_event;
    final l$gender = gender;
    return Object.hashAll([
      _$data.containsKey('user_name') ? l$user_name : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('gender') ? l$gender : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonOpenEventsInput<TRes> {
  factory CopyWith$Input$CommonOpenEventsInput(
    Input$CommonOpenEventsInput instance,
    TRes Function(Input$CommonOpenEventsInput) then,
  ) = _CopyWithImpl$Input$CommonOpenEventsInput;

  factory CopyWith$Input$CommonOpenEventsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonOpenEventsInput;

  TRes call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
    int? gender,
  });
}

class _CopyWithImpl$Input$CommonOpenEventsInput<TRes>
    implements CopyWith$Input$CommonOpenEventsInput<TRes> {
  _CopyWithImpl$Input$CommonOpenEventsInput(
    this._instance,
    this._then,
  );

  final Input$CommonOpenEventsInput _instance;

  final TRes Function(Input$CommonOpenEventsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_name = _undefined,
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
    Object? timezone = _undefined,
    Object? is_event = _undefined,
    Object? gender = _undefined,
  }) =>
      _then(Input$CommonOpenEventsInput._({
        ..._instance._$data,
        if (user_name != _undefined) 'user_name': (user_name as String?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (gender != _undefined) 'gender': (gender as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonOpenEventsInput<TRes>
    implements CopyWith$Input$CommonOpenEventsInput<TRes> {
  _CopyWithStubImpl$Input$CommonOpenEventsInput(this._res);

  TRes _res;

  call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
    int? gender,
  }) =>
      _res;
}

class Input$CommonPastEventsInput {
  factory Input$CommonPastEventsInput({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
  }) =>
      Input$CommonPastEventsInput._({
        if (user_name != null) r'user_name': user_name,
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
        if (timezone != null) r'timezone': timezone,
        if (is_event != null) r'is_event': is_event,
      });

  Input$CommonPastEventsInput._(this._$data);

  factory Input$CommonPastEventsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_name')) {
      final l$user_name = data['user_name'];
      result$data['user_name'] = (l$user_name as String?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    return Input$CommonPastEventsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_name => (_$data['user_name'] as String?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get timezone => (_$data['timezone'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_name')) {
      final l$user_name = user_name;
      result$data['user_name'] = l$user_name;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    return result$data;
  }

  CopyWith$Input$CommonPastEventsInput<Input$CommonPastEventsInput>
      get copyWith => CopyWith$Input$CommonPastEventsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonPastEventsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_name = user_name;
    final lOther$user_name = other.user_name;
    if (_$data.containsKey('user_name') !=
        other._$data.containsKey('user_name')) {
      return false;
    }
    if (l$user_name != lOther$user_name) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_name = user_name;
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    final l$timezone = timezone;
    final l$is_event = is_event;
    return Object.hashAll([
      _$data.containsKey('user_name') ? l$user_name : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonPastEventsInput<TRes> {
  factory CopyWith$Input$CommonPastEventsInput(
    Input$CommonPastEventsInput instance,
    TRes Function(Input$CommonPastEventsInput) then,
  ) = _CopyWithImpl$Input$CommonPastEventsInput;

  factory CopyWith$Input$CommonPastEventsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonPastEventsInput;

  TRes call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
  });
}

class _CopyWithImpl$Input$CommonPastEventsInput<TRes>
    implements CopyWith$Input$CommonPastEventsInput<TRes> {
  _CopyWithImpl$Input$CommonPastEventsInput(
    this._instance,
    this._then,
  );

  final Input$CommonPastEventsInput _instance;

  final TRes Function(Input$CommonPastEventsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_name = _undefined,
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
    Object? timezone = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$CommonPastEventsInput._({
        ..._instance._$data,
        if (user_name != _undefined) 'user_name': (user_name as String?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonPastEventsInput<TRes>
    implements CopyWith$Input$CommonPastEventsInput<TRes> {
  _CopyWithStubImpl$Input$CommonPastEventsInput(this._res);

  TRes _res;

  call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? timezone,
    int? is_event,
  }) =>
      _res;
}

class Input$CommonScheduleEventsInput {
  factory Input$CommonScheduleEventsInput({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    required int offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
    int? is_event,
    int? is_approved_tournament,
  }) =>
      Input$CommonScheduleEventsInput._({
        if (user_name != null) r'user_name': user_name,
        if (match_title != null) r'match_title': match_title,
        if (location != null) r'location': location,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (invitation_status != null) r'invitation_status': invitation_status,
        if (schdeuled_type != null) r'schdeuled_type': schdeuled_type,
        if (match_type != null) r'match_type': match_type,
        if (skill_level != null) r'skill_level': skill_level,
        if (rating != null) r'rating': rating,
        if (club_name != null) r'club_name': club_name,
        if (club_type != null) r'club_type': club_type,
        if (is_membership_require != null)
          r'is_membership_require': is_membership_require,
        if (time_line != null) r'time_line': time_line,
        if (from_date != null) r'from_date': from_date,
        if (to_date != null) r'to_date': to_date,
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (organized_by != null) r'organized_by': organized_by,
        if (open_slot_filt != null) r'open_slot_filt': open_slot_filt,
        if (timezone != null) r'timezone': timezone,
        if (is_event != null) r'is_event': is_event,
        if (is_approved_tournament != null)
          r'is_approved_tournament': is_approved_tournament,
      });

  Input$CommonScheduleEventsInput._(this._$data);

  factory Input$CommonScheduleEventsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('user_name')) {
      final l$user_name = data['user_name'];
      result$data['user_name'] = (l$user_name as String?);
    }
    if (data.containsKey('match_title')) {
      final l$match_title = data['match_title'];
      result$data['match_title'] = (l$match_title as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('invitation_status')) {
      final l$invitation_status = data['invitation_status'];
      result$data['invitation_status'] = (l$invitation_status as String?);
    }
    if (data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = data['schdeuled_type'];
      result$data['schdeuled_type'] = (l$schdeuled_type as String?);
    }
    if (data.containsKey('match_type')) {
      final l$match_type = data['match_type'];
      result$data['match_type'] = (l$match_type as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('club_type')) {
      final l$club_type = data['club_type'];
      result$data['club_type'] = (l$club_type as String?);
    }
    if (data.containsKey('is_membership_require')) {
      final l$is_membership_require = data['is_membership_require'];
      result$data['is_membership_require'] =
          (l$is_membership_require as String?);
    }
    if (data.containsKey('time_line')) {
      final l$time_line = data['time_line'];
      result$data['time_line'] = (l$time_line as String?);
    }
    if (data.containsKey('from_date')) {
      final l$from_date = data['from_date'];
      result$data['from_date'] = (l$from_date as String?);
    }
    if (data.containsKey('to_date')) {
      final l$to_date = data['to_date'];
      result$data['to_date'] = (l$to_date as String?);
    }
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('organized_by')) {
      final l$organized_by = data['organized_by'];
      result$data['organized_by'] = (l$organized_by as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = data['open_slot_filt'];
      result$data['open_slot_filt'] = (l$open_slot_filt as String?);
    }
    if (data.containsKey('timezone')) {
      final l$timezone = data['timezone'];
      result$data['timezone'] = (l$timezone as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('is_approved_tournament')) {
      final l$is_approved_tournament = data['is_approved_tournament'];
      result$data['is_approved_tournament'] =
          (l$is_approved_tournament as int?);
    }
    return Input$CommonScheduleEventsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get user_name => (_$data['user_name'] as String?);

  String? get match_title => (_$data['match_title'] as String?);

  String? get location => (_$data['location'] as String?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get invitation_status => (_$data['invitation_status'] as String?);

  String? get schdeuled_type => (_$data['schdeuled_type'] as String?);

  String? get match_type => (_$data['match_type'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get rating => (_$data['rating'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get club_type => (_$data['club_type'] as String?);

  String? get is_membership_require =>
      (_$data['is_membership_require'] as String?);

  String? get time_line => (_$data['time_line'] as String?);

  String? get from_date => (_$data['from_date'] as String?);

  String? get to_date => (_$data['to_date'] as String?);

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get organized_by => (_$data['organized_by'] as List<String?>?);

  String? get open_slot_filt => (_$data['open_slot_filt'] as String?);

  String? get timezone => (_$data['timezone'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  int? get is_approved_tournament => (_$data['is_approved_tournament'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('user_name')) {
      final l$user_name = user_name;
      result$data['user_name'] = l$user_name;
    }
    if (_$data.containsKey('match_title')) {
      final l$match_title = match_title;
      result$data['match_title'] = l$match_title;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('invitation_status')) {
      final l$invitation_status = invitation_status;
      result$data['invitation_status'] = l$invitation_status;
    }
    if (_$data.containsKey('schdeuled_type')) {
      final l$schdeuled_type = schdeuled_type;
      result$data['schdeuled_type'] = l$schdeuled_type;
    }
    if (_$data.containsKey('match_type')) {
      final l$match_type = match_type;
      result$data['match_type'] = l$match_type;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('club_type')) {
      final l$club_type = club_type;
      result$data['club_type'] = l$club_type;
    }
    if (_$data.containsKey('is_membership_require')) {
      final l$is_membership_require = is_membership_require;
      result$data['is_membership_require'] = l$is_membership_require;
    }
    if (_$data.containsKey('time_line')) {
      final l$time_line = time_line;
      result$data['time_line'] = l$time_line;
    }
    if (_$data.containsKey('from_date')) {
      final l$from_date = from_date;
      result$data['from_date'] = l$from_date;
    }
    if (_$data.containsKey('to_date')) {
      final l$to_date = to_date;
      result$data['to_date'] = l$to_date;
    }
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('organized_by')) {
      final l$organized_by = organized_by;
      result$data['organized_by'] = l$organized_by?.map((e) => e).toList();
    }
    if (_$data.containsKey('open_slot_filt')) {
      final l$open_slot_filt = open_slot_filt;
      result$data['open_slot_filt'] = l$open_slot_filt;
    }
    if (_$data.containsKey('timezone')) {
      final l$timezone = timezone;
      result$data['timezone'] = l$timezone;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('is_approved_tournament')) {
      final l$is_approved_tournament = is_approved_tournament;
      result$data['is_approved_tournament'] = l$is_approved_tournament;
    }
    return result$data;
  }

  CopyWith$Input$CommonScheduleEventsInput<Input$CommonScheduleEventsInput>
      get copyWith => CopyWith$Input$CommonScheduleEventsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonScheduleEventsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$user_name = user_name;
    final lOther$user_name = other.user_name;
    if (_$data.containsKey('user_name') !=
        other._$data.containsKey('user_name')) {
      return false;
    }
    if (l$user_name != lOther$user_name) {
      return false;
    }
    final l$match_title = match_title;
    final lOther$match_title = other.match_title;
    if (_$data.containsKey('match_title') !=
        other._$data.containsKey('match_title')) {
      return false;
    }
    if (l$match_title != lOther$match_title) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$invitation_status = invitation_status;
    final lOther$invitation_status = other.invitation_status;
    if (_$data.containsKey('invitation_status') !=
        other._$data.containsKey('invitation_status')) {
      return false;
    }
    if (l$invitation_status != lOther$invitation_status) {
      return false;
    }
    final l$schdeuled_type = schdeuled_type;
    final lOther$schdeuled_type = other.schdeuled_type;
    if (_$data.containsKey('schdeuled_type') !=
        other._$data.containsKey('schdeuled_type')) {
      return false;
    }
    if (l$schdeuled_type != lOther$schdeuled_type) {
      return false;
    }
    final l$match_type = match_type;
    final lOther$match_type = other.match_type;
    if (_$data.containsKey('match_type') !=
        other._$data.containsKey('match_type')) {
      return false;
    }
    if (l$match_type != lOther$match_type) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$club_type = club_type;
    final lOther$club_type = other.club_type;
    if (_$data.containsKey('club_type') !=
        other._$data.containsKey('club_type')) {
      return false;
    }
    if (l$club_type != lOther$club_type) {
      return false;
    }
    final l$is_membership_require = is_membership_require;
    final lOther$is_membership_require = other.is_membership_require;
    if (_$data.containsKey('is_membership_require') !=
        other._$data.containsKey('is_membership_require')) {
      return false;
    }
    if (l$is_membership_require != lOther$is_membership_require) {
      return false;
    }
    final l$time_line = time_line;
    final lOther$time_line = other.time_line;
    if (_$data.containsKey('time_line') !=
        other._$data.containsKey('time_line')) {
      return false;
    }
    if (l$time_line != lOther$time_line) {
      return false;
    }
    final l$from_date = from_date;
    final lOther$from_date = other.from_date;
    if (_$data.containsKey('from_date') !=
        other._$data.containsKey('from_date')) {
      return false;
    }
    if (l$from_date != lOther$from_date) {
      return false;
    }
    final l$to_date = to_date;
    final lOther$to_date = other.to_date;
    if (_$data.containsKey('to_date') != other._$data.containsKey('to_date')) {
      return false;
    }
    if (l$to_date != lOther$to_date) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$organized_by = organized_by;
    final lOther$organized_by = other.organized_by;
    if (_$data.containsKey('organized_by') !=
        other._$data.containsKey('organized_by')) {
      return false;
    }
    if (l$organized_by != null && lOther$organized_by != null) {
      if (l$organized_by.length != lOther$organized_by.length) {
        return false;
      }
      for (int i = 0; i < l$organized_by.length; i++) {
        final l$organized_by$entry = l$organized_by[i];
        final lOther$organized_by$entry = lOther$organized_by[i];
        if (l$organized_by$entry != lOther$organized_by$entry) {
          return false;
        }
      }
    } else if (l$organized_by != lOther$organized_by) {
      return false;
    }
    final l$open_slot_filt = open_slot_filt;
    final lOther$open_slot_filt = other.open_slot_filt;
    if (_$data.containsKey('open_slot_filt') !=
        other._$data.containsKey('open_slot_filt')) {
      return false;
    }
    if (l$open_slot_filt != lOther$open_slot_filt) {
      return false;
    }
    final l$timezone = timezone;
    final lOther$timezone = other.timezone;
    if (_$data.containsKey('timezone') !=
        other._$data.containsKey('timezone')) {
      return false;
    }
    if (l$timezone != lOther$timezone) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$is_approved_tournament = is_approved_tournament;
    final lOther$is_approved_tournament = other.is_approved_tournament;
    if (_$data.containsKey('is_approved_tournament') !=
        other._$data.containsKey('is_approved_tournament')) {
      return false;
    }
    if (l$is_approved_tournament != lOther$is_approved_tournament) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$user_name = user_name;
    final l$match_title = match_title;
    final l$location = location;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$invitation_status = invitation_status;
    final l$schdeuled_type = schdeuled_type;
    final l$match_type = match_type;
    final l$skill_level = skill_level;
    final l$rating = rating;
    final l$club_name = club_name;
    final l$club_type = club_type;
    final l$is_membership_require = is_membership_require;
    final l$time_line = time_line;
    final l$from_date = from_date;
    final l$to_date = to_date;
    final l$offset = offset;
    final l$limit = limit;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$organized_by = organized_by;
    final l$open_slot_filt = open_slot_filt;
    final l$timezone = timezone;
    final l$is_event = is_event;
    final l$is_approved_tournament = is_approved_tournament;
    return Object.hashAll([
      _$data.containsKey('user_name') ? l$user_name : const {},
      _$data.containsKey('match_title') ? l$match_title : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('invitation_status') ? l$invitation_status : const {},
      _$data.containsKey('schdeuled_type') ? l$schdeuled_type : const {},
      _$data.containsKey('match_type') ? l$match_type : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('rating') ? l$rating : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('club_type') ? l$club_type : const {},
      _$data.containsKey('is_membership_require')
          ? l$is_membership_require
          : const {},
      _$data.containsKey('time_line') ? l$time_line : const {},
      _$data.containsKey('from_date') ? l$from_date : const {},
      _$data.containsKey('to_date') ? l$to_date : const {},
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('organized_by')
          ? l$organized_by == null
              ? null
              : Object.hashAll(l$organized_by.map((v) => v))
          : const {},
      _$data.containsKey('open_slot_filt') ? l$open_slot_filt : const {},
      _$data.containsKey('timezone') ? l$timezone : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('is_approved_tournament')
          ? l$is_approved_tournament
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonScheduleEventsInput<TRes> {
  factory CopyWith$Input$CommonScheduleEventsInput(
    Input$CommonScheduleEventsInput instance,
    TRes Function(Input$CommonScheduleEventsInput) then,
  ) = _CopyWithImpl$Input$CommonScheduleEventsInput;

  factory CopyWith$Input$CommonScheduleEventsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonScheduleEventsInput;

  TRes call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
    int? is_event,
    int? is_approved_tournament,
  });
}

class _CopyWithImpl$Input$CommonScheduleEventsInput<TRes>
    implements CopyWith$Input$CommonScheduleEventsInput<TRes> {
  _CopyWithImpl$Input$CommonScheduleEventsInput(
    this._instance,
    this._then,
  );

  final Input$CommonScheduleEventsInput _instance;

  final TRes Function(Input$CommonScheduleEventsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? user_name = _undefined,
    Object? match_title = _undefined,
    Object? location = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? invitation_status = _undefined,
    Object? schdeuled_type = _undefined,
    Object? match_type = _undefined,
    Object? skill_level = _undefined,
    Object? rating = _undefined,
    Object? club_name = _undefined,
    Object? club_type = _undefined,
    Object? is_membership_require = _undefined,
    Object? time_line = _undefined,
    Object? from_date = _undefined,
    Object? to_date = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? organized_by = _undefined,
    Object? open_slot_filt = _undefined,
    Object? timezone = _undefined,
    Object? is_event = _undefined,
    Object? is_approved_tournament = _undefined,
  }) =>
      _then(Input$CommonScheduleEventsInput._({
        ..._instance._$data,
        if (user_name != _undefined) 'user_name': (user_name as String?),
        if (match_title != _undefined) 'match_title': (match_title as String?),
        if (location != _undefined) 'location': (location as String?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (invitation_status != _undefined)
          'invitation_status': (invitation_status as String?),
        if (schdeuled_type != _undefined)
          'schdeuled_type': (schdeuled_type as String?),
        if (match_type != _undefined) 'match_type': (match_type as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (rating != _undefined) 'rating': (rating as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (club_type != _undefined) 'club_type': (club_type as String?),
        if (is_membership_require != _undefined)
          'is_membership_require': (is_membership_require as String?),
        if (time_line != _undefined) 'time_line': (time_line as String?),
        if (from_date != _undefined) 'from_date': (from_date as String?),
        if (to_date != _undefined) 'to_date': (to_date as String?),
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (organized_by != _undefined)
          'organized_by': (organized_by as List<String?>?),
        if (open_slot_filt != _undefined)
          'open_slot_filt': (open_slot_filt as String?),
        if (timezone != _undefined) 'timezone': (timezone as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (is_approved_tournament != _undefined)
          'is_approved_tournament': (is_approved_tournament as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonScheduleEventsInput<TRes>
    implements CopyWith$Input$CommonScheduleEventsInput<TRes> {
  _CopyWithStubImpl$Input$CommonScheduleEventsInput(this._res);

  TRes _res;

  call({
    String? user_name,
    String? match_title,
    String? location,
    double? latitude,
    double? longitude,
    int? radius,
    String? invitation_status,
    String? schdeuled_type,
    String? match_type,
    String? skill_level,
    String? rating,
    String? club_name,
    String? club_type,
    String? is_membership_require,
    String? time_line,
    String? from_date,
    String? to_date,
    int? offset,
    int? limit,
    String? sort_column,
    String? sort_order,
    List<String?>? organized_by,
    String? open_slot_filt,
    String? timezone,
    int? is_event,
    int? is_approved_tournament,
  }) =>
      _res;
}

class Input$CoachListInput {
  factory Input$CoachListInput({
    int? offset,
    int? limit,
    String? name,
    String? match_id,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
    int? match_organiser,
    String? clubs,
  }) =>
      Input$CoachListInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (name != null) r'name': name,
        if (match_id != null) r'match_id': match_id,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (match_organiser != null) r'match_organiser': match_organiser,
        if (clubs != null) r'clubs': clubs,
      });

  Input$CoachListInput._(this._$data);

  factory Input$CoachListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('match_organiser')) {
      final l$match_organiser = data['match_organiser'];
      result$data['match_organiser'] = (l$match_organiser as int?);
    }
    if (data.containsKey('clubs')) {
      final l$clubs = data['clubs'];
      result$data['clubs'] = (l$clubs as String?);
    }
    return Input$CoachListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get name => (_$data['name'] as String?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  int? get match_organiser => (_$data['match_organiser'] as int?);

  String? get clubs => (_$data['clubs'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('match_organiser')) {
      final l$match_organiser = match_organiser;
      result$data['match_organiser'] = l$match_organiser;
    }
    if (_$data.containsKey('clubs')) {
      final l$clubs = clubs;
      result$data['clubs'] = l$clubs;
    }
    return result$data;
  }

  CopyWith$Input$CoachListInput<Input$CoachListInput> get copyWith =>
      CopyWith$Input$CoachListInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CoachListInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$match_organiser = match_organiser;
    final lOther$match_organiser = other.match_organiser;
    if (_$data.containsKey('match_organiser') !=
        other._$data.containsKey('match_organiser')) {
      return false;
    }
    if (l$match_organiser != lOther$match_organiser) {
      return false;
    }
    final l$clubs = clubs;
    final lOther$clubs = other.clubs;
    if (_$data.containsKey('clubs') != other._$data.containsKey('clubs')) {
      return false;
    }
    if (l$clubs != lOther$clubs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$name = name;
    final l$match_id = match_id;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$match_organiser = match_organiser;
    final l$clubs = clubs;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('match_organiser') ? l$match_organiser : const {},
      _$data.containsKey('clubs') ? l$clubs : const {},
    ]);
  }
}

abstract class CopyWith$Input$CoachListInput<TRes> {
  factory CopyWith$Input$CoachListInput(
    Input$CoachListInput instance,
    TRes Function(Input$CoachListInput) then,
  ) = _CopyWithImpl$Input$CoachListInput;

  factory CopyWith$Input$CoachListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CoachListInput;

  TRes call({
    int? offset,
    int? limit,
    String? name,
    String? match_id,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
    int? match_organiser,
    String? clubs,
  });
}

class _CopyWithImpl$Input$CoachListInput<TRes>
    implements CopyWith$Input$CoachListInput<TRes> {
  _CopyWithImpl$Input$CoachListInput(
    this._instance,
    this._then,
  );

  final Input$CoachListInput _instance;

  final TRes Function(Input$CoachListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? name = _undefined,
    Object? match_id = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? match_organiser = _undefined,
    Object? clubs = _undefined,
  }) =>
      _then(Input$CoachListInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (name != _undefined) 'name': (name as String?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (match_organiser != _undefined)
          'match_organiser': (match_organiser as int?),
        if (clubs != _undefined) 'clubs': (clubs as String?),
      }));
}

class _CopyWithStubImpl$Input$CoachListInput<TRes>
    implements CopyWith$Input$CoachListInput<TRes> {
  _CopyWithStubImpl$Input$CoachListInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? name,
    String? match_id,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
    int? match_organiser,
    String? clubs,
  }) =>
      _res;
}

class Input$InvitedCoachListInput {
  factory Input$InvitedCoachListInput({
    String? name,
    required String uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$InvitedCoachListInput._({
        if (name != null) r'name': name,
        r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$InvitedCoachListInput._(this._$data);

  factory Input$InvitedCoachListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$InvitedCoachListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String get uuid => (_$data['uuid'] as String);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$InvitedCoachListInput<Input$InvitedCoachListInput>
      get copyWith => CopyWith$Input$InvitedCoachListInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitedCoachListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      l$uuid,
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitedCoachListInput<TRes> {
  factory CopyWith$Input$InvitedCoachListInput(
    Input$InvitedCoachListInput instance,
    TRes Function(Input$InvitedCoachListInput) then,
  ) = _CopyWithImpl$Input$InvitedCoachListInput;

  factory CopyWith$Input$InvitedCoachListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitedCoachListInput;

  TRes call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$InvitedCoachListInput<TRes>
    implements CopyWith$Input$InvitedCoachListInput<TRes> {
  _CopyWithImpl$Input$InvitedCoachListInput(
    this._instance,
    this._then,
  );

  final Input$InvitedCoachListInput _instance;

  final TRes Function(Input$InvitedCoachListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$InvitedCoachListInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$InvitedCoachListInput<TRes>
    implements CopyWith$Input$InvitedCoachListInput<TRes> {
  _CopyWithStubImpl$Input$InvitedCoachListInput(this._res);

  TRes _res;

  call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$sendCoachInviteInput {
  factory Input$sendCoachInviteInput({
    String? match_id,
    List<String?>? players,
    String? time_zone,
    bool? is_alert_notification,
    bool? is_reinvite,
  }) =>
      Input$sendCoachInviteInput._({
        if (match_id != null) r'match_id': match_id,
        if (players != null) r'players': players,
        if (time_zone != null) r'time_zone': time_zone,
        if (is_alert_notification != null)
          r'is_alert_notification': is_alert_notification,
        if (is_reinvite != null) r'is_reinvite': is_reinvite,
      });

  Input$sendCoachInviteInput._(this._$data);

  factory Input$sendCoachInviteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('players')) {
      final l$players = data['players'];
      result$data['players'] =
          (l$players as List<dynamic>?)?.map((e) => (e as String?)).toList();
    }
    if (data.containsKey('time_zone')) {
      final l$time_zone = data['time_zone'];
      result$data['time_zone'] = (l$time_zone as String?);
    }
    if (data.containsKey('is_alert_notification')) {
      final l$is_alert_notification = data['is_alert_notification'];
      result$data['is_alert_notification'] = (l$is_alert_notification as bool?);
    }
    if (data.containsKey('is_reinvite')) {
      final l$is_reinvite = data['is_reinvite'];
      result$data['is_reinvite'] = (l$is_reinvite as bool?);
    }
    return Input$sendCoachInviteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  List<String?>? get players => (_$data['players'] as List<String?>?);

  String? get time_zone => (_$data['time_zone'] as String?);

  bool? get is_alert_notification => (_$data['is_alert_notification'] as bool?);

  bool? get is_reinvite => (_$data['is_reinvite'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('players')) {
      final l$players = players;
      result$data['players'] = l$players?.map((e) => e).toList();
    }
    if (_$data.containsKey('time_zone')) {
      final l$time_zone = time_zone;
      result$data['time_zone'] = l$time_zone;
    }
    if (_$data.containsKey('is_alert_notification')) {
      final l$is_alert_notification = is_alert_notification;
      result$data['is_alert_notification'] = l$is_alert_notification;
    }
    if (_$data.containsKey('is_reinvite')) {
      final l$is_reinvite = is_reinvite;
      result$data['is_reinvite'] = l$is_reinvite;
    }
    return result$data;
  }

  CopyWith$Input$sendCoachInviteInput<Input$sendCoachInviteInput>
      get copyWith => CopyWith$Input$sendCoachInviteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$sendCoachInviteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$players = players;
    final lOther$players = other.players;
    if (_$data.containsKey('players') != other._$data.containsKey('players')) {
      return false;
    }
    if (l$players != null && lOther$players != null) {
      if (l$players.length != lOther$players.length) {
        return false;
      }
      for (int i = 0; i < l$players.length; i++) {
        final l$players$entry = l$players[i];
        final lOther$players$entry = lOther$players[i];
        if (l$players$entry != lOther$players$entry) {
          return false;
        }
      }
    } else if (l$players != lOther$players) {
      return false;
    }
    final l$time_zone = time_zone;
    final lOther$time_zone = other.time_zone;
    if (_$data.containsKey('time_zone') !=
        other._$data.containsKey('time_zone')) {
      return false;
    }
    if (l$time_zone != lOther$time_zone) {
      return false;
    }
    final l$is_alert_notification = is_alert_notification;
    final lOther$is_alert_notification = other.is_alert_notification;
    if (_$data.containsKey('is_alert_notification') !=
        other._$data.containsKey('is_alert_notification')) {
      return false;
    }
    if (l$is_alert_notification != lOther$is_alert_notification) {
      return false;
    }
    final l$is_reinvite = is_reinvite;
    final lOther$is_reinvite = other.is_reinvite;
    if (_$data.containsKey('is_reinvite') !=
        other._$data.containsKey('is_reinvite')) {
      return false;
    }
    if (l$is_reinvite != lOther$is_reinvite) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$players = players;
    final l$time_zone = time_zone;
    final l$is_alert_notification = is_alert_notification;
    final l$is_reinvite = is_reinvite;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('players')
          ? l$players == null
              ? null
              : Object.hashAll(l$players.map((v) => v))
          : const {},
      _$data.containsKey('time_zone') ? l$time_zone : const {},
      _$data.containsKey('is_alert_notification')
          ? l$is_alert_notification
          : const {},
      _$data.containsKey('is_reinvite') ? l$is_reinvite : const {},
    ]);
  }
}

abstract class CopyWith$Input$sendCoachInviteInput<TRes> {
  factory CopyWith$Input$sendCoachInviteInput(
    Input$sendCoachInviteInput instance,
    TRes Function(Input$sendCoachInviteInput) then,
  ) = _CopyWithImpl$Input$sendCoachInviteInput;

  factory CopyWith$Input$sendCoachInviteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$sendCoachInviteInput;

  TRes call({
    String? match_id,
    List<String?>? players,
    String? time_zone,
    bool? is_alert_notification,
    bool? is_reinvite,
  });
}

class _CopyWithImpl$Input$sendCoachInviteInput<TRes>
    implements CopyWith$Input$sendCoachInviteInput<TRes> {
  _CopyWithImpl$Input$sendCoachInviteInput(
    this._instance,
    this._then,
  );

  final Input$sendCoachInviteInput _instance;

  final TRes Function(Input$sendCoachInviteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? players = _undefined,
    Object? time_zone = _undefined,
    Object? is_alert_notification = _undefined,
    Object? is_reinvite = _undefined,
  }) =>
      _then(Input$sendCoachInviteInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (players != _undefined) 'players': (players as List<String?>?),
        if (time_zone != _undefined) 'time_zone': (time_zone as String?),
        if (is_alert_notification != _undefined)
          'is_alert_notification': (is_alert_notification as bool?),
        if (is_reinvite != _undefined) 'is_reinvite': (is_reinvite as bool?),
      }));
}

class _CopyWithStubImpl$Input$sendCoachInviteInput<TRes>
    implements CopyWith$Input$sendCoachInviteInput<TRes> {
  _CopyWithStubImpl$Input$sendCoachInviteInput(this._res);

  TRes _res;

  call({
    String? match_id,
    List<String?>? players,
    String? time_zone,
    bool? is_alert_notification,
    bool? is_reinvite,
  }) =>
      _res;
}

class Input$CoachRemoveInput {
  factory Input$CoachRemoveInput({
    required String match_uuid,
    required List<String?> user,
  }) =>
      Input$CoachRemoveInput._({
        r'match_uuid': match_uuid,
        r'user': user,
      });

  Input$CoachRemoveInput._(this._$data);

  factory Input$CoachRemoveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_uuid = data['match_uuid'];
    result$data['match_uuid'] = (l$match_uuid as String);
    final l$user = data['user'];
    result$data['user'] =
        (l$user as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$CoachRemoveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_uuid => (_$data['match_uuid'] as String);

  List<String?> get user => (_$data['user'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_uuid = match_uuid;
    result$data['match_uuid'] = l$match_uuid;
    final l$user = user;
    result$data['user'] = l$user.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$CoachRemoveInput<Input$CoachRemoveInput> get copyWith =>
      CopyWith$Input$CoachRemoveInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CoachRemoveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user.length != lOther$user.length) {
      return false;
    }
    for (int i = 0; i < l$user.length; i++) {
      final l$user$entry = l$user[i];
      final lOther$user$entry = lOther$user[i];
      if (l$user$entry != lOther$user$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user = user;
    return Object.hashAll([
      l$match_uuid,
      Object.hashAll(l$user.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$CoachRemoveInput<TRes> {
  factory CopyWith$Input$CoachRemoveInput(
    Input$CoachRemoveInput instance,
    TRes Function(Input$CoachRemoveInput) then,
  ) = _CopyWithImpl$Input$CoachRemoveInput;

  factory CopyWith$Input$CoachRemoveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CoachRemoveInput;

  TRes call({
    String? match_uuid,
    List<String?>? user,
  });
}

class _CopyWithImpl$Input$CoachRemoveInput<TRes>
    implements CopyWith$Input$CoachRemoveInput<TRes> {
  _CopyWithImpl$Input$CoachRemoveInput(
    this._instance,
    this._then,
  );

  final Input$CoachRemoveInput _instance;

  final TRes Function(Input$CoachRemoveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user = _undefined,
  }) =>
      _then(Input$CoachRemoveInput._({
        ..._instance._$data,
        if (match_uuid != _undefined && match_uuid != null)
          'match_uuid': (match_uuid as String),
        if (user != _undefined && user != null) 'user': (user as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$CoachRemoveInput<TRes>
    implements CopyWith$Input$CoachRemoveInput<TRes> {
  _CopyWithStubImpl$Input$CoachRemoveInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    List<String?>? user,
  }) =>
      _res;
}

class Input$viewCommonEventInput {
  factory Input$viewCommonEventInput({required String uuid}) =>
      Input$viewCommonEventInput._({
        r'uuid': uuid,
      });

  Input$viewCommonEventInput._(this._$data);

  factory Input$viewCommonEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewCommonEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewCommonEventInput<Input$viewCommonEventInput>
      get copyWith => CopyWith$Input$viewCommonEventInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewCommonEventInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewCommonEventInput<TRes> {
  factory CopyWith$Input$viewCommonEventInput(
    Input$viewCommonEventInput instance,
    TRes Function(Input$viewCommonEventInput) then,
  ) = _CopyWithImpl$Input$viewCommonEventInput;

  factory CopyWith$Input$viewCommonEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewCommonEventInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewCommonEventInput<TRes>
    implements CopyWith$Input$viewCommonEventInput<TRes> {
  _CopyWithImpl$Input$viewCommonEventInput(
    this._instance,
    this._then,
  );

  final Input$viewCommonEventInput _instance;

  final TRes Function(Input$viewCommonEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) => _then(Input$viewCommonEventInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewCommonEventInput<TRes>
    implements CopyWith$Input$viewCommonEventInput<TRes> {
  _CopyWithStubImpl$Input$viewCommonEventInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$AddRequestPlayInputEvent {
  factory Input$AddRequestPlayInputEvent({
    required String match_id,
    required String user_id,
    required int is_event,
  }) =>
      Input$AddRequestPlayInputEvent._({
        r'match_id': match_id,
        r'user_id': user_id,
        r'is_event': is_event,
      });

  Input$AddRequestPlayInputEvent._(this._$data);

  factory Input$AddRequestPlayInputEvent.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    return Input$AddRequestPlayInputEvent._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  int get is_event => (_$data['is_event'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    return result$data;
  }

  CopyWith$Input$AddRequestPlayInputEvent<Input$AddRequestPlayInputEvent>
      get copyWith => CopyWith$Input$AddRequestPlayInputEvent(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddRequestPlayInputEvent) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_event = is_event;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      l$is_event,
    ]);
  }
}

abstract class CopyWith$Input$AddRequestPlayInputEvent<TRes> {
  factory CopyWith$Input$AddRequestPlayInputEvent(
    Input$AddRequestPlayInputEvent instance,
    TRes Function(Input$AddRequestPlayInputEvent) then,
  ) = _CopyWithImpl$Input$AddRequestPlayInputEvent;

  factory CopyWith$Input$AddRequestPlayInputEvent.stub(TRes res) =
      _CopyWithStubImpl$Input$AddRequestPlayInputEvent;

  TRes call({
    String? match_id,
    String? user_id,
    int? is_event,
  });
}

class _CopyWithImpl$Input$AddRequestPlayInputEvent<TRes>
    implements CopyWith$Input$AddRequestPlayInputEvent<TRes> {
  _CopyWithImpl$Input$AddRequestPlayInputEvent(
    this._instance,
    this._then,
  );

  final Input$AddRequestPlayInputEvent _instance;

  final TRes Function(Input$AddRequestPlayInputEvent) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$AddRequestPlayInputEvent._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
      }));
}

class _CopyWithStubImpl$Input$AddRequestPlayInputEvent<TRes>
    implements CopyWith$Input$AddRequestPlayInputEvent<TRes> {
  _CopyWithStubImpl$Input$AddRequestPlayInputEvent(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    int? is_event,
  }) =>
      _res;
}

class Input$EventRequestedUserInput {
  factory Input$EventRequestedUserInput({
    required String match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$EventRequestedUserInput._({
        r'match_id': match_id,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$EventRequestedUserInput._(this._$data);

  factory Input$EventRequestedUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$EventRequestedUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$EventRequestedUserInput<Input$EventRequestedUserInput>
      get copyWith => CopyWith$Input$EventRequestedUserInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventRequestedUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$match_id,
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventRequestedUserInput<TRes> {
  factory CopyWith$Input$EventRequestedUserInput(
    Input$EventRequestedUserInput instance,
    TRes Function(Input$EventRequestedUserInput) then,
  ) = _CopyWithImpl$Input$EventRequestedUserInput;

  factory CopyWith$Input$EventRequestedUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventRequestedUserInput;

  TRes call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$EventRequestedUserInput<TRes>
    implements CopyWith$Input$EventRequestedUserInput<TRes> {
  _CopyWithImpl$Input$EventRequestedUserInput(
    this._instance,
    this._then,
  );

  final Input$EventRequestedUserInput _instance;

  final TRes Function(Input$EventRequestedUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$EventRequestedUserInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$EventRequestedUserInput<TRes>
    implements CopyWith$Input$EventRequestedUserInput<TRes> {
  _CopyWithStubImpl$Input$EventRequestedUserInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$InvitedEventMemberInput {
  factory Input$InvitedEventMemberInput({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$InvitedEventMemberInput._({
        if (name != null) r'name': name,
        if (uuid != null) r'uuid': uuid,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$InvitedEventMemberInput._(this._$data);

  factory Input$InvitedEventMemberInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$InvitedEventMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$InvitedEventMemberInput<Input$InvitedEventMemberInput>
      get copyWith => CopyWith$Input$InvitedEventMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitedEventMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$uuid = uuid;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitedEventMemberInput<TRes> {
  factory CopyWith$Input$InvitedEventMemberInput(
    Input$InvitedEventMemberInput instance,
    TRes Function(Input$InvitedEventMemberInput) then,
  ) = _CopyWithImpl$Input$InvitedEventMemberInput;

  factory CopyWith$Input$InvitedEventMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitedEventMemberInput;

  TRes call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$InvitedEventMemberInput<TRes>
    implements CopyWith$Input$InvitedEventMemberInput<TRes> {
  _CopyWithImpl$Input$InvitedEventMemberInput(
    this._instance,
    this._then,
  );

  final Input$InvitedEventMemberInput _instance;

  final TRes Function(Input$InvitedEventMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? uuid = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$InvitedEventMemberInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$InvitedEventMemberInput<TRes>
    implements CopyWith$Input$InvitedEventMemberInput<TRes> {
  _CopyWithStubImpl$Input$InvitedEventMemberInput(this._res);

  TRes _res;

  call({
    String? name,
    String? uuid,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$EventReqAcceptInput {
  factory Input$EventReqAcceptInput({
    required String match_id,
    required String user_id,
    required int is_event,
    int? tier_price,
    String? tier_description,
  }) =>
      Input$EventReqAcceptInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        r'is_event': is_event,
        if (tier_price != null) r'tier_price': tier_price,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$EventReqAcceptInput._(this._$data);

  factory Input$EventReqAcceptInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    if (data.containsKey('tier_price')) {
      final l$tier_price = data['tier_price'];
      result$data['tier_price'] = (l$tier_price as int?);
    }
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$EventReqAcceptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  int get is_event => (_$data['is_event'] as int);

  int? get tier_price => (_$data['tier_price'] as int?);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    if (_$data.containsKey('tier_price')) {
      final l$tier_price = tier_price;
      result$data['tier_price'] = l$tier_price;
    }
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$EventReqAcceptInput<Input$EventReqAcceptInput> get copyWith =>
      CopyWith$Input$EventReqAcceptInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventReqAcceptInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$tier_price = tier_price;
    final lOther$tier_price = other.tier_price;
    if (_$data.containsKey('tier_price') !=
        other._$data.containsKey('tier_price')) {
      return false;
    }
    if (l$tier_price != lOther$tier_price) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_event = is_event;
    final l$tier_price = tier_price;
    final l$tier_description = tier_description;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      l$is_event,
      _$data.containsKey('tier_price') ? l$tier_price : const {},
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventReqAcceptInput<TRes> {
  factory CopyWith$Input$EventReqAcceptInput(
    Input$EventReqAcceptInput instance,
    TRes Function(Input$EventReqAcceptInput) then,
  ) = _CopyWithImpl$Input$EventReqAcceptInput;

  factory CopyWith$Input$EventReqAcceptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventReqAcceptInput;

  TRes call({
    String? match_id,
    String? user_id,
    int? is_event,
    int? tier_price,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$EventReqAcceptInput<TRes>
    implements CopyWith$Input$EventReqAcceptInput<TRes> {
  _CopyWithImpl$Input$EventReqAcceptInput(
    this._instance,
    this._then,
  );

  final Input$EventReqAcceptInput _instance;

  final TRes Function(Input$EventReqAcceptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_event = _undefined,
    Object? tier_price = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$EventReqAcceptInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
        if (tier_price != _undefined) 'tier_price': (tier_price as int?),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$EventReqAcceptInput<TRes>
    implements CopyWith$Input$EventReqAcceptInput<TRes> {
  _CopyWithStubImpl$Input$EventReqAcceptInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    int? is_event,
    int? tier_price,
    String? tier_description,
  }) =>
      _res;
}

class Input$CommonEventReqRejectInput {
  factory Input$CommonEventReqRejectInput({
    required String match_id,
    required String user_id,
    bool? is_host_reject,
    required int is_event,
  }) =>
      Input$CommonEventReqRejectInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        if (is_host_reject != null) r'is_host_reject': is_host_reject,
        r'is_event': is_event,
      });

  Input$CommonEventReqRejectInput._(this._$data);

  factory Input$CommonEventReqRejectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    if (data.containsKey('is_host_reject')) {
      final l$is_host_reject = data['is_host_reject'];
      result$data['is_host_reject'] = (l$is_host_reject as bool?);
    }
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    return Input$CommonEventReqRejectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  bool? get is_host_reject => (_$data['is_host_reject'] as bool?);

  int get is_event => (_$data['is_event'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    if (_$data.containsKey('is_host_reject')) {
      final l$is_host_reject = is_host_reject;
      result$data['is_host_reject'] = l$is_host_reject;
    }
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    return result$data;
  }

  CopyWith$Input$CommonEventReqRejectInput<Input$CommonEventReqRejectInput>
      get copyWith => CopyWith$Input$CommonEventReqRejectInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonEventReqRejectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_host_reject = is_host_reject;
    final lOther$is_host_reject = other.is_host_reject;
    if (_$data.containsKey('is_host_reject') !=
        other._$data.containsKey('is_host_reject')) {
      return false;
    }
    if (l$is_host_reject != lOther$is_host_reject) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_host_reject = is_host_reject;
    final l$is_event = is_event;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      _$data.containsKey('is_host_reject') ? l$is_host_reject : const {},
      l$is_event,
    ]);
  }
}

abstract class CopyWith$Input$CommonEventReqRejectInput<TRes> {
  factory CopyWith$Input$CommonEventReqRejectInput(
    Input$CommonEventReqRejectInput instance,
    TRes Function(Input$CommonEventReqRejectInput) then,
  ) = _CopyWithImpl$Input$CommonEventReqRejectInput;

  factory CopyWith$Input$CommonEventReqRejectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonEventReqRejectInput;

  TRes call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
    int? is_event,
  });
}

class _CopyWithImpl$Input$CommonEventReqRejectInput<TRes>
    implements CopyWith$Input$CommonEventReqRejectInput<TRes> {
  _CopyWithImpl$Input$CommonEventReqRejectInput(
    this._instance,
    this._then,
  );

  final Input$CommonEventReqRejectInput _instance;

  final TRes Function(Input$CommonEventReqRejectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_host_reject = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$CommonEventReqRejectInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_host_reject != _undefined)
          'is_host_reject': (is_host_reject as bool?),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
      }));
}

class _CopyWithStubImpl$Input$CommonEventReqRejectInput<TRes>
    implements CopyWith$Input$CommonEventReqRejectInput<TRes> {
  _CopyWithStubImpl$Input$CommonEventReqRejectInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    bool? is_host_reject,
    int? is_event,
  }) =>
      _res;
}

class Input$EventCancelInput {
  factory Input$EventCancelInput({
    String? match_id,
    int? cancel_all,
    required int is_event,
  }) =>
      Input$EventCancelInput._({
        if (match_id != null) r'match_id': match_id,
        if (cancel_all != null) r'cancel_all': cancel_all,
        r'is_event': is_event,
      });

  Input$EventCancelInput._(this._$data);

  factory Input$EventCancelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('cancel_all')) {
      final l$cancel_all = data['cancel_all'];
      result$data['cancel_all'] = (l$cancel_all as int?);
    }
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    return Input$EventCancelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  int? get cancel_all => (_$data['cancel_all'] as int?);

  int get is_event => (_$data['is_event'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('cancel_all')) {
      final l$cancel_all = cancel_all;
      result$data['cancel_all'] = l$cancel_all;
    }
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    return result$data;
  }

  CopyWith$Input$EventCancelInput<Input$EventCancelInput> get copyWith =>
      CopyWith$Input$EventCancelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventCancelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$cancel_all = cancel_all;
    final lOther$cancel_all = other.cancel_all;
    if (_$data.containsKey('cancel_all') !=
        other._$data.containsKey('cancel_all')) {
      return false;
    }
    if (l$cancel_all != lOther$cancel_all) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$cancel_all = cancel_all;
    final l$is_event = is_event;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('cancel_all') ? l$cancel_all : const {},
      l$is_event,
    ]);
  }
}

abstract class CopyWith$Input$EventCancelInput<TRes> {
  factory CopyWith$Input$EventCancelInput(
    Input$EventCancelInput instance,
    TRes Function(Input$EventCancelInput) then,
  ) = _CopyWithImpl$Input$EventCancelInput;

  factory CopyWith$Input$EventCancelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventCancelInput;

  TRes call({
    String? match_id,
    int? cancel_all,
    int? is_event,
  });
}

class _CopyWithImpl$Input$EventCancelInput<TRes>
    implements CopyWith$Input$EventCancelInput<TRes> {
  _CopyWithImpl$Input$EventCancelInput(
    this._instance,
    this._then,
  );

  final Input$EventCancelInput _instance;

  final TRes Function(Input$EventCancelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? cancel_all = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$EventCancelInput._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (cancel_all != _undefined) 'cancel_all': (cancel_all as int?),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
      }));
}

class _CopyWithStubImpl$Input$EventCancelInput<TRes>
    implements CopyWith$Input$EventCancelInput<TRes> {
  _CopyWithStubImpl$Input$EventCancelInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? cancel_all,
    int? is_event,
  }) =>
      _res;
}

class Input$addPaymentInputEvent {
  factory Input$addPaymentInputEvent({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    required int is_event,
    String? tier_description,
  }) =>
      Input$addPaymentInputEvent._({
        if (match_id != null) r'match_id': match_id,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (transaction_fee != null) r'transaction_fee': transaction_fee,
        if (admin_fee != null) r'admin_fee': admin_fee,
        if (total != null) r'total': total,
        r'is_event': is_event,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$addPaymentInputEvent._(this._$data);

  factory Input$addPaymentInputEvent.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('transaction_fee')) {
      final l$transaction_fee = data['transaction_fee'];
      result$data['transaction_fee'] = (l$transaction_fee as String?);
    }
    if (data.containsKey('admin_fee')) {
      final l$admin_fee = data['admin_fee'];
      result$data['admin_fee'] = (l$admin_fee as String?);
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] = (l$total as String?);
    }
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$addPaymentInputEvent._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_id => (_$data['match_id'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get transaction_fee => (_$data['transaction_fee'] as String?);

  String? get admin_fee => (_$data['admin_fee'] as String?);

  String? get total => (_$data['total'] as String?);

  int get is_event => (_$data['is_event'] as int);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('transaction_fee')) {
      final l$transaction_fee = transaction_fee;
      result$data['transaction_fee'] = l$transaction_fee;
    }
    if (_$data.containsKey('admin_fee')) {
      final l$admin_fee = admin_fee;
      result$data['admin_fee'] = l$admin_fee;
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] = l$total;
    }
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$addPaymentInputEvent<Input$addPaymentInputEvent>
      get copyWith => CopyWith$Input$addPaymentInputEvent(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addPaymentInputEvent) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$transaction_fee = transaction_fee;
    final lOther$transaction_fee = other.transaction_fee;
    if (_$data.containsKey('transaction_fee') !=
        other._$data.containsKey('transaction_fee')) {
      return false;
    }
    if (l$transaction_fee != lOther$transaction_fee) {
      return false;
    }
    final l$admin_fee = admin_fee;
    final lOther$admin_fee = other.admin_fee;
    if (_$data.containsKey('admin_fee') !=
        other._$data.containsKey('admin_fee')) {
      return false;
    }
    if (l$admin_fee != lOther$admin_fee) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$cost_per_player = cost_per_player;
    final l$transaction_fee = transaction_fee;
    final l$admin_fee = admin_fee;
    final l$total = total;
    final l$is_event = is_event;
    final l$tier_description = tier_description;
    return Object.hashAll([
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('transaction_fee') ? l$transaction_fee : const {},
      _$data.containsKey('admin_fee') ? l$admin_fee : const {},
      _$data.containsKey('total') ? l$total : const {},
      l$is_event,
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$addPaymentInputEvent<TRes> {
  factory CopyWith$Input$addPaymentInputEvent(
    Input$addPaymentInputEvent instance,
    TRes Function(Input$addPaymentInputEvent) then,
  ) = _CopyWithImpl$Input$addPaymentInputEvent;

  factory CopyWith$Input$addPaymentInputEvent.stub(TRes res) =
      _CopyWithStubImpl$Input$addPaymentInputEvent;

  TRes call({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    int? is_event,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$addPaymentInputEvent<TRes>
    implements CopyWith$Input$addPaymentInputEvent<TRes> {
  _CopyWithImpl$Input$addPaymentInputEvent(
    this._instance,
    this._then,
  );

  final Input$addPaymentInputEvent _instance;

  final TRes Function(Input$addPaymentInputEvent) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? cost_per_player = _undefined,
    Object? transaction_fee = _undefined,
    Object? admin_fee = _undefined,
    Object? total = _undefined,
    Object? is_event = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$addPaymentInputEvent._({
        ..._instance._$data,
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (transaction_fee != _undefined)
          'transaction_fee': (transaction_fee as String?),
        if (admin_fee != _undefined) 'admin_fee': (admin_fee as String?),
        if (total != _undefined) 'total': (total as String?),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$addPaymentInputEvent<TRes>
    implements CopyWith$Input$addPaymentInputEvent<TRes> {
  _CopyWithStubImpl$Input$addPaymentInputEvent(this._res);

  TRes _res;

  call({
    String? match_id,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    int? is_event,
    String? tier_description,
  }) =>
      _res;
}

class Input$CommunityEventsListInput {
  factory Input$CommunityEventsListInput({
    double? latitude,
    double? longitude,
    int? radius,
    String? skill_level,
    String? community_photo,
    int? gender,
  }) =>
      Input$CommunityEventsListInput._({
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (skill_level != null) r'skill_level': skill_level,
        if (community_photo != null) r'community_photo': community_photo,
        if (gender != null) r'gender': gender,
      });

  Input$CommunityEventsListInput._(this._$data);

  factory Input$CommunityEventsListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('community_photo')) {
      final l$community_photo = data['community_photo'];
      result$data['community_photo'] = (l$community_photo as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    return Input$CommunityEventsListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get community_photo => (_$data['community_photo'] as String?);

  int? get gender => (_$data['gender'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('community_photo')) {
      final l$community_photo = community_photo;
      result$data['community_photo'] = l$community_photo;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    return result$data;
  }

  CopyWith$Input$CommunityEventsListInput<Input$CommunityEventsListInput>
      get copyWith => CopyWith$Input$CommunityEventsListInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommunityEventsListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$community_photo = community_photo;
    final lOther$community_photo = other.community_photo;
    if (_$data.containsKey('community_photo') !=
        other._$data.containsKey('community_photo')) {
      return false;
    }
    if (l$community_photo != lOther$community_photo) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$skill_level = skill_level;
    final l$community_photo = community_photo;
    final l$gender = gender;
    return Object.hashAll([
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('community_photo') ? l$community_photo : const {},
      _$data.containsKey('gender') ? l$gender : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommunityEventsListInput<TRes> {
  factory CopyWith$Input$CommunityEventsListInput(
    Input$CommunityEventsListInput instance,
    TRes Function(Input$CommunityEventsListInput) then,
  ) = _CopyWithImpl$Input$CommunityEventsListInput;

  factory CopyWith$Input$CommunityEventsListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommunityEventsListInput;

  TRes call({
    double? latitude,
    double? longitude,
    int? radius,
    String? skill_level,
    String? community_photo,
    int? gender,
  });
}

class _CopyWithImpl$Input$CommunityEventsListInput<TRes>
    implements CopyWith$Input$CommunityEventsListInput<TRes> {
  _CopyWithImpl$Input$CommunityEventsListInput(
    this._instance,
    this._then,
  );

  final Input$CommunityEventsListInput _instance;

  final TRes Function(Input$CommunityEventsListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? skill_level = _undefined,
    Object? community_photo = _undefined,
    Object? gender = _undefined,
  }) =>
      _then(Input$CommunityEventsListInput._({
        ..._instance._$data,
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (community_photo != _undefined)
          'community_photo': (community_photo as String?),
        if (gender != _undefined) 'gender': (gender as int?),
      }));
}

class _CopyWithStubImpl$Input$CommunityEventsListInput<TRes>
    implements CopyWith$Input$CommunityEventsListInput<TRes> {
  _CopyWithStubImpl$Input$CommunityEventsListInput(this._res);

  TRes _res;

  call({
    double? latitude,
    double? longitude,
    int? radius,
    String? skill_level,
    String? community_photo,
    int? gender,
  }) =>
      _res;
}

class Input$setPartnerPreferenceInput {
  factory Input$setPartnerPreferenceInput({
    required String match_id,
    required String user_id,
    required List<String?> preferred_to,
  }) =>
      Input$setPartnerPreferenceInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        r'preferred_to': preferred_to,
      });

  Input$setPartnerPreferenceInput._(this._$data);

  factory Input$setPartnerPreferenceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    final l$preferred_to = data['preferred_to'];
    result$data['preferred_to'] =
        (l$preferred_to as List<dynamic>).map((e) => (e as String?)).toList();
    return Input$setPartnerPreferenceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  List<String?> get preferred_to => (_$data['preferred_to'] as List<String?>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    final l$preferred_to = preferred_to;
    result$data['preferred_to'] = l$preferred_to.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$setPartnerPreferenceInput<Input$setPartnerPreferenceInput>
      get copyWith => CopyWith$Input$setPartnerPreferenceInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$setPartnerPreferenceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$preferred_to = preferred_to;
    final lOther$preferred_to = other.preferred_to;
    if (l$preferred_to.length != lOther$preferred_to.length) {
      return false;
    }
    for (int i = 0; i < l$preferred_to.length; i++) {
      final l$preferred_to$entry = l$preferred_to[i];
      final lOther$preferred_to$entry = lOther$preferred_to[i];
      if (l$preferred_to$entry != lOther$preferred_to$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$preferred_to = preferred_to;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      Object.hashAll(l$preferred_to.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$setPartnerPreferenceInput<TRes> {
  factory CopyWith$Input$setPartnerPreferenceInput(
    Input$setPartnerPreferenceInput instance,
    TRes Function(Input$setPartnerPreferenceInput) then,
  ) = _CopyWithImpl$Input$setPartnerPreferenceInput;

  factory CopyWith$Input$setPartnerPreferenceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$setPartnerPreferenceInput;

  TRes call({
    String? match_id,
    String? user_id,
    List<String?>? preferred_to,
  });
}

class _CopyWithImpl$Input$setPartnerPreferenceInput<TRes>
    implements CopyWith$Input$setPartnerPreferenceInput<TRes> {
  _CopyWithImpl$Input$setPartnerPreferenceInput(
    this._instance,
    this._then,
  );

  final Input$setPartnerPreferenceInput _instance;

  final TRes Function(Input$setPartnerPreferenceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? preferred_to = _undefined,
  }) =>
      _then(Input$setPartnerPreferenceInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (preferred_to != _undefined && preferred_to != null)
          'preferred_to': (preferred_to as List<String?>),
      }));
}

class _CopyWithStubImpl$Input$setPartnerPreferenceInput<TRes>
    implements CopyWith$Input$setPartnerPreferenceInput<TRes> {
  _CopyWithStubImpl$Input$setPartnerPreferenceInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    List<String?>? preferred_to,
  }) =>
      _res;
}

class Input$EventWaitingListInput {
  factory Input$EventWaitingListInput({
    required String match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$EventWaitingListInput._({
        r'match_id': match_id,
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (skill_level != null) r'skill_level': skill_level,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (recommendation_level != null)
          r'recommendation_level': recommendation_level,
        if (age_range != null) r'age_range': age_range,
        if (gender != null) r'gender': gender,
        if (friends != null) r'friends': friends,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$EventWaitingListInput._(this._$data);

  factory Input$EventWaitingListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('recommendation_level')) {
      final l$recommendation_level = data['recommendation_level'];
      result$data['recommendation_level'] = (l$recommendation_level as String?);
    }
    if (data.containsKey('age_range')) {
      final l$age_range = data['age_range'];
      result$data['age_range'] = (l$age_range as String?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as String?);
    }
    if (data.containsKey('friends')) {
      final l$friends = data['friends'];
      result$data['friends'] = (l$friends as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$EventWaitingListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get skill_level => (_$data['skill_level'] as String?);

  int? get radius => (_$data['radius'] as int?);

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  String? get recommendation_level =>
      (_$data['recommendation_level'] as String?);

  String? get age_range => (_$data['age_range'] as String?);

  String? get gender => (_$data['gender'] as String?);

  String? get friends => (_$data['friends'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('recommendation_level')) {
      final l$recommendation_level = recommendation_level;
      result$data['recommendation_level'] = l$recommendation_level;
    }
    if (_$data.containsKey('age_range')) {
      final l$age_range = age_range;
      result$data['age_range'] = l$age_range;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    if (_$data.containsKey('friends')) {
      final l$friends = friends;
      result$data['friends'] = l$friends;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$EventWaitingListInput<Input$EventWaitingListInput>
      get copyWith => CopyWith$Input$EventWaitingListInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventWaitingListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$recommendation_level = recommendation_level;
    final lOther$recommendation_level = other.recommendation_level;
    if (_$data.containsKey('recommendation_level') !=
        other._$data.containsKey('recommendation_level')) {
      return false;
    }
    if (l$recommendation_level != lOther$recommendation_level) {
      return false;
    }
    final l$age_range = age_range;
    final lOther$age_range = other.age_range;
    if (_$data.containsKey('age_range') !=
        other._$data.containsKey('age_range')) {
      return false;
    }
    if (l$age_range != lOther$age_range) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    final l$friends = friends;
    final lOther$friends = other.friends;
    if (_$data.containsKey('friends') != other._$data.containsKey('friends')) {
      return false;
    }
    if (l$friends != lOther$friends) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$offset = offset;
    final l$limit = limit;
    final l$skill_level = skill_level;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$recommendation_level = recommendation_level;
    final l$age_range = age_range;
    final l$gender = gender;
    final l$friends = friends;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      l$match_id,
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('recommendation_level')
          ? l$recommendation_level
          : const {},
      _$data.containsKey('age_range') ? l$age_range : const {},
      _$data.containsKey('gender') ? l$gender : const {},
      _$data.containsKey('friends') ? l$friends : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventWaitingListInput<TRes> {
  factory CopyWith$Input$EventWaitingListInput(
    Input$EventWaitingListInput instance,
    TRes Function(Input$EventWaitingListInput) then,
  ) = _CopyWithImpl$Input$EventWaitingListInput;

  factory CopyWith$Input$EventWaitingListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventWaitingListInput;

  TRes call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$EventWaitingListInput<TRes>
    implements CopyWith$Input$EventWaitingListInput<TRes> {
  _CopyWithImpl$Input$EventWaitingListInput(
    this._instance,
    this._then,
  );

  final Input$EventWaitingListInput _instance;

  final TRes Function(Input$EventWaitingListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? skill_level = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? recommendation_level = _undefined,
    Object? age_range = _undefined,
    Object? gender = _undefined,
    Object? friends = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$EventWaitingListInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (recommendation_level != _undefined)
          'recommendation_level': (recommendation_level as String?),
        if (age_range != _undefined) 'age_range': (age_range as String?),
        if (gender != _undefined) 'gender': (gender as String?),
        if (friends != _undefined) 'friends': (friends as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$EventWaitingListInput<TRes>
    implements CopyWith$Input$EventWaitingListInput<TRes> {
  _CopyWithStubImpl$Input$EventWaitingListInput(this._res);

  TRes _res;

  call({
    String? match_id,
    int? offset,
    int? limit,
    String? skill_level,
    int? radius,
    double? latitude,
    double? longitude,
    String? recommendation_level,
    String? age_range,
    String? gender,
    String? friends,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$CancelWaitingSpotInput {
  factory Input$CancelWaitingSpotInput({
    required String match_id,
    required String user_id,
    required int is_event,
  }) =>
      Input$CancelWaitingSpotInput._({
        r'match_id': match_id,
        r'user_id': user_id,
        r'is_event': is_event,
      });

  Input$CancelWaitingSpotInput._(this._$data);

  factory Input$CancelWaitingSpotInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$match_id = data['match_id'];
    result$data['match_id'] = (l$match_id as String);
    final l$user_id = data['user_id'];
    result$data['user_id'] = (l$user_id as String);
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    return Input$CancelWaitingSpotInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get match_id => (_$data['match_id'] as String);

  String get user_id => (_$data['user_id'] as String);

  int get is_event => (_$data['is_event'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$match_id = match_id;
    result$data['match_id'] = l$match_id;
    final l$user_id = user_id;
    result$data['user_id'] = l$user_id;
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    return result$data;
  }

  CopyWith$Input$CancelWaitingSpotInput<Input$CancelWaitingSpotInput>
      get copyWith => CopyWith$Input$CancelWaitingSpotInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CancelWaitingSpotInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$is_event = is_event;
    return Object.hashAll([
      l$match_id,
      l$user_id,
      l$is_event,
    ]);
  }
}

abstract class CopyWith$Input$CancelWaitingSpotInput<TRes> {
  factory CopyWith$Input$CancelWaitingSpotInput(
    Input$CancelWaitingSpotInput instance,
    TRes Function(Input$CancelWaitingSpotInput) then,
  ) = _CopyWithImpl$Input$CancelWaitingSpotInput;

  factory CopyWith$Input$CancelWaitingSpotInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelWaitingSpotInput;

  TRes call({
    String? match_id,
    String? user_id,
    int? is_event,
  });
}

class _CopyWithImpl$Input$CancelWaitingSpotInput<TRes>
    implements CopyWith$Input$CancelWaitingSpotInput<TRes> {
  _CopyWithImpl$Input$CancelWaitingSpotInput(
    this._instance,
    this._then,
  );

  final Input$CancelWaitingSpotInput _instance;

  final TRes Function(Input$CancelWaitingSpotInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? is_event = _undefined,
  }) =>
      _then(Input$CancelWaitingSpotInput._({
        ..._instance._$data,
        if (match_id != _undefined && match_id != null)
          'match_id': (match_id as String),
        if (user_id != _undefined && user_id != null)
          'user_id': (user_id as String),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
      }));
}

class _CopyWithStubImpl$Input$CancelWaitingSpotInput<TRes>
    implements CopyWith$Input$CancelWaitingSpotInput<TRes> {
  _CopyWithStubImpl$Input$CancelWaitingSpotInput(this._res);

  TRes _res;

  call({
    String? match_id,
    String? user_id,
    int? is_event,
  }) =>
      _res;
}

class Input$TournamentBracketsListInput {
  factory Input$TournamentBracketsListInput({
    int? offset,
    int? limit,
    String? event_id,
    String? user_id,
  }) =>
      Input$TournamentBracketsListInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (event_id != null) r'event_id': event_id,
        if (user_id != null) r'user_id': user_id,
      });

  Input$TournamentBracketsListInput._(this._$data);

  factory Input$TournamentBracketsListInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('event_id')) {
      final l$event_id = data['event_id'];
      result$data['event_id'] = (l$event_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$TournamentBracketsListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get event_id => (_$data['event_id'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('event_id')) {
      final l$event_id = event_id;
      result$data['event_id'] = l$event_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$TournamentBracketsListInput<Input$TournamentBracketsListInput>
      get copyWith => CopyWith$Input$TournamentBracketsListInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TournamentBracketsListInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$event_id = event_id;
    final lOther$event_id = other.event_id;
    if (_$data.containsKey('event_id') !=
        other._$data.containsKey('event_id')) {
      return false;
    }
    if (l$event_id != lOther$event_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$event_id = event_id;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('event_id') ? l$event_id : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TournamentBracketsListInput<TRes> {
  factory CopyWith$Input$TournamentBracketsListInput(
    Input$TournamentBracketsListInput instance,
    TRes Function(Input$TournamentBracketsListInput) then,
  ) = _CopyWithImpl$Input$TournamentBracketsListInput;

  factory CopyWith$Input$TournamentBracketsListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TournamentBracketsListInput;

  TRes call({
    int? offset,
    int? limit,
    String? event_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$TournamentBracketsListInput<TRes>
    implements CopyWith$Input$TournamentBracketsListInput<TRes> {
  _CopyWithImpl$Input$TournamentBracketsListInput(
    this._instance,
    this._then,
  );

  final Input$TournamentBracketsListInput _instance;

  final TRes Function(Input$TournamentBracketsListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? event_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$TournamentBracketsListInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (event_id != _undefined) 'event_id': (event_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$TournamentBracketsListInput<TRes>
    implements CopyWith$Input$TournamentBracketsListInput<TRes> {
  _CopyWithStubImpl$Input$TournamentBracketsListInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? event_id,
    String? user_id,
  }) =>
      _res;
}

class Input$MoveToOtherEventInput {
  factory Input$MoveToOtherEventInput({
    String? from_event_id,
    String? to_event_id,
    String? user_id,
  }) =>
      Input$MoveToOtherEventInput._({
        if (from_event_id != null) r'from_event_id': from_event_id,
        if (to_event_id != null) r'to_event_id': to_event_id,
        if (user_id != null) r'user_id': user_id,
      });

  Input$MoveToOtherEventInput._(this._$data);

  factory Input$MoveToOtherEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('from_event_id')) {
      final l$from_event_id = data['from_event_id'];
      result$data['from_event_id'] = (l$from_event_id as String?);
    }
    if (data.containsKey('to_event_id')) {
      final l$to_event_id = data['to_event_id'];
      result$data['to_event_id'] = (l$to_event_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    return Input$MoveToOtherEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get from_event_id => (_$data['from_event_id'] as String?);

  String? get to_event_id => (_$data['to_event_id'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('from_event_id')) {
      final l$from_event_id = from_event_id;
      result$data['from_event_id'] = l$from_event_id;
    }
    if (_$data.containsKey('to_event_id')) {
      final l$to_event_id = to_event_id;
      result$data['to_event_id'] = l$to_event_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    return result$data;
  }

  CopyWith$Input$MoveToOtherEventInput<Input$MoveToOtherEventInput>
      get copyWith => CopyWith$Input$MoveToOtherEventInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MoveToOtherEventInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$from_event_id = from_event_id;
    final lOther$from_event_id = other.from_event_id;
    if (_$data.containsKey('from_event_id') !=
        other._$data.containsKey('from_event_id')) {
      return false;
    }
    if (l$from_event_id != lOther$from_event_id) {
      return false;
    }
    final l$to_event_id = to_event_id;
    final lOther$to_event_id = other.to_event_id;
    if (_$data.containsKey('to_event_id') !=
        other._$data.containsKey('to_event_id')) {
      return false;
    }
    if (l$to_event_id != lOther$to_event_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$from_event_id = from_event_id;
    final l$to_event_id = to_event_id;
    final l$user_id = user_id;
    return Object.hashAll([
      _$data.containsKey('from_event_id') ? l$from_event_id : const {},
      _$data.containsKey('to_event_id') ? l$to_event_id : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveToOtherEventInput<TRes> {
  factory CopyWith$Input$MoveToOtherEventInput(
    Input$MoveToOtherEventInput instance,
    TRes Function(Input$MoveToOtherEventInput) then,
  ) = _CopyWithImpl$Input$MoveToOtherEventInput;

  factory CopyWith$Input$MoveToOtherEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveToOtherEventInput;

  TRes call({
    String? from_event_id,
    String? to_event_id,
    String? user_id,
  });
}

class _CopyWithImpl$Input$MoveToOtherEventInput<TRes>
    implements CopyWith$Input$MoveToOtherEventInput<TRes> {
  _CopyWithImpl$Input$MoveToOtherEventInput(
    this._instance,
    this._then,
  );

  final Input$MoveToOtherEventInput _instance;

  final TRes Function(Input$MoveToOtherEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? from_event_id = _undefined,
    Object? to_event_id = _undefined,
    Object? user_id = _undefined,
  }) =>
      _then(Input$MoveToOtherEventInput._({
        ..._instance._$data,
        if (from_event_id != _undefined)
          'from_event_id': (from_event_id as String?),
        if (to_event_id != _undefined) 'to_event_id': (to_event_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
      }));
}

class _CopyWithStubImpl$Input$MoveToOtherEventInput<TRes>
    implements CopyWith$Input$MoveToOtherEventInput<TRes> {
  _CopyWithStubImpl$Input$MoveToOtherEventInput(this._res);

  TRes _res;

  call({
    String? from_event_id,
    String? to_event_id,
    String? user_id,
  }) =>
      _res;
}

class Input$CommonEventsInput {
  factory Input$CommonEventsInput({
    required int offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    List<String?>? event_creator,
    String? is_event,
    int? event_approved,
    int? gender,
  }) =>
      Input$CommonEventsInput._({
        r'offset': offset,
        if (limit != null) r'limit': limit,
        if (title != null) r'title': title,
        if (club_name != null) r'club_name': club_name,
        if (skill_level != null) r'skill_level': skill_level,
        if (status != null) r'status': status,
        if (locations != null) r'locations': locations,
        if (radius != null) r'radius': radius,
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (start_date != null) r'start_date': start_date,
        if (end_date != null) r'end_date': end_date,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
        if (event_creator != null) r'event_creator': event_creator,
        if (is_event != null) r'is_event': is_event,
        if (event_approved != null) r'event_approved': event_approved,
        if (gender != null) r'gender': gender,
      });

  Input$CommonEventsInput._(this._$data);

  factory Input$CommonEventsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$offset = data['offset'];
    result$data['offset'] = (l$offset as int);
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('club_name')) {
      final l$club_name = data['club_name'];
      result$data['club_name'] = (l$club_name as String?);
    }
    if (data.containsKey('skill_level')) {
      final l$skill_level = data['skill_level'];
      result$data['skill_level'] = (l$skill_level as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as String?);
    }
    if (data.containsKey('locations')) {
      final l$locations = data['locations'];
      result$data['locations'] = (l$locations as String?);
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as String?);
    }
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as String?);
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as String?);
    }
    if (data.containsKey('start_date')) {
      final l$start_date = data['start_date'];
      result$data['start_date'] = (l$start_date as String?);
    }
    if (data.containsKey('end_date')) {
      final l$end_date = data['end_date'];
      result$data['end_date'] = (l$end_date as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    if (data.containsKey('event_creator')) {
      final l$event_creator = data['event_creator'];
      result$data['event_creator'] = (l$event_creator as List<dynamic>?)
          ?.map((e) => (e as String?))
          .toList();
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as String?);
    }
    if (data.containsKey('event_approved')) {
      final l$event_approved = data['event_approved'];
      result$data['event_approved'] = (l$event_approved as int?);
    }
    if (data.containsKey('gender')) {
      final l$gender = data['gender'];
      result$data['gender'] = (l$gender as int?);
    }
    return Input$CommonEventsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get offset => (_$data['offset'] as int);

  int? get limit => (_$data['limit'] as int?);

  String? get title => (_$data['title'] as String?);

  String? get club_name => (_$data['club_name'] as String?);

  String? get skill_level => (_$data['skill_level'] as String?);

  String? get status => (_$data['status'] as String?);

  String? get locations => (_$data['locations'] as String?);

  String? get radius => (_$data['radius'] as String?);

  String? get latitude => (_$data['latitude'] as String?);

  String? get longitude => (_$data['longitude'] as String?);

  String? get start_date => (_$data['start_date'] as String?);

  String? get end_date => (_$data['end_date'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  List<String?>? get event_creator =>
      (_$data['event_creator'] as List<String?>?);

  String? get is_event => (_$data['is_event'] as String?);

  int? get event_approved => (_$data['event_approved'] as int?);

  int? get gender => (_$data['gender'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$offset = offset;
    result$data['offset'] = l$offset;
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('club_name')) {
      final l$club_name = club_name;
      result$data['club_name'] = l$club_name;
    }
    if (_$data.containsKey('skill_level')) {
      final l$skill_level = skill_level;
      result$data['skill_level'] = l$skill_level;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('locations')) {
      final l$locations = locations;
      result$data['locations'] = l$locations;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('start_date')) {
      final l$start_date = start_date;
      result$data['start_date'] = l$start_date;
    }
    if (_$data.containsKey('end_date')) {
      final l$end_date = end_date;
      result$data['end_date'] = l$end_date;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    if (_$data.containsKey('event_creator')) {
      final l$event_creator = event_creator;
      result$data['event_creator'] = l$event_creator?.map((e) => e).toList();
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('event_approved')) {
      final l$event_approved = event_approved;
      result$data['event_approved'] = l$event_approved;
    }
    if (_$data.containsKey('gender')) {
      final l$gender = gender;
      result$data['gender'] = l$gender;
    }
    return result$data;
  }

  CopyWith$Input$CommonEventsInput<Input$CommonEventsInput> get copyWith =>
      CopyWith$Input$CommonEventsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommonEventsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$club_name = club_name;
    final lOther$club_name = other.club_name;
    if (_$data.containsKey('club_name') !=
        other._$data.containsKey('club_name')) {
      return false;
    }
    if (l$club_name != lOther$club_name) {
      return false;
    }
    final l$skill_level = skill_level;
    final lOther$skill_level = other.skill_level;
    if (_$data.containsKey('skill_level') !=
        other._$data.containsKey('skill_level')) {
      return false;
    }
    if (l$skill_level != lOther$skill_level) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$locations = locations;
    final lOther$locations = other.locations;
    if (_$data.containsKey('locations') !=
        other._$data.containsKey('locations')) {
      return false;
    }
    if (l$locations != lOther$locations) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$start_date = start_date;
    final lOther$start_date = other.start_date;
    if (_$data.containsKey('start_date') !=
        other._$data.containsKey('start_date')) {
      return false;
    }
    if (l$start_date != lOther$start_date) {
      return false;
    }
    final l$end_date = end_date;
    final lOther$end_date = other.end_date;
    if (_$data.containsKey('end_date') !=
        other._$data.containsKey('end_date')) {
      return false;
    }
    if (l$end_date != lOther$end_date) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    final l$event_creator = event_creator;
    final lOther$event_creator = other.event_creator;
    if (_$data.containsKey('event_creator') !=
        other._$data.containsKey('event_creator')) {
      return false;
    }
    if (l$event_creator != null && lOther$event_creator != null) {
      if (l$event_creator.length != lOther$event_creator.length) {
        return false;
      }
      for (int i = 0; i < l$event_creator.length; i++) {
        final l$event_creator$entry = l$event_creator[i];
        final lOther$event_creator$entry = lOther$event_creator[i];
        if (l$event_creator$entry != lOther$event_creator$entry) {
          return false;
        }
      }
    } else if (l$event_creator != lOther$event_creator) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$event_approved = event_approved;
    final lOther$event_approved = other.event_approved;
    if (_$data.containsKey('event_approved') !=
        other._$data.containsKey('event_approved')) {
      return false;
    }
    if (l$event_approved != lOther$event_approved) {
      return false;
    }
    final l$gender = gender;
    final lOther$gender = other.gender;
    if (_$data.containsKey('gender') != other._$data.containsKey('gender')) {
      return false;
    }
    if (l$gender != lOther$gender) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$title = title;
    final l$club_name = club_name;
    final l$skill_level = skill_level;
    final l$status = status;
    final l$locations = locations;
    final l$radius = radius;
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$start_date = start_date;
    final l$end_date = end_date;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    final l$event_creator = event_creator;
    final l$is_event = is_event;
    final l$event_approved = event_approved;
    final l$gender = gender;
    return Object.hashAll([
      l$offset,
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('club_name') ? l$club_name : const {},
      _$data.containsKey('skill_level') ? l$skill_level : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('locations') ? l$locations : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('start_date') ? l$start_date : const {},
      _$data.containsKey('end_date') ? l$end_date : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
      _$data.containsKey('event_creator')
          ? l$event_creator == null
              ? null
              : Object.hashAll(l$event_creator.map((v) => v))
          : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('event_approved') ? l$event_approved : const {},
      _$data.containsKey('gender') ? l$gender : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommonEventsInput<TRes> {
  factory CopyWith$Input$CommonEventsInput(
    Input$CommonEventsInput instance,
    TRes Function(Input$CommonEventsInput) then,
  ) = _CopyWithImpl$Input$CommonEventsInput;

  factory CopyWith$Input$CommonEventsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommonEventsInput;

  TRes call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    List<String?>? event_creator,
    String? is_event,
    int? event_approved,
    int? gender,
  });
}

class _CopyWithImpl$Input$CommonEventsInput<TRes>
    implements CopyWith$Input$CommonEventsInput<TRes> {
  _CopyWithImpl$Input$CommonEventsInput(
    this._instance,
    this._then,
  );

  final Input$CommonEventsInput _instance;

  final TRes Function(Input$CommonEventsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? title = _undefined,
    Object? club_name = _undefined,
    Object? skill_level = _undefined,
    Object? status = _undefined,
    Object? locations = _undefined,
    Object? radius = _undefined,
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? start_date = _undefined,
    Object? end_date = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
    Object? event_creator = _undefined,
    Object? is_event = _undefined,
    Object? event_approved = _undefined,
    Object? gender = _undefined,
  }) =>
      _then(Input$CommonEventsInput._({
        ..._instance._$data,
        if (offset != _undefined && offset != null) 'offset': (offset as int),
        if (limit != _undefined) 'limit': (limit as int?),
        if (title != _undefined) 'title': (title as String?),
        if (club_name != _undefined) 'club_name': (club_name as String?),
        if (skill_level != _undefined) 'skill_level': (skill_level as String?),
        if (status != _undefined) 'status': (status as String?),
        if (locations != _undefined) 'locations': (locations as String?),
        if (radius != _undefined) 'radius': (radius as String?),
        if (latitude != _undefined) 'latitude': (latitude as String?),
        if (longitude != _undefined) 'longitude': (longitude as String?),
        if (start_date != _undefined) 'start_date': (start_date as String?),
        if (end_date != _undefined) 'end_date': (end_date as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
        if (event_creator != _undefined)
          'event_creator': (event_creator as List<String?>?),
        if (is_event != _undefined) 'is_event': (is_event as String?),
        if (event_approved != _undefined)
          'event_approved': (event_approved as int?),
        if (gender != _undefined) 'gender': (gender as int?),
      }));
}

class _CopyWithStubImpl$Input$CommonEventsInput<TRes>
    implements CopyWith$Input$CommonEventsInput<TRes> {
  _CopyWithStubImpl$Input$CommonEventsInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? title,
    String? club_name,
    String? skill_level,
    String? status,
    String? locations,
    String? radius,
    String? latitude,
    String? longitude,
    String? start_date,
    String? end_date,
    String? sort_column,
    String? sort_order,
    List<String?>? event_creator,
    String? is_event,
    int? event_approved,
    int? gender,
  }) =>
      _res;
}

class Input$viewCommonEventsAdminInput {
  factory Input$viewCommonEventsAdminInput({required String uuid}) =>
      Input$viewCommonEventsAdminInput._({
        r'uuid': uuid,
      });

  Input$viewCommonEventsAdminInput._(this._$data);

  factory Input$viewCommonEventsAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    return Input$viewCommonEventsAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    return result$data;
  }

  CopyWith$Input$viewCommonEventsAdminInput<Input$viewCommonEventsAdminInput>
      get copyWith => CopyWith$Input$viewCommonEventsAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$viewCommonEventsAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    return Object.hashAll([l$uuid]);
  }
}

abstract class CopyWith$Input$viewCommonEventsAdminInput<TRes> {
  factory CopyWith$Input$viewCommonEventsAdminInput(
    Input$viewCommonEventsAdminInput instance,
    TRes Function(Input$viewCommonEventsAdminInput) then,
  ) = _CopyWithImpl$Input$viewCommonEventsAdminInput;

  factory CopyWith$Input$viewCommonEventsAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$viewCommonEventsAdminInput;

  TRes call({String? uuid});
}

class _CopyWithImpl$Input$viewCommonEventsAdminInput<TRes>
    implements CopyWith$Input$viewCommonEventsAdminInput<TRes> {
  _CopyWithImpl$Input$viewCommonEventsAdminInput(
    this._instance,
    this._then,
  );

  final Input$viewCommonEventsAdminInput _instance;

  final TRes Function(Input$viewCommonEventsAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? uuid = _undefined}) =>
      _then(Input$viewCommonEventsAdminInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
      }));
}

class _CopyWithStubImpl$Input$viewCommonEventsAdminInput<TRes>
    implements CopyWith$Input$viewCommonEventsAdminInput<TRes> {
  _CopyWithStubImpl$Input$viewCommonEventsAdminInput(this._res);

  TRes _res;

  call({String? uuid}) => _res;
}

class Input$CommunityApproveInput {
  factory Input$CommunityApproveInput({
    required String uuid,
    int? status,
  }) =>
      Input$CommunityApproveInput._({
        r'uuid': uuid,
        if (status != null) r'status': status,
      });

  Input$CommunityApproveInput._(this._$data);

  factory Input$CommunityApproveInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as int?);
    }
    return Input$CommunityApproveInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  int? get status => (_$data['status'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    return result$data;
  }

  CopyWith$Input$CommunityApproveInput<Input$CommunityApproveInput>
      get copyWith => CopyWith$Input$CommunityApproveInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommunityApproveInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$status = status;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommunityApproveInput<TRes> {
  factory CopyWith$Input$CommunityApproveInput(
    Input$CommunityApproveInput instance,
    TRes Function(Input$CommunityApproveInput) then,
  ) = _CopyWithImpl$Input$CommunityApproveInput;

  factory CopyWith$Input$CommunityApproveInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommunityApproveInput;

  TRes call({
    String? uuid,
    int? status,
  });
}

class _CopyWithImpl$Input$CommunityApproveInput<TRes>
    implements CopyWith$Input$CommunityApproveInput<TRes> {
  _CopyWithImpl$Input$CommunityApproveInput(
    this._instance,
    this._then,
  );

  final Input$CommunityApproveInput _instance;

  final TRes Function(Input$CommunityApproveInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CommunityApproveInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (status != _undefined) 'status': (status as int?),
      }));
}

class _CopyWithStubImpl$Input$CommunityApproveInput<TRes>
    implements CopyWith$Input$CommunityApproveInput<TRes> {
  _CopyWithStubImpl$Input$CommunityApproveInput(this._res);

  TRes _res;

  call({
    String? uuid,
    int? status,
  }) =>
      _res;
}

class Input$UpdateCommunityPhotoInput {
  factory Input$UpdateCommunityPhotoInput({
    required String uuid,
    String? community_image,
  }) =>
      Input$UpdateCommunityPhotoInput._({
        r'uuid': uuid,
        if (community_image != null) r'community_image': community_image,
      });

  Input$UpdateCommunityPhotoInput._(this._$data);

  factory Input$UpdateCommunityPhotoInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$uuid = data['uuid'];
    result$data['uuid'] = (l$uuid as String);
    if (data.containsKey('community_image')) {
      final l$community_image = data['community_image'];
      result$data['community_image'] = (l$community_image as String?);
    }
    return Input$UpdateCommunityPhotoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get uuid => (_$data['uuid'] as String);

  String? get community_image => (_$data['community_image'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$uuid = uuid;
    result$data['uuid'] = l$uuid;
    if (_$data.containsKey('community_image')) {
      final l$community_image = community_image;
      result$data['community_image'] = l$community_image;
    }
    return result$data;
  }

  CopyWith$Input$UpdateCommunityPhotoInput<Input$UpdateCommunityPhotoInput>
      get copyWith => CopyWith$Input$UpdateCommunityPhotoInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCommunityPhotoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (l$uuid != lOther$uuid) {
      return false;
    }
    final l$community_image = community_image;
    final lOther$community_image = other.community_image;
    if (_$data.containsKey('community_image') !=
        other._$data.containsKey('community_image')) {
      return false;
    }
    if (l$community_image != lOther$community_image) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$uuid = uuid;
    final l$community_image = community_image;
    return Object.hashAll([
      l$uuid,
      _$data.containsKey('community_image') ? l$community_image : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateCommunityPhotoInput<TRes> {
  factory CopyWith$Input$UpdateCommunityPhotoInput(
    Input$UpdateCommunityPhotoInput instance,
    TRes Function(Input$UpdateCommunityPhotoInput) then,
  ) = _CopyWithImpl$Input$UpdateCommunityPhotoInput;

  factory CopyWith$Input$UpdateCommunityPhotoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCommunityPhotoInput;

  TRes call({
    String? uuid,
    String? community_image,
  });
}

class _CopyWithImpl$Input$UpdateCommunityPhotoInput<TRes>
    implements CopyWith$Input$UpdateCommunityPhotoInput<TRes> {
  _CopyWithImpl$Input$UpdateCommunityPhotoInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCommunityPhotoInput _instance;

  final TRes Function(Input$UpdateCommunityPhotoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? uuid = _undefined,
    Object? community_image = _undefined,
  }) =>
      _then(Input$UpdateCommunityPhotoInput._({
        ..._instance._$data,
        if (uuid != _undefined && uuid != null) 'uuid': (uuid as String),
        if (community_image != _undefined)
          'community_image': (community_image as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateCommunityPhotoInput<TRes>
    implements CopyWith$Input$UpdateCommunityPhotoInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCommunityPhotoInput(this._res);

  TRes _res;

  call({
    String? uuid,
    String? community_image,
  }) =>
      _res;
}

class Input$skipRatingInput {
  factory Input$skipRatingInput({
    String? match_uuid,
    String? user_uuid,
  }) =>
      Input$skipRatingInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$skipRatingInput._(this._$data);

  factory Input$skipRatingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$skipRatingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$skipRatingInput<Input$skipRatingInput> get copyWith =>
      CopyWith$Input$skipRatingInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$skipRatingInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$skipRatingInput<TRes> {
  factory CopyWith$Input$skipRatingInput(
    Input$skipRatingInput instance,
    TRes Function(Input$skipRatingInput) then,
  ) = _CopyWithImpl$Input$skipRatingInput;

  factory CopyWith$Input$skipRatingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$skipRatingInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$skipRatingInput<TRes>
    implements CopyWith$Input$skipRatingInput<TRes> {
  _CopyWithImpl$Input$skipRatingInput(
    this._instance,
    this._then,
  );

  final Input$skipRatingInput _instance;

  final TRes Function(Input$skipRatingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$skipRatingInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$skipRatingInput<TRes>
    implements CopyWith$Input$skipRatingInput<TRes> {
  _CopyWithStubImpl$Input$skipRatingInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
  }) =>
      _res;
}

class Input$homePageCountInput {
  factory Input$homePageCountInput({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
  }) =>
      Input$homePageCountInput._({
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
        if (rating != null) r'rating': rating,
      });

  Input$homePageCountInput._(this._$data);

  factory Input$homePageCountInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    if (data.containsKey('rating')) {
      final l$rating = data['rating'];
      result$data['rating'] = (l$rating as String?);
    }
    return Input$homePageCountInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  String? get rating => (_$data['rating'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    if (_$data.containsKey('rating')) {
      final l$rating = rating;
      result$data['rating'] = l$rating;
    }
    return result$data;
  }

  CopyWith$Input$homePageCountInput<Input$homePageCountInput> get copyWith =>
      CopyWith$Input$homePageCountInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$homePageCountInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    final l$rating = rating;
    final lOther$rating = other.rating;
    if (_$data.containsKey('rating') != other._$data.containsKey('rating')) {
      return false;
    }
    if (l$rating != lOther$rating) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    final l$rating = rating;
    return Object.hashAll([
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
      _$data.containsKey('rating') ? l$rating : const {},
    ]);
  }
}

abstract class CopyWith$Input$homePageCountInput<TRes> {
  factory CopyWith$Input$homePageCountInput(
    Input$homePageCountInput instance,
    TRes Function(Input$homePageCountInput) then,
  ) = _CopyWithImpl$Input$homePageCountInput;

  factory CopyWith$Input$homePageCountInput.stub(TRes res) =
      _CopyWithStubImpl$Input$homePageCountInput;

  TRes call({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
  });
}

class _CopyWithImpl$Input$homePageCountInput<TRes>
    implements CopyWith$Input$homePageCountInput<TRes> {
  _CopyWithImpl$Input$homePageCountInput(
    this._instance,
    this._then,
  );

  final Input$homePageCountInput _instance;

  final TRes Function(Input$homePageCountInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
    Object? rating = _undefined,
  }) =>
      _then(Input$homePageCountInput._({
        ..._instance._$data,
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
        if (rating != _undefined) 'rating': (rating as String?),
      }));
}

class _CopyWithStubImpl$Input$homePageCountInput<TRes>
    implements CopyWith$Input$homePageCountInput<TRes> {
  _CopyWithStubImpl$Input$homePageCountInput(this._res);

  TRes _res;

  call({
    double? latitude,
    double? longitude,
    int? radius,
    String? rating,
  }) =>
      _res;
}

class Input$homePageUserCountInput {
  factory Input$homePageUserCountInput({
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      Input$homePageUserCountInput._({
        if (latitude != null) r'latitude': latitude,
        if (longitude != null) r'longitude': longitude,
        if (radius != null) r'radius': radius,
      });

  Input$homePageUserCountInput._(this._$data);

  factory Input$homePageUserCountInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('latitude')) {
      final l$latitude = data['latitude'];
      result$data['latitude'] = (l$latitude as num?)?.toDouble();
    }
    if (data.containsKey('longitude')) {
      final l$longitude = data['longitude'];
      result$data['longitude'] = (l$longitude as num?)?.toDouble();
    }
    if (data.containsKey('radius')) {
      final l$radius = data['radius'];
      result$data['radius'] = (l$radius as int?);
    }
    return Input$homePageUserCountInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get latitude => (_$data['latitude'] as double?);

  double? get longitude => (_$data['longitude'] as double?);

  int? get radius => (_$data['radius'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('latitude')) {
      final l$latitude = latitude;
      result$data['latitude'] = l$latitude;
    }
    if (_$data.containsKey('longitude')) {
      final l$longitude = longitude;
      result$data['longitude'] = l$longitude;
    }
    if (_$data.containsKey('radius')) {
      final l$radius = radius;
      result$data['radius'] = l$radius;
    }
    return result$data;
  }

  CopyWith$Input$homePageUserCountInput<Input$homePageUserCountInput>
      get copyWith => CopyWith$Input$homePageUserCountInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$homePageUserCountInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$latitude = latitude;
    final lOther$latitude = other.latitude;
    if (_$data.containsKey('latitude') !=
        other._$data.containsKey('latitude')) {
      return false;
    }
    if (l$latitude != lOther$latitude) {
      return false;
    }
    final l$longitude = longitude;
    final lOther$longitude = other.longitude;
    if (_$data.containsKey('longitude') !=
        other._$data.containsKey('longitude')) {
      return false;
    }
    if (l$longitude != lOther$longitude) {
      return false;
    }
    final l$radius = radius;
    final lOther$radius = other.radius;
    if (_$data.containsKey('radius') != other._$data.containsKey('radius')) {
      return false;
    }
    if (l$radius != lOther$radius) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$latitude = latitude;
    final l$longitude = longitude;
    final l$radius = radius;
    return Object.hashAll([
      _$data.containsKey('latitude') ? l$latitude : const {},
      _$data.containsKey('longitude') ? l$longitude : const {},
      _$data.containsKey('radius') ? l$radius : const {},
    ]);
  }
}

abstract class CopyWith$Input$homePageUserCountInput<TRes> {
  factory CopyWith$Input$homePageUserCountInput(
    Input$homePageUserCountInput instance,
    TRes Function(Input$homePageUserCountInput) then,
  ) = _CopyWithImpl$Input$homePageUserCountInput;

  factory CopyWith$Input$homePageUserCountInput.stub(TRes res) =
      _CopyWithStubImpl$Input$homePageUserCountInput;

  TRes call({
    double? latitude,
    double? longitude,
    int? radius,
  });
}

class _CopyWithImpl$Input$homePageUserCountInput<TRes>
    implements CopyWith$Input$homePageUserCountInput<TRes> {
  _CopyWithImpl$Input$homePageUserCountInput(
    this._instance,
    this._then,
  );

  final Input$homePageUserCountInput _instance;

  final TRes Function(Input$homePageUserCountInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? latitude = _undefined,
    Object? longitude = _undefined,
    Object? radius = _undefined,
  }) =>
      _then(Input$homePageUserCountInput._({
        ..._instance._$data,
        if (latitude != _undefined) 'latitude': (latitude as double?),
        if (longitude != _undefined) 'longitude': (longitude as double?),
        if (radius != _undefined) 'radius': (radius as int?),
      }));
}

class _CopyWithStubImpl$Input$homePageUserCountInput<TRes>
    implements CopyWith$Input$homePageUserCountInput<TRes> {
  _CopyWithStubImpl$Input$homePageUserCountInput(this._res);

  TRes _res;

  call({
    double? latitude,
    double? longitude,
    int? radius,
  }) =>
      _res;
}

class Input$addPreferredPartnerInput {
  factory Input$addPreferredPartnerInput({
    String? match_uuid,
    String? preferred_user_uuid,
    int? is_tier,
    String? prefer_by_uuid,
  }) =>
      Input$addPreferredPartnerInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (preferred_user_uuid != null)
          r'preferred_user_uuid': preferred_user_uuid,
        if (is_tier != null) r'is_tier': is_tier,
        if (prefer_by_uuid != null) r'prefer_by_uuid': prefer_by_uuid,
      });

  Input$addPreferredPartnerInput._(this._$data);

  factory Input$addPreferredPartnerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('preferred_user_uuid')) {
      final l$preferred_user_uuid = data['preferred_user_uuid'];
      result$data['preferred_user_uuid'] = (l$preferred_user_uuid as String?);
    }
    if (data.containsKey('is_tier')) {
      final l$is_tier = data['is_tier'];
      result$data['is_tier'] = (l$is_tier as int?);
    }
    if (data.containsKey('prefer_by_uuid')) {
      final l$prefer_by_uuid = data['prefer_by_uuid'];
      result$data['prefer_by_uuid'] = (l$prefer_by_uuid as String?);
    }
    return Input$addPreferredPartnerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get preferred_user_uuid => (_$data['preferred_user_uuid'] as String?);

  int? get is_tier => (_$data['is_tier'] as int?);

  String? get prefer_by_uuid => (_$data['prefer_by_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('preferred_user_uuid')) {
      final l$preferred_user_uuid = preferred_user_uuid;
      result$data['preferred_user_uuid'] = l$preferred_user_uuid;
    }
    if (_$data.containsKey('is_tier')) {
      final l$is_tier = is_tier;
      result$data['is_tier'] = l$is_tier;
    }
    if (_$data.containsKey('prefer_by_uuid')) {
      final l$prefer_by_uuid = prefer_by_uuid;
      result$data['prefer_by_uuid'] = l$prefer_by_uuid;
    }
    return result$data;
  }

  CopyWith$Input$addPreferredPartnerInput<Input$addPreferredPartnerInput>
      get copyWith => CopyWith$Input$addPreferredPartnerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addPreferredPartnerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$preferred_user_uuid = preferred_user_uuid;
    final lOther$preferred_user_uuid = other.preferred_user_uuid;
    if (_$data.containsKey('preferred_user_uuid') !=
        other._$data.containsKey('preferred_user_uuid')) {
      return false;
    }
    if (l$preferred_user_uuid != lOther$preferred_user_uuid) {
      return false;
    }
    final l$is_tier = is_tier;
    final lOther$is_tier = other.is_tier;
    if (_$data.containsKey('is_tier') != other._$data.containsKey('is_tier')) {
      return false;
    }
    if (l$is_tier != lOther$is_tier) {
      return false;
    }
    final l$prefer_by_uuid = prefer_by_uuid;
    final lOther$prefer_by_uuid = other.prefer_by_uuid;
    if (_$data.containsKey('prefer_by_uuid') !=
        other._$data.containsKey('prefer_by_uuid')) {
      return false;
    }
    if (l$prefer_by_uuid != lOther$prefer_by_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$preferred_user_uuid = preferred_user_uuid;
    final l$is_tier = is_tier;
    final l$prefer_by_uuid = prefer_by_uuid;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('preferred_user_uuid')
          ? l$preferred_user_uuid
          : const {},
      _$data.containsKey('is_tier') ? l$is_tier : const {},
      _$data.containsKey('prefer_by_uuid') ? l$prefer_by_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$addPreferredPartnerInput<TRes> {
  factory CopyWith$Input$addPreferredPartnerInput(
    Input$addPreferredPartnerInput instance,
    TRes Function(Input$addPreferredPartnerInput) then,
  ) = _CopyWithImpl$Input$addPreferredPartnerInput;

  factory CopyWith$Input$addPreferredPartnerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$addPreferredPartnerInput;

  TRes call({
    String? match_uuid,
    String? preferred_user_uuid,
    int? is_tier,
    String? prefer_by_uuid,
  });
}

class _CopyWithImpl$Input$addPreferredPartnerInput<TRes>
    implements CopyWith$Input$addPreferredPartnerInput<TRes> {
  _CopyWithImpl$Input$addPreferredPartnerInput(
    this._instance,
    this._then,
  );

  final Input$addPreferredPartnerInput _instance;

  final TRes Function(Input$addPreferredPartnerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? preferred_user_uuid = _undefined,
    Object? is_tier = _undefined,
    Object? prefer_by_uuid = _undefined,
  }) =>
      _then(Input$addPreferredPartnerInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (preferred_user_uuid != _undefined)
          'preferred_user_uuid': (preferred_user_uuid as String?),
        if (is_tier != _undefined) 'is_tier': (is_tier as int?),
        if (prefer_by_uuid != _undefined)
          'prefer_by_uuid': (prefer_by_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$addPreferredPartnerInput<TRes>
    implements CopyWith$Input$addPreferredPartnerInput<TRes> {
  _CopyWithStubImpl$Input$addPreferredPartnerInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? preferred_user_uuid,
    int? is_tier,
    String? prefer_by_uuid,
  }) =>
      _res;
}

class Input$addPaymentPreferPartnerInput {
  factory Input$addPaymentPreferPartnerInput({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    required int is_event,
    String? tier_description,
    String? prefer_partner_id,
  }) =>
      Input$addPaymentPreferPartnerInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (cost_per_player != null) r'cost_per_player': cost_per_player,
        if (transaction_fee != null) r'transaction_fee': transaction_fee,
        if (admin_fee != null) r'admin_fee': admin_fee,
        if (total != null) r'total': total,
        r'is_event': is_event,
        if (tier_description != null) r'tier_description': tier_description,
        if (prefer_partner_id != null) r'prefer_partner_id': prefer_partner_id,
      });

  Input$addPaymentPreferPartnerInput._(this._$data);

  factory Input$addPaymentPreferPartnerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('cost_per_player')) {
      final l$cost_per_player = data['cost_per_player'];
      result$data['cost_per_player'] = (l$cost_per_player as String?);
    }
    if (data.containsKey('transaction_fee')) {
      final l$transaction_fee = data['transaction_fee'];
      result$data['transaction_fee'] = (l$transaction_fee as String?);
    }
    if (data.containsKey('admin_fee')) {
      final l$admin_fee = data['admin_fee'];
      result$data['admin_fee'] = (l$admin_fee as String?);
    }
    if (data.containsKey('total')) {
      final l$total = data['total'];
      result$data['total'] = (l$total as String?);
    }
    final l$is_event = data['is_event'];
    result$data['is_event'] = (l$is_event as int);
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    if (data.containsKey('prefer_partner_id')) {
      final l$prefer_partner_id = data['prefer_partner_id'];
      result$data['prefer_partner_id'] = (l$prefer_partner_id as String?);
    }
    return Input$addPaymentPreferPartnerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get cost_per_player => (_$data['cost_per_player'] as String?);

  String? get transaction_fee => (_$data['transaction_fee'] as String?);

  String? get admin_fee => (_$data['admin_fee'] as String?);

  String? get total => (_$data['total'] as String?);

  int get is_event => (_$data['is_event'] as int);

  String? get tier_description => (_$data['tier_description'] as String?);

  String? get prefer_partner_id => (_$data['prefer_partner_id'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('cost_per_player')) {
      final l$cost_per_player = cost_per_player;
      result$data['cost_per_player'] = l$cost_per_player;
    }
    if (_$data.containsKey('transaction_fee')) {
      final l$transaction_fee = transaction_fee;
      result$data['transaction_fee'] = l$transaction_fee;
    }
    if (_$data.containsKey('admin_fee')) {
      final l$admin_fee = admin_fee;
      result$data['admin_fee'] = l$admin_fee;
    }
    if (_$data.containsKey('total')) {
      final l$total = total;
      result$data['total'] = l$total;
    }
    final l$is_event = is_event;
    result$data['is_event'] = l$is_event;
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    if (_$data.containsKey('prefer_partner_id')) {
      final l$prefer_partner_id = prefer_partner_id;
      result$data['prefer_partner_id'] = l$prefer_partner_id;
    }
    return result$data;
  }

  CopyWith$Input$addPaymentPreferPartnerInput<
          Input$addPaymentPreferPartnerInput>
      get copyWith => CopyWith$Input$addPaymentPreferPartnerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$addPaymentPreferPartnerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$cost_per_player = cost_per_player;
    final lOther$cost_per_player = other.cost_per_player;
    if (_$data.containsKey('cost_per_player') !=
        other._$data.containsKey('cost_per_player')) {
      return false;
    }
    if (l$cost_per_player != lOther$cost_per_player) {
      return false;
    }
    final l$transaction_fee = transaction_fee;
    final lOther$transaction_fee = other.transaction_fee;
    if (_$data.containsKey('transaction_fee') !=
        other._$data.containsKey('transaction_fee')) {
      return false;
    }
    if (l$transaction_fee != lOther$transaction_fee) {
      return false;
    }
    final l$admin_fee = admin_fee;
    final lOther$admin_fee = other.admin_fee;
    if (_$data.containsKey('admin_fee') !=
        other._$data.containsKey('admin_fee')) {
      return false;
    }
    if (l$admin_fee != lOther$admin_fee) {
      return false;
    }
    final l$total = total;
    final lOther$total = other.total;
    if (_$data.containsKey('total') != other._$data.containsKey('total')) {
      return false;
    }
    if (l$total != lOther$total) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    final l$prefer_partner_id = prefer_partner_id;
    final lOther$prefer_partner_id = other.prefer_partner_id;
    if (_$data.containsKey('prefer_partner_id') !=
        other._$data.containsKey('prefer_partner_id')) {
      return false;
    }
    if (l$prefer_partner_id != lOther$prefer_partner_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$cost_per_player = cost_per_player;
    final l$transaction_fee = transaction_fee;
    final l$admin_fee = admin_fee;
    final l$total = total;
    final l$is_event = is_event;
    final l$tier_description = tier_description;
    final l$prefer_partner_id = prefer_partner_id;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('cost_per_player') ? l$cost_per_player : const {},
      _$data.containsKey('transaction_fee') ? l$transaction_fee : const {},
      _$data.containsKey('admin_fee') ? l$admin_fee : const {},
      _$data.containsKey('total') ? l$total : const {},
      l$is_event,
      _$data.containsKey('tier_description') ? l$tier_description : const {},
      _$data.containsKey('prefer_partner_id') ? l$prefer_partner_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$addPaymentPreferPartnerInput<TRes> {
  factory CopyWith$Input$addPaymentPreferPartnerInput(
    Input$addPaymentPreferPartnerInput instance,
    TRes Function(Input$addPaymentPreferPartnerInput) then,
  ) = _CopyWithImpl$Input$addPaymentPreferPartnerInput;

  factory CopyWith$Input$addPaymentPreferPartnerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$addPaymentPreferPartnerInput;

  TRes call({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    int? is_event,
    String? tier_description,
    String? prefer_partner_id,
  });
}

class _CopyWithImpl$Input$addPaymentPreferPartnerInput<TRes>
    implements CopyWith$Input$addPaymentPreferPartnerInput<TRes> {
  _CopyWithImpl$Input$addPaymentPreferPartnerInput(
    this._instance,
    this._then,
  );

  final Input$addPaymentPreferPartnerInput _instance;

  final TRes Function(Input$addPaymentPreferPartnerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? cost_per_player = _undefined,
    Object? transaction_fee = _undefined,
    Object? admin_fee = _undefined,
    Object? total = _undefined,
    Object? is_event = _undefined,
    Object? tier_description = _undefined,
    Object? prefer_partner_id = _undefined,
  }) =>
      _then(Input$addPaymentPreferPartnerInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (cost_per_player != _undefined)
          'cost_per_player': (cost_per_player as String?),
        if (transaction_fee != _undefined)
          'transaction_fee': (transaction_fee as String?),
        if (admin_fee != _undefined) 'admin_fee': (admin_fee as String?),
        if (total != _undefined) 'total': (total as String?),
        if (is_event != _undefined && is_event != null)
          'is_event': (is_event as int),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
        if (prefer_partner_id != _undefined)
          'prefer_partner_id': (prefer_partner_id as String?),
      }));
}

class _CopyWithStubImpl$Input$addPaymentPreferPartnerInput<TRes>
    implements CopyWith$Input$addPaymentPreferPartnerInput<TRes> {
  _CopyWithStubImpl$Input$addPaymentPreferPartnerInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? cost_per_player,
    String? transaction_fee,
    String? admin_fee,
    String? total,
    int? is_event,
    String? tier_description,
    String? prefer_partner_id,
  }) =>
      _res;
}

class Input$inviteFreeLessonAcceptInput {
  factory Input$inviteFreeLessonAcceptInput({
    String? match_uuid,
    String? user_uuid,
  }) =>
      Input$inviteFreeLessonAcceptInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$inviteFreeLessonAcceptInput._(this._$data);

  factory Input$inviteFreeLessonAcceptInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$inviteFreeLessonAcceptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$inviteFreeLessonAcceptInput<Input$inviteFreeLessonAcceptInput>
      get copyWith => CopyWith$Input$inviteFreeLessonAcceptInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$inviteFreeLessonAcceptInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$inviteFreeLessonAcceptInput<TRes> {
  factory CopyWith$Input$inviteFreeLessonAcceptInput(
    Input$inviteFreeLessonAcceptInput instance,
    TRes Function(Input$inviteFreeLessonAcceptInput) then,
  ) = _CopyWithImpl$Input$inviteFreeLessonAcceptInput;

  factory CopyWith$Input$inviteFreeLessonAcceptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$inviteFreeLessonAcceptInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$inviteFreeLessonAcceptInput<TRes>
    implements CopyWith$Input$inviteFreeLessonAcceptInput<TRes> {
  _CopyWithImpl$Input$inviteFreeLessonAcceptInput(
    this._instance,
    this._then,
  );

  final Input$inviteFreeLessonAcceptInput _instance;

  final TRes Function(Input$inviteFreeLessonAcceptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$inviteFreeLessonAcceptInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$inviteFreeLessonAcceptInput<TRes>
    implements CopyWith$Input$inviteFreeLessonAcceptInput<TRes> {
  _CopyWithStubImpl$Input$inviteFreeLessonAcceptInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
  }) =>
      _res;
}

class Input$joinCommonEventInput {
  factory Input$joinCommonEventInput({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
    int? tier_price,
    String? tier_description,
  }) =>
      Input$joinCommonEventInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
        if (is_event != null) r'is_event': is_event,
        if (tier_price != null) r'tier_price': tier_price,
        if (tier_description != null) r'tier_description': tier_description,
      });

  Input$joinCommonEventInput._(this._$data);

  factory Input$joinCommonEventInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    if (data.containsKey('is_event')) {
      final l$is_event = data['is_event'];
      result$data['is_event'] = (l$is_event as int?);
    }
    if (data.containsKey('tier_price')) {
      final l$tier_price = data['tier_price'];
      result$data['tier_price'] = (l$tier_price as int?);
    }
    if (data.containsKey('tier_description')) {
      final l$tier_description = data['tier_description'];
      result$data['tier_description'] = (l$tier_description as String?);
    }
    return Input$joinCommonEventInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  int? get is_event => (_$data['is_event'] as int?);

  int? get tier_price => (_$data['tier_price'] as int?);

  String? get tier_description => (_$data['tier_description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    if (_$data.containsKey('is_event')) {
      final l$is_event = is_event;
      result$data['is_event'] = l$is_event;
    }
    if (_$data.containsKey('tier_price')) {
      final l$tier_price = tier_price;
      result$data['tier_price'] = l$tier_price;
    }
    if (_$data.containsKey('tier_description')) {
      final l$tier_description = tier_description;
      result$data['tier_description'] = l$tier_description;
    }
    return result$data;
  }

  CopyWith$Input$joinCommonEventInput<Input$joinCommonEventInput>
      get copyWith => CopyWith$Input$joinCommonEventInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$joinCommonEventInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    final l$is_event = is_event;
    final lOther$is_event = other.is_event;
    if (_$data.containsKey('is_event') !=
        other._$data.containsKey('is_event')) {
      return false;
    }
    if (l$is_event != lOther$is_event) {
      return false;
    }
    final l$tier_price = tier_price;
    final lOther$tier_price = other.tier_price;
    if (_$data.containsKey('tier_price') !=
        other._$data.containsKey('tier_price')) {
      return false;
    }
    if (l$tier_price != lOther$tier_price) {
      return false;
    }
    final l$tier_description = tier_description;
    final lOther$tier_description = other.tier_description;
    if (_$data.containsKey('tier_description') !=
        other._$data.containsKey('tier_description')) {
      return false;
    }
    if (l$tier_description != lOther$tier_description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    final l$is_event = is_event;
    final l$tier_price = tier_price;
    final l$tier_description = tier_description;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
      _$data.containsKey('is_event') ? l$is_event : const {},
      _$data.containsKey('tier_price') ? l$tier_price : const {},
      _$data.containsKey('tier_description') ? l$tier_description : const {},
    ]);
  }
}

abstract class CopyWith$Input$joinCommonEventInput<TRes> {
  factory CopyWith$Input$joinCommonEventInput(
    Input$joinCommonEventInput instance,
    TRes Function(Input$joinCommonEventInput) then,
  ) = _CopyWithImpl$Input$joinCommonEventInput;

  factory CopyWith$Input$joinCommonEventInput.stub(TRes res) =
      _CopyWithStubImpl$Input$joinCommonEventInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
    int? tier_price,
    String? tier_description,
  });
}

class _CopyWithImpl$Input$joinCommonEventInput<TRes>
    implements CopyWith$Input$joinCommonEventInput<TRes> {
  _CopyWithImpl$Input$joinCommonEventInput(
    this._instance,
    this._then,
  );

  final Input$joinCommonEventInput _instance;

  final TRes Function(Input$joinCommonEventInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
    Object? is_event = _undefined,
    Object? tier_price = _undefined,
    Object? tier_description = _undefined,
  }) =>
      _then(Input$joinCommonEventInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
        if (is_event != _undefined) 'is_event': (is_event as int?),
        if (tier_price != _undefined) 'tier_price': (tier_price as int?),
        if (tier_description != _undefined)
          'tier_description': (tier_description as String?),
      }));
}

class _CopyWithStubImpl$Input$joinCommonEventInput<TRes>
    implements CopyWith$Input$joinCommonEventInput<TRes> {
  _CopyWithStubImpl$Input$joinCommonEventInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
    int? is_event,
    int? tier_price,
    String? tier_description,
  }) =>
      _res;
}

class Input$matchPaymentLedgerInput {
  factory Input$matchPaymentLedgerInput({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  }) =>
      Input$matchPaymentLedgerInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (match_id != null) r'match_id': match_id,
        if (sort_column != null) r'sort_column': sort_column,
        if (sort_order != null) r'sort_order': sort_order,
      });

  Input$matchPaymentLedgerInput._(this._$data);

  factory Input$matchPaymentLedgerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('sort_column')) {
      final l$sort_column = data['sort_column'];
      result$data['sort_column'] = (l$sort_column as String?);
    }
    if (data.containsKey('sort_order')) {
      final l$sort_order = data['sort_order'];
      result$data['sort_order'] = (l$sort_order as String?);
    }
    return Input$matchPaymentLedgerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get sort_column => (_$data['sort_column'] as String?);

  String? get sort_order => (_$data['sort_order'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('sort_column')) {
      final l$sort_column = sort_column;
      result$data['sort_column'] = l$sort_column;
    }
    if (_$data.containsKey('sort_order')) {
      final l$sort_order = sort_order;
      result$data['sort_order'] = l$sort_order;
    }
    return result$data;
  }

  CopyWith$Input$matchPaymentLedgerInput<Input$matchPaymentLedgerInput>
      get copyWith => CopyWith$Input$matchPaymentLedgerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$matchPaymentLedgerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$sort_column = sort_column;
    final lOther$sort_column = other.sort_column;
    if (_$data.containsKey('sort_column') !=
        other._$data.containsKey('sort_column')) {
      return false;
    }
    if (l$sort_column != lOther$sort_column) {
      return false;
    }
    final l$sort_order = sort_order;
    final lOther$sort_order = other.sort_order;
    if (_$data.containsKey('sort_order') !=
        other._$data.containsKey('sort_order')) {
      return false;
    }
    if (l$sort_order != lOther$sort_order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$match_id = match_id;
    final l$sort_column = sort_column;
    final l$sort_order = sort_order;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('sort_column') ? l$sort_column : const {},
      _$data.containsKey('sort_order') ? l$sort_order : const {},
    ]);
  }
}

abstract class CopyWith$Input$matchPaymentLedgerInput<TRes> {
  factory CopyWith$Input$matchPaymentLedgerInput(
    Input$matchPaymentLedgerInput instance,
    TRes Function(Input$matchPaymentLedgerInput) then,
  ) = _CopyWithImpl$Input$matchPaymentLedgerInput;

  factory CopyWith$Input$matchPaymentLedgerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$matchPaymentLedgerInput;

  TRes call({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  });
}

class _CopyWithImpl$Input$matchPaymentLedgerInput<TRes>
    implements CopyWith$Input$matchPaymentLedgerInput<TRes> {
  _CopyWithImpl$Input$matchPaymentLedgerInput(
    this._instance,
    this._then,
  );

  final Input$matchPaymentLedgerInput _instance;

  final TRes Function(Input$matchPaymentLedgerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? match_id = _undefined,
    Object? sort_column = _undefined,
    Object? sort_order = _undefined,
  }) =>
      _then(Input$matchPaymentLedgerInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (sort_column != _undefined) 'sort_column': (sort_column as String?),
        if (sort_order != _undefined) 'sort_order': (sort_order as String?),
      }));
}

class _CopyWithStubImpl$Input$matchPaymentLedgerInput<TRes>
    implements CopyWith$Input$matchPaymentLedgerInput<TRes> {
  _CopyWithStubImpl$Input$matchPaymentLedgerInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? match_id,
    String? sort_column,
    String? sort_order,
  }) =>
      _res;
}

class Input$inviteAcceptSlotCheckInput {
  factory Input$inviteAcceptSlotCheckInput({
    String? match_uuid,
    String? user_uuid,
  }) =>
      Input$inviteAcceptSlotCheckInput._({
        if (match_uuid != null) r'match_uuid': match_uuid,
        if (user_uuid != null) r'user_uuid': user_uuid,
      });

  Input$inviteAcceptSlotCheckInput._(this._$data);

  factory Input$inviteAcceptSlotCheckInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('match_uuid')) {
      final l$match_uuid = data['match_uuid'];
      result$data['match_uuid'] = (l$match_uuid as String?);
    }
    if (data.containsKey('user_uuid')) {
      final l$user_uuid = data['user_uuid'];
      result$data['user_uuid'] = (l$user_uuid as String?);
    }
    return Input$inviteAcceptSlotCheckInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get match_uuid => (_$data['match_uuid'] as String?);

  String? get user_uuid => (_$data['user_uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('match_uuid')) {
      final l$match_uuid = match_uuid;
      result$data['match_uuid'] = l$match_uuid;
    }
    if (_$data.containsKey('user_uuid')) {
      final l$user_uuid = user_uuid;
      result$data['user_uuid'] = l$user_uuid;
    }
    return result$data;
  }

  CopyWith$Input$inviteAcceptSlotCheckInput<Input$inviteAcceptSlotCheckInput>
      get copyWith => CopyWith$Input$inviteAcceptSlotCheckInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$inviteAcceptSlotCheckInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$match_uuid = match_uuid;
    final lOther$match_uuid = other.match_uuid;
    if (_$data.containsKey('match_uuid') !=
        other._$data.containsKey('match_uuid')) {
      return false;
    }
    if (l$match_uuid != lOther$match_uuid) {
      return false;
    }
    final l$user_uuid = user_uuid;
    final lOther$user_uuid = other.user_uuid;
    if (_$data.containsKey('user_uuid') !=
        other._$data.containsKey('user_uuid')) {
      return false;
    }
    if (l$user_uuid != lOther$user_uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$match_uuid = match_uuid;
    final l$user_uuid = user_uuid;
    return Object.hashAll([
      _$data.containsKey('match_uuid') ? l$match_uuid : const {},
      _$data.containsKey('user_uuid') ? l$user_uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$inviteAcceptSlotCheckInput<TRes> {
  factory CopyWith$Input$inviteAcceptSlotCheckInput(
    Input$inviteAcceptSlotCheckInput instance,
    TRes Function(Input$inviteAcceptSlotCheckInput) then,
  ) = _CopyWithImpl$Input$inviteAcceptSlotCheckInput;

  factory CopyWith$Input$inviteAcceptSlotCheckInput.stub(TRes res) =
      _CopyWithStubImpl$Input$inviteAcceptSlotCheckInput;

  TRes call({
    String? match_uuid,
    String? user_uuid,
  });
}

class _CopyWithImpl$Input$inviteAcceptSlotCheckInput<TRes>
    implements CopyWith$Input$inviteAcceptSlotCheckInput<TRes> {
  _CopyWithImpl$Input$inviteAcceptSlotCheckInput(
    this._instance,
    this._then,
  );

  final Input$inviteAcceptSlotCheckInput _instance;

  final TRes Function(Input$inviteAcceptSlotCheckInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? match_uuid = _undefined,
    Object? user_uuid = _undefined,
  }) =>
      _then(Input$inviteAcceptSlotCheckInput._({
        ..._instance._$data,
        if (match_uuid != _undefined) 'match_uuid': (match_uuid as String?),
        if (user_uuid != _undefined) 'user_uuid': (user_uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$inviteAcceptSlotCheckInput<TRes>
    implements CopyWith$Input$inviteAcceptSlotCheckInput<TRes> {
  _CopyWithStubImpl$Input$inviteAcceptSlotCheckInput(this._res);

  TRes _res;

  call({
    String? match_uuid,
    String? user_uuid,
  }) =>
      _res;
}

class Input$EventConfirmPlayerInput {
  factory Input$EventConfirmPlayerInput({
    int? offset,
    int? limit,
    String? match_id,
    String? user_id,
    String? name,
  }) =>
      Input$EventConfirmPlayerInput._({
        if (offset != null) r'offset': offset,
        if (limit != null) r'limit': limit,
        if (match_id != null) r'match_id': match_id,
        if (user_id != null) r'user_id': user_id,
        if (name != null) r'name': name,
      });

  Input$EventConfirmPlayerInput._(this._$data);

  factory Input$EventConfirmPlayerInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('offset')) {
      final l$offset = data['offset'];
      result$data['offset'] = (l$offset as int?);
    }
    if (data.containsKey('limit')) {
      final l$limit = data['limit'];
      result$data['limit'] = (l$limit as int?);
    }
    if (data.containsKey('match_id')) {
      final l$match_id = data['match_id'];
      result$data['match_id'] = (l$match_id as String?);
    }
    if (data.containsKey('user_id')) {
      final l$user_id = data['user_id'];
      result$data['user_id'] = (l$user_id as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$EventConfirmPlayerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get offset => (_$data['offset'] as int?);

  int? get limit => (_$data['limit'] as int?);

  String? get match_id => (_$data['match_id'] as String?);

  String? get user_id => (_$data['user_id'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('offset')) {
      final l$offset = offset;
      result$data['offset'] = l$offset;
    }
    if (_$data.containsKey('limit')) {
      final l$limit = limit;
      result$data['limit'] = l$limit;
    }
    if (_$data.containsKey('match_id')) {
      final l$match_id = match_id;
      result$data['match_id'] = l$match_id;
    }
    if (_$data.containsKey('user_id')) {
      final l$user_id = user_id;
      result$data['user_id'] = l$user_id;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$EventConfirmPlayerInput<Input$EventConfirmPlayerInput>
      get copyWith => CopyWith$Input$EventConfirmPlayerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EventConfirmPlayerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$offset = offset;
    final lOther$offset = other.offset;
    if (_$data.containsKey('offset') != other._$data.containsKey('offset')) {
      return false;
    }
    if (l$offset != lOther$offset) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (_$data.containsKey('limit') != other._$data.containsKey('limit')) {
      return false;
    }
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$match_id = match_id;
    final lOther$match_id = other.match_id;
    if (_$data.containsKey('match_id') !=
        other._$data.containsKey('match_id')) {
      return false;
    }
    if (l$match_id != lOther$match_id) {
      return false;
    }
    final l$user_id = user_id;
    final lOther$user_id = other.user_id;
    if (_$data.containsKey('user_id') != other._$data.containsKey('user_id')) {
      return false;
    }
    if (l$user_id != lOther$user_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$offset = offset;
    final l$limit = limit;
    final l$match_id = match_id;
    final l$user_id = user_id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('offset') ? l$offset : const {},
      _$data.containsKey('limit') ? l$limit : const {},
      _$data.containsKey('match_id') ? l$match_id : const {},
      _$data.containsKey('user_id') ? l$user_id : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$EventConfirmPlayerInput<TRes> {
  factory CopyWith$Input$EventConfirmPlayerInput(
    Input$EventConfirmPlayerInput instance,
    TRes Function(Input$EventConfirmPlayerInput) then,
  ) = _CopyWithImpl$Input$EventConfirmPlayerInput;

  factory CopyWith$Input$EventConfirmPlayerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EventConfirmPlayerInput;

  TRes call({
    int? offset,
    int? limit,
    String? match_id,
    String? user_id,
    String? name,
  });
}

class _CopyWithImpl$Input$EventConfirmPlayerInput<TRes>
    implements CopyWith$Input$EventConfirmPlayerInput<TRes> {
  _CopyWithImpl$Input$EventConfirmPlayerInput(
    this._instance,
    this._then,
  );

  final Input$EventConfirmPlayerInput _instance;

  final TRes Function(Input$EventConfirmPlayerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? offset = _undefined,
    Object? limit = _undefined,
    Object? match_id = _undefined,
    Object? user_id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$EventConfirmPlayerInput._({
        ..._instance._$data,
        if (offset != _undefined) 'offset': (offset as int?),
        if (limit != _undefined) 'limit': (limit as int?),
        if (match_id != _undefined) 'match_id': (match_id as String?),
        if (user_id != _undefined) 'user_id': (user_id as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$EventConfirmPlayerInput<TRes>
    implements CopyWith$Input$EventConfirmPlayerInput<TRes> {
  _CopyWithStubImpl$Input$EventConfirmPlayerInput(this._res);

  TRes _res;

  call({
    int? offset,
    int? limit,
    String? match_id,
    String? user_id,
    String? name,
  }) =>
      _res;
}

class Input$LoginInput {
  factory Input$LoginInput({
    required String username,
    required String password,
  }) =>
      Input$LoginInput._({
        r'username': username,
        r'password': password,
      });

  Input$LoginInput._(this._$data);

  factory Input$LoginInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$username = data['username'];
    result$data['username'] = (l$username as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$LoginInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get username => (_$data['username'] as String);

  String get password => (_$data['password'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$username = username;
    result$data['username'] = l$username;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$LoginInput<Input$LoginInput> get copyWith =>
      CopyWith$Input$LoginInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LoginInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$username = username;
    final lOther$username = other.username;
    if (l$username != lOther$username) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$username = username;
    final l$password = password;
    return Object.hashAll([
      l$username,
      l$password,
    ]);
  }
}

abstract class CopyWith$Input$LoginInput<TRes> {
  factory CopyWith$Input$LoginInput(
    Input$LoginInput instance,
    TRes Function(Input$LoginInput) then,
  ) = _CopyWithImpl$Input$LoginInput;

  factory CopyWith$Input$LoginInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LoginInput;

  TRes call({
    String? username,
    String? password,
  });
}

class _CopyWithImpl$Input$LoginInput<TRes>
    implements CopyWith$Input$LoginInput<TRes> {
  _CopyWithImpl$Input$LoginInput(
    this._instance,
    this._then,
  );

  final Input$LoginInput _instance;

  final TRes Function(Input$LoginInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? username = _undefined,
    Object? password = _undefined,
  }) =>
      _then(Input$LoginInput._({
        ..._instance._$data,
        if (username != _undefined && username != null)
          'username': (username as String),
        if (password != _undefined && password != null)
          'password': (password as String),
      }));
}

class _CopyWithStubImpl$Input$LoginInput<TRes>
    implements CopyWith$Input$LoginInput<TRes> {
  _CopyWithStubImpl$Input$LoginInput(this._res);

  TRes _res;

  call({
    String? username,
    String? password,
  }) =>
      _res;
}

class Input$RefreshTokenInput {
  factory Input$RefreshTokenInput({String? refresh_token}) =>
      Input$RefreshTokenInput._({
        if (refresh_token != null) r'refresh_token': refresh_token,
      });

  Input$RefreshTokenInput._(this._$data);

  factory Input$RefreshTokenInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refresh_token')) {
      final l$refresh_token = data['refresh_token'];
      result$data['refresh_token'] = (l$refresh_token as String?);
    }
    return Input$RefreshTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get refresh_token => (_$data['refresh_token'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refresh_token')) {
      final l$refresh_token = refresh_token;
      result$data['refresh_token'] = l$refresh_token;
    }
    return result$data;
  }

  CopyWith$Input$RefreshTokenInput<Input$RefreshTokenInput> get copyWith =>
      CopyWith$Input$RefreshTokenInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RefreshTokenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refresh_token = refresh_token;
    final lOther$refresh_token = other.refresh_token;
    if (_$data.containsKey('refresh_token') !=
        other._$data.containsKey('refresh_token')) {
      return false;
    }
    if (l$refresh_token != lOther$refresh_token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refresh_token = refresh_token;
    return Object.hashAll(
        [_$data.containsKey('refresh_token') ? l$refresh_token : const {}]);
  }
}

abstract class CopyWith$Input$RefreshTokenInput<TRes> {
  factory CopyWith$Input$RefreshTokenInput(
    Input$RefreshTokenInput instance,
    TRes Function(Input$RefreshTokenInput) then,
  ) = _CopyWithImpl$Input$RefreshTokenInput;

  factory CopyWith$Input$RefreshTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RefreshTokenInput;

  TRes call({String? refresh_token});
}

class _CopyWithImpl$Input$RefreshTokenInput<TRes>
    implements CopyWith$Input$RefreshTokenInput<TRes> {
  _CopyWithImpl$Input$RefreshTokenInput(
    this._instance,
    this._then,
  );

  final Input$RefreshTokenInput _instance;

  final TRes Function(Input$RefreshTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? refresh_token = _undefined}) =>
      _then(Input$RefreshTokenInput._({
        ..._instance._$data,
        if (refresh_token != _undefined)
          'refresh_token': (refresh_token as String?),
      }));
}

class _CopyWithStubImpl$Input$RefreshTokenInput<TRes>
    implements CopyWith$Input$RefreshTokenInput<TRes> {
  _CopyWithStubImpl$Input$RefreshTokenInput(this._res);

  TRes _res;

  call({String? refresh_token}) => _res;
}

class Input$NewPasswordWithCodeInput {
  factory Input$NewPasswordWithCodeInput({
    required String email,
    required String token,
    required String password,
    required String password_confirmation,
  }) =>
      Input$NewPasswordWithCodeInput._({
        r'email': email,
        r'token': token,
        r'password': password,
        r'password_confirmation': password_confirmation,
      });

  Input$NewPasswordWithCodeInput._(this._$data);

  factory Input$NewPasswordWithCodeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$token = data['token'];
    result$data['token'] = (l$token as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    final l$password_confirmation = data['password_confirmation'];
    result$data['password_confirmation'] = (l$password_confirmation as String);
    return Input$NewPasswordWithCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get email => (_$data['email'] as String);

  String get token => (_$data['token'] as String);

  String get password => (_$data['password'] as String);

  String get password_confirmation =>
      (_$data['password_confirmation'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$email = email;
    result$data['email'] = l$email;
    final l$token = token;
    result$data['token'] = l$token;
    final l$password = password;
    result$data['password'] = l$password;
    final l$password_confirmation = password_confirmation;
    result$data['password_confirmation'] = l$password_confirmation;
    return result$data;
  }

  CopyWith$Input$NewPasswordWithCodeInput<Input$NewPasswordWithCodeInput>
      get copyWith => CopyWith$Input$NewPasswordWithCodeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NewPasswordWithCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$token = token;
    final lOther$token = other.token;
    if (l$token != lOther$token) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$password_confirmation = password_confirmation;
    final lOther$password_confirmation = other.password_confirmation;
    if (l$password_confirmation != lOther$password_confirmation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$email = email;
    final l$token = token;
    final l$password = password;
    final l$password_confirmation = password_confirmation;
    return Object.hashAll([
      l$email,
      l$token,
      l$password,
      l$password_confirmation,
    ]);
  }
}

abstract class CopyWith$Input$NewPasswordWithCodeInput<TRes> {
  factory CopyWith$Input$NewPasswordWithCodeInput(
    Input$NewPasswordWithCodeInput instance,
    TRes Function(Input$NewPasswordWithCodeInput) then,
  ) = _CopyWithImpl$Input$NewPasswordWithCodeInput;

  factory CopyWith$Input$NewPasswordWithCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NewPasswordWithCodeInput;

  TRes call({
    String? email,
    String? token,
    String? password,
    String? password_confirmation,
  });
}

class _CopyWithImpl$Input$NewPasswordWithCodeInput<TRes>
    implements CopyWith$Input$NewPasswordWithCodeInput<TRes> {
  _CopyWithImpl$Input$NewPasswordWithCodeInput(
    this._instance,
    this._then,
  );

  final Input$NewPasswordWithCodeInput _instance;

  final TRes Function(Input$NewPasswordWithCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? email = _undefined,
    Object? token = _undefined,
    Object? password = _undefined,
    Object? password_confirmation = _undefined,
  }) =>
      _then(Input$NewPasswordWithCodeInput._({
        ..._instance._$data,
        if (email != _undefined && email != null) 'email': (email as String),
        if (token != _undefined && token != null) 'token': (token as String),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (password_confirmation != _undefined &&
            password_confirmation != null)
          'password_confirmation': (password_confirmation as String),
      }));
}

class _CopyWithStubImpl$Input$NewPasswordWithCodeInput<TRes>
    implements CopyWith$Input$NewPasswordWithCodeInput<TRes> {
  _CopyWithStubImpl$Input$NewPasswordWithCodeInput(this._res);

  TRes _res;

  call({
    String? email,
    String? token,
    String? password,
    String? password_confirmation,
  }) =>
      _res;
}

class Input$RegisterInput {
  factory Input$RegisterInput({
    required String name,
    required String email,
    required String password,
    required String password_confirmation,
  }) =>
      Input$RegisterInput._({
        r'name': name,
        r'email': email,
        r'password': password,
        r'password_confirmation': password_confirmation,
      });

  Input$RegisterInput._(this._$data);

  factory Input$RegisterInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    final l$password_confirmation = data['password_confirmation'];
    result$data['password_confirmation'] = (l$password_confirmation as String);
    return Input$RegisterInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get email => (_$data['email'] as String);

  String get password => (_$data['password'] as String);

  String get password_confirmation =>
      (_$data['password_confirmation'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    final l$password_confirmation = password_confirmation;
    result$data['password_confirmation'] = l$password_confirmation;
    return result$data;
  }

  CopyWith$Input$RegisterInput<Input$RegisterInput> get copyWith =>
      CopyWith$Input$RegisterInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RegisterInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$password_confirmation = password_confirmation;
    final lOther$password_confirmation = other.password_confirmation;
    if (l$password_confirmation != lOther$password_confirmation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$email = email;
    final l$password = password;
    final l$password_confirmation = password_confirmation;
    return Object.hashAll([
      l$name,
      l$email,
      l$password,
      l$password_confirmation,
    ]);
  }
}

abstract class CopyWith$Input$RegisterInput<TRes> {
  factory CopyWith$Input$RegisterInput(
    Input$RegisterInput instance,
    TRes Function(Input$RegisterInput) then,
  ) = _CopyWithImpl$Input$RegisterInput;

  factory CopyWith$Input$RegisterInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RegisterInput;

  TRes call({
    String? name,
    String? email,
    String? password,
    String? password_confirmation,
  });
}

class _CopyWithImpl$Input$RegisterInput<TRes>
    implements CopyWith$Input$RegisterInput<TRes> {
  _CopyWithImpl$Input$RegisterInput(
    this._instance,
    this._then,
  );

  final Input$RegisterInput _instance;

  final TRes Function(Input$RegisterInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? password_confirmation = _undefined,
  }) =>
      _then(Input$RegisterInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (email != _undefined && email != null) 'email': (email as String),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (password_confirmation != _undefined &&
            password_confirmation != null)
          'password_confirmation': (password_confirmation as String),
      }));
}

class _CopyWithStubImpl$Input$RegisterInput<TRes>
    implements CopyWith$Input$RegisterInput<TRes> {
  _CopyWithStubImpl$Input$RegisterInput(this._res);

  TRes _res;

  call({
    String? name,
    String? email,
    String? password,
    String? password_confirmation,
  }) =>
      _res;
}

class Input$SocialLoginInput {
  factory Input$SocialLoginInput({
    required String provider,
    required String token,
  }) =>
      Input$SocialLoginInput._({
        r'provider': provider,
        r'token': token,
      });

  Input$SocialLoginInput._(this._$data);

  factory Input$SocialLoginInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$provider = data['provider'];
    result$data['provider'] = (l$provider as String);
    final l$token = data['token'];
    result$data['token'] = (l$token as String);
    return Input$SocialLoginInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get provider => (_$data['provider'] as String);

  String get token => (_$data['token'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$provider = provider;
    result$data['provider'] = l$provider;
    final l$token = token;
    result$data['token'] = l$token;
    return result$data;
  }

  CopyWith$Input$SocialLoginInput<Input$SocialLoginInput> get copyWith =>
      CopyWith$Input$SocialLoginInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SocialLoginInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$provider = provider;
    final lOther$provider = other.provider;
    if (l$provider != lOther$provider) {
      return false;
    }
    final l$token = token;
    final lOther$token = other.token;
    if (l$token != lOther$token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$provider = provider;
    final l$token = token;
    return Object.hashAll([
      l$provider,
      l$token,
    ]);
  }
}

abstract class CopyWith$Input$SocialLoginInput<TRes> {
  factory CopyWith$Input$SocialLoginInput(
    Input$SocialLoginInput instance,
    TRes Function(Input$SocialLoginInput) then,
  ) = _CopyWithImpl$Input$SocialLoginInput;

  factory CopyWith$Input$SocialLoginInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SocialLoginInput;

  TRes call({
    String? provider,
    String? token,
  });
}

class _CopyWithImpl$Input$SocialLoginInput<TRes>
    implements CopyWith$Input$SocialLoginInput<TRes> {
  _CopyWithImpl$Input$SocialLoginInput(
    this._instance,
    this._then,
  );

  final Input$SocialLoginInput _instance;

  final TRes Function(Input$SocialLoginInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? provider = _undefined,
    Object? token = _undefined,
  }) =>
      _then(Input$SocialLoginInput._({
        ..._instance._$data,
        if (provider != _undefined && provider != null)
          'provider': (provider as String),
        if (token != _undefined && token != null) 'token': (token as String),
      }));
}

class _CopyWithStubImpl$Input$SocialLoginInput<TRes>
    implements CopyWith$Input$SocialLoginInput<TRes> {
  _CopyWithStubImpl$Input$SocialLoginInput(this._res);

  TRes _res;

  call({
    String? provider,
    String? token,
  }) =>
      _res;
}

class Input$VerifyEmailInput {
  factory Input$VerifyEmailInput({required String token}) =>
      Input$VerifyEmailInput._({
        r'token': token,
      });

  Input$VerifyEmailInput._(this._$data);

  factory Input$VerifyEmailInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$token = data['token'];
    result$data['token'] = (l$token as String);
    return Input$VerifyEmailInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get token => (_$data['token'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$token = token;
    result$data['token'] = l$token;
    return result$data;
  }

  CopyWith$Input$VerifyEmailInput<Input$VerifyEmailInput> get copyWith =>
      CopyWith$Input$VerifyEmailInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VerifyEmailInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$token = token;
    final lOther$token = other.token;
    if (l$token != lOther$token) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$token = token;
    return Object.hashAll([l$token]);
  }
}

abstract class CopyWith$Input$VerifyEmailInput<TRes> {
  factory CopyWith$Input$VerifyEmailInput(
    Input$VerifyEmailInput instance,
    TRes Function(Input$VerifyEmailInput) then,
  ) = _CopyWithImpl$Input$VerifyEmailInput;

  factory CopyWith$Input$VerifyEmailInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifyEmailInput;

  TRes call({String? token});
}

class _CopyWithImpl$Input$VerifyEmailInput<TRes>
    implements CopyWith$Input$VerifyEmailInput<TRes> {
  _CopyWithImpl$Input$VerifyEmailInput(
    this._instance,
    this._then,
  );

  final Input$VerifyEmailInput _instance;

  final TRes Function(Input$VerifyEmailInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? token = _undefined}) => _then(Input$VerifyEmailInput._({
        ..._instance._$data,
        if (token != _undefined && token != null) 'token': (token as String),
      }));
}

class _CopyWithStubImpl$Input$VerifyEmailInput<TRes>
    implements CopyWith$Input$VerifyEmailInput<TRes> {
  _CopyWithStubImpl$Input$VerifyEmailInput(this._res);

  TRes _res;

  call({String? token}) => _res;
}

class Input$UpdatePassword {
  factory Input$UpdatePassword({
    required String old_password,
    required String password,
    required String password_confirmation,
  }) =>
      Input$UpdatePassword._({
        r'old_password': old_password,
        r'password': password,
        r'password_confirmation': password_confirmation,
      });

  Input$UpdatePassword._(this._$data);

  factory Input$UpdatePassword.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$old_password = data['old_password'];
    result$data['old_password'] = (l$old_password as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    final l$password_confirmation = data['password_confirmation'];
    result$data['password_confirmation'] = (l$password_confirmation as String);
    return Input$UpdatePassword._(result$data);
  }

  Map<String, dynamic> _$data;

  String get old_password => (_$data['old_password'] as String);

  String get password => (_$data['password'] as String);

  String get password_confirmation =>
      (_$data['password_confirmation'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$old_password = old_password;
    result$data['old_password'] = l$old_password;
    final l$password = password;
    result$data['password'] = l$password;
    final l$password_confirmation = password_confirmation;
    result$data['password_confirmation'] = l$password_confirmation;
    return result$data;
  }

  CopyWith$Input$UpdatePassword<Input$UpdatePassword> get copyWith =>
      CopyWith$Input$UpdatePassword(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePassword) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$old_password = old_password;
    final lOther$old_password = other.old_password;
    if (l$old_password != lOther$old_password) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$password_confirmation = password_confirmation;
    final lOther$password_confirmation = other.password_confirmation;
    if (l$password_confirmation != lOther$password_confirmation) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$old_password = old_password;
    final l$password = password;
    final l$password_confirmation = password_confirmation;
    return Object.hashAll([
      l$old_password,
      l$password,
      l$password_confirmation,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePassword<TRes> {
  factory CopyWith$Input$UpdatePassword(
    Input$UpdatePassword instance,
    TRes Function(Input$UpdatePassword) then,
  ) = _CopyWithImpl$Input$UpdatePassword;

  factory CopyWith$Input$UpdatePassword.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePassword;

  TRes call({
    String? old_password,
    String? password,
    String? password_confirmation,
  });
}

class _CopyWithImpl$Input$UpdatePassword<TRes>
    implements CopyWith$Input$UpdatePassword<TRes> {
  _CopyWithImpl$Input$UpdatePassword(
    this._instance,
    this._then,
  );

  final Input$UpdatePassword _instance;

  final TRes Function(Input$UpdatePassword) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? old_password = _undefined,
    Object? password = _undefined,
    Object? password_confirmation = _undefined,
  }) =>
      _then(Input$UpdatePassword._({
        ..._instance._$data,
        if (old_password != _undefined && old_password != null)
          'old_password': (old_password as String),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (password_confirmation != _undefined &&
            password_confirmation != null)
          'password_confirmation': (password_confirmation as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePassword<TRes>
    implements CopyWith$Input$UpdatePassword<TRes> {
  _CopyWithStubImpl$Input$UpdatePassword(this._res);

  TRes _res;

  call({
    String? old_password,
    String? password,
    String? password_confirmation,
  }) =>
      _res;
}

class Input$OrderByClause {
  factory Input$OrderByClause({
    required String column,
    required Enum$SortOrder order,
  }) =>
      Input$OrderByClause._({
        r'column': column,
        r'order': order,
      });

  Input$OrderByClause._(this._$data);

  factory Input$OrderByClause.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$column = data['column'];
    result$data['column'] = (l$column as String);
    final l$order = data['order'];
    result$data['order'] = fromJson$Enum$SortOrder((l$order as String));
    return Input$OrderByClause._(result$data);
  }

  Map<String, dynamic> _$data;

  String get column => (_$data['column'] as String);

  Enum$SortOrder get order => (_$data['order'] as Enum$SortOrder);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$column = column;
    result$data['column'] = l$column;
    final l$order = order;
    result$data['order'] = toJson$Enum$SortOrder(l$order);
    return result$data;
  }

  CopyWith$Input$OrderByClause<Input$OrderByClause> get copyWith =>
      CopyWith$Input$OrderByClause(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OrderByClause) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$column = column;
    final lOther$column = other.column;
    if (l$column != lOther$column) {
      return false;
    }
    final l$order = order;
    final lOther$order = other.order;
    if (l$order != lOther$order) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$column = column;
    final l$order = order;
    return Object.hashAll([
      l$column,
      l$order,
    ]);
  }
}

abstract class CopyWith$Input$OrderByClause<TRes> {
  factory CopyWith$Input$OrderByClause(
    Input$OrderByClause instance,
    TRes Function(Input$OrderByClause) then,
  ) = _CopyWithImpl$Input$OrderByClause;

  factory CopyWith$Input$OrderByClause.stub(TRes res) =
      _CopyWithStubImpl$Input$OrderByClause;

  TRes call({
    String? column,
    Enum$SortOrder? order,
  });
}

class _CopyWithImpl$Input$OrderByClause<TRes>
    implements CopyWith$Input$OrderByClause<TRes> {
  _CopyWithImpl$Input$OrderByClause(
    this._instance,
    this._then,
  );

  final Input$OrderByClause _instance;

  final TRes Function(Input$OrderByClause) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? column = _undefined,
    Object? order = _undefined,
  }) =>
      _then(Input$OrderByClause._({
        ..._instance._$data,
        if (column != _undefined && column != null)
          'column': (column as String),
        if (order != _undefined && order != null)
          'order': (order as Enum$SortOrder),
      }));
}

class _CopyWithStubImpl$Input$OrderByClause<TRes>
    implements CopyWith$Input$OrderByClause<TRes> {
  _CopyWithStubImpl$Input$OrderByClause(this._res);

  TRes _res;

  call({
    String? column,
    Enum$SortOrder? order,
  }) =>
      _res;
}

enum Enum$RegisterStatuses {
  MUST_VERIFY_EMAIL,
  SUCCESS,
  $unknown;

  factory Enum$RegisterStatuses.fromJson(String value) =>
      fromJson$Enum$RegisterStatuses(value);

  String toJson() => toJson$Enum$RegisterStatuses(this);
}

String toJson$Enum$RegisterStatuses(Enum$RegisterStatuses e) {
  switch (e) {
    case Enum$RegisterStatuses.MUST_VERIFY_EMAIL:
      return r'MUST_VERIFY_EMAIL';
    case Enum$RegisterStatuses.SUCCESS:
      return r'SUCCESS';
    case Enum$RegisterStatuses.$unknown:
      return r'$unknown';
  }
}

Enum$RegisterStatuses fromJson$Enum$RegisterStatuses(String value) {
  switch (value) {
    case r'MUST_VERIFY_EMAIL':
      return Enum$RegisterStatuses.MUST_VERIFY_EMAIL;
    case r'SUCCESS':
      return Enum$RegisterStatuses.SUCCESS;
    default:
      return Enum$RegisterStatuses.$unknown;
  }
}

enum Enum$SortOrder {
  ASC,
  DESC,
  $unknown;

  factory Enum$SortOrder.fromJson(String value) =>
      fromJson$Enum$SortOrder(value);

  String toJson() => toJson$Enum$SortOrder(this);
}

String toJson$Enum$SortOrder(Enum$SortOrder e) {
  switch (e) {
    case Enum$SortOrder.ASC:
      return r'ASC';
    case Enum$SortOrder.DESC:
      return r'DESC';
    case Enum$SortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$SortOrder fromJson$Enum$SortOrder(String value) {
  switch (value) {
    case r'ASC':
      return Enum$SortOrder.ASC;
    case r'DESC':
      return Enum$SortOrder.DESC;
    default:
      return Enum$SortOrder.$unknown;
  }
}

enum Enum$OrderByRelationAggregateFunction {
  COUNT,
  $unknown;

  factory Enum$OrderByRelationAggregateFunction.fromJson(String value) =>
      fromJson$Enum$OrderByRelationAggregateFunction(value);

  String toJson() => toJson$Enum$OrderByRelationAggregateFunction(this);
}

String toJson$Enum$OrderByRelationAggregateFunction(
    Enum$OrderByRelationAggregateFunction e) {
  switch (e) {
    case Enum$OrderByRelationAggregateFunction.COUNT:
      return r'COUNT';
    case Enum$OrderByRelationAggregateFunction.$unknown:
      return r'$unknown';
  }
}

Enum$OrderByRelationAggregateFunction
    fromJson$Enum$OrderByRelationAggregateFunction(String value) {
  switch (value) {
    case r'COUNT':
      return Enum$OrderByRelationAggregateFunction.COUNT;
    default:
      return Enum$OrderByRelationAggregateFunction.$unknown;
  }
}

enum Enum$OrderByRelationWithColumnAggregateFunction {
  AVG,
  MIN,
  MAX,
  SUM,
  COUNT,
  $unknown;

  factory Enum$OrderByRelationWithColumnAggregateFunction.fromJson(
          String value) =>
      fromJson$Enum$OrderByRelationWithColumnAggregateFunction(value);

  String toJson() =>
      toJson$Enum$OrderByRelationWithColumnAggregateFunction(this);
}

String toJson$Enum$OrderByRelationWithColumnAggregateFunction(
    Enum$OrderByRelationWithColumnAggregateFunction e) {
  switch (e) {
    case Enum$OrderByRelationWithColumnAggregateFunction.AVG:
      return r'AVG';
    case Enum$OrderByRelationWithColumnAggregateFunction.MIN:
      return r'MIN';
    case Enum$OrderByRelationWithColumnAggregateFunction.MAX:
      return r'MAX';
    case Enum$OrderByRelationWithColumnAggregateFunction.SUM:
      return r'SUM';
    case Enum$OrderByRelationWithColumnAggregateFunction.COUNT:
      return r'COUNT';
    case Enum$OrderByRelationWithColumnAggregateFunction.$unknown:
      return r'$unknown';
  }
}

Enum$OrderByRelationWithColumnAggregateFunction
    fromJson$Enum$OrderByRelationWithColumnAggregateFunction(String value) {
  switch (value) {
    case r'AVG':
      return Enum$OrderByRelationWithColumnAggregateFunction.AVG;
    case r'MIN':
      return Enum$OrderByRelationWithColumnAggregateFunction.MIN;
    case r'MAX':
      return Enum$OrderByRelationWithColumnAggregateFunction.MAX;
    case r'SUM':
      return Enum$OrderByRelationWithColumnAggregateFunction.SUM;
    case r'COUNT':
      return Enum$OrderByRelationWithColumnAggregateFunction.COUNT;
    default:
      return Enum$OrderByRelationWithColumnAggregateFunction.$unknown;
  }
}

enum Enum$Trashed {
  ONLY,
  WITH,
  WITHOUT,
  $unknown;

  factory Enum$Trashed.fromJson(String value) => fromJson$Enum$Trashed(value);

  String toJson() => toJson$Enum$Trashed(this);
}

String toJson$Enum$Trashed(Enum$Trashed e) {
  switch (e) {
    case Enum$Trashed.ONLY:
      return r'ONLY';
    case Enum$Trashed.WITH:
      return r'WITH';
    case Enum$Trashed.WITHOUT:
      return r'WITHOUT';
    case Enum$Trashed.$unknown:
      return r'$unknown';
  }
}

Enum$Trashed fromJson$Enum$Trashed(String value) {
  switch (value) {
    case r'ONLY':
      return Enum$Trashed.ONLY;
    case r'WITH':
      return Enum$Trashed.WITH;
    case r'WITHOUT':
      return Enum$Trashed.WITHOUT;
    default:
      return Enum$Trashed.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown;

  factory Enum$__TypeKind.fromJson(String value) =>
      fromJson$Enum$__TypeKind(value);

  String toJson() => toJson$Enum$__TypeKind(this);
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown;

  factory Enum$__DirectiveLocation.fromJson(String value) =>
      fromJson$Enum$__DirectiveLocation(value);

  String toJson() => toJson$Enum$__DirectiveLocation(this);
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
